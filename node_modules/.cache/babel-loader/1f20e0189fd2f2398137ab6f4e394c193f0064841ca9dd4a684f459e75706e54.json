{"ast":null,"code":"import Papa from 'papaparse';\n\n// Simple data service for beginner-friendly version\nclass SimpleDataService {\n  // Fetch and parse patient CSV data\n  static async getPatientData(patientId) {\n    if (!patientId) {\n      throw new Error('Patient ID is required');\n    }\n    try {\n      // Fetch the CSV file\n      const response = await fetch(`/synthetic_patients/${patientId}.csv`);\n      if (!response.ok) {\n        throw new Error(`Could not load data for ${patientId}`);\n      }\n      const csvText = await response.text();\n\n      // Parse CSV with PapaParse\n      const parsed = Papa.parse(csvText, {\n        header: true,\n        skipEmptyLines: true\n      });\n      if (parsed.errors.length > 0) {\n        console.warn('CSV parsing warnings:', parsed.errors);\n      }\n      return this.processPatientData(parsed.data, patientId);\n    } catch (error) {\n      console.error('Error loading patient data:', error);\n      throw error;\n    }\n  }\n\n  // Process raw CSV data into organized structure\n  static processPatientData(rows, patientId) {\n    if (!rows || rows.length === 0) {\n      throw new Error('No data found');\n    }\n    const firstRow = rows[0];\n\n    // Extract patient info from first row\n    const patientInfo = {\n      patientId,\n      patientNumber: patientId,\n      age: firstRow['Age'] || 'Not specified',\n      gender: firstRow['Gender'] || 'Not specified',\n      conditions: firstRow['Chronic_Conditions'] ? firstRow['Chronic_Conditions'].split(';').map(c => c.trim()) : [],\n      medications: this.extractMedications(firstRow['Medications'] || ''),\n      dataAvailable: 'May 2025'\n    };\n\n    // Process different types of health data\n    return {\n      patientInfo,\n      glucoseData: this.processGlucoseData(rows),\n      bloodPressureData: this.processBloodPressureData(rows),\n      exerciseData: this.processExerciseData(rows),\n      moodData: this.processMoodData(rows),\n      painData: this.processPainData(rows),\n      sleepData: this.processSleepData(rows),\n      mealData: this.processMealData(rows),\n      rawData: rows\n    };\n  }\n\n  // Extract medications from string\n  static extractMedications(medicationString) {\n    if (!medicationString) return [];\n    return medicationString.split(';').map(med => {\n      const trimmed = med.trim();\n      // Simple parsing - just extract name before first parenthesis\n      const nameMatch = trimmed.match(/^([^(]+)/);\n      return {\n        name: nameMatch ? nameMatch[1].trim() : trimmed,\n        details: trimmed\n      };\n    });\n  }\n\n  // Process glucose readings\n  static processGlucoseData(rows) {\n    const readings = [];\n    rows.forEach(row => {\n      const date = new Date(row['Date']);\n\n      // Check for multi-column glucose data (Glucose_1, Glucose_2, etc.)\n      for (let i = 1; i <= 4; i++) {\n        const value = parseFloat(row[`Glucose_${i}`]);\n        const time = row[`Glucose_Time_${i}`];\n        const type = row[`Glucose_Measurement_Type_${i}`];\n        const range = row[`Glucose_Range_${i}`];\n        if (value > 0 && time) {\n          const [hours, minutes] = time.split(':').map(Number);\n          const readingDate = new Date(date);\n          readingDate.setHours(hours, minutes);\n          readings.push({\n            date: readingDate,\n            value,\n            measurementType: type || 'Unknown',\n            range: range || 'unknown'\n          });\n        }\n      }\n    });\n    return readings;\n  }\n\n  // Process blood pressure readings  \n  static processBloodPressureData(rows) {\n    const readings = [];\n    rows.forEach(row => {\n      const date = new Date(row['Date']);\n\n      // Check for multi-column BP data\n      for (let i = 1; i <= 4; i++) {\n        const systolic = parseInt(row[`Systolic_${i}`]);\n        const diastolic = parseInt(row[`Diastolic_${i}`]);\n        const time = row[`BP_Time_${i}`];\n        if (systolic > 0 && diastolic > 0 && time) {\n          const [hours, minutes] = time.split(':').map(Number);\n          const readingDate = new Date(date);\n          readingDate.setHours(hours, minutes);\n          readings.push({\n            date: readingDate,\n            systolic,\n            diastolic\n          });\n        }\n      }\n    });\n    return readings;\n  }\n\n  // Process exercise data\n  static processExerciseData(rows) {\n    const exerciseByDate = {};\n    rows.forEach(row => {\n      const date = new Date(row['Date']);\n      const dateKey = date.toDateString();\n      if (!exerciseByDate[dateKey]) {\n        exerciseByDate[dateKey] = {\n          date,\n          totalMinutes: 0,\n          activities: []\n        };\n      }\n\n      // Check for multiple exercise entries\n      for (let i = 1; i <= 3; i++) {\n        const type = row[`Exercise_Type_${i}`];\n        const minutes = parseInt(row[`Exercise_Minutes_${i}`]) || 0;\n        if (type && minutes > 0) {\n          exerciseByDate[dateKey].activities.push({\n            type,\n            minutes\n          });\n          exerciseByDate[dateKey].totalMinutes += minutes;\n        }\n      }\n    });\n    return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n  }\n\n  // Process mood data\n  static processMoodData(rows) {\n    return rows.filter(row => row['Mood']).map(row => ({\n      date: new Date(row['Date']),\n      mood: row['Mood']\n    }));\n  }\n\n  // Process pain data\n  static processPainData(rows) {\n    return rows.filter(row => row['Pain_Location'] && row['Pain_Level']).map(row => ({\n      date: new Date(row['Date']),\n      location: row['Pain_Location'],\n      level: parseInt(row['Pain_Level']) || 0\n    }));\n  }\n\n  // Process sleep data\n  static processSleepData(rows) {\n    return rows.filter(row => row['Sleep_Hours'] && row['Sleep_Quality']).map(row => ({\n      date: new Date(row['Date']),\n      hours: parseFloat(row['Sleep_Hours']) || 0,\n      quality: row['Sleep_Quality'],\n      qualityCode: parseInt(row['Sleep_Quality_Code']) || 0\n    }));\n  }\n\n  // Process meal data\n  static processMealData(rows) {\n    return rows.filter(row => {\n      // Check if any meal data exists for this day\n      const mealTypes = ['Breakfast', 'Lunch', 'Dinner'];\n      return mealTypes.some(mealType => {\n        const time = row[`${mealType}_Time`];\n        const hasComponents = ['Protein', 'Carbohydrates', 'Vegetables', 'Fruit'].some(component => row[`${mealType}_${component}`] === '1');\n        return time && hasComponents;\n      });\n    }).map(row => ({\n      date: new Date(row['Date']),\n      rawData: row // Keep raw data for meal component processing\n    }));\n  }\n}\nexport default SimpleDataService;","map":{"version":3,"names":["Papa","SimpleDataService","getPatientData","patientId","Error","response","fetch","ok","csvText","text","parsed","parse","header","skipEmptyLines","errors","length","console","warn","processPatientData","data","error","rows","firstRow","patientInfo","patientNumber","age","gender","conditions","split","map","c","trim","medications","extractMedications","dataAvailable","glucoseData","processGlucoseData","bloodPressureData","processBloodPressureData","exerciseData","processExerciseData","moodData","processMoodData","painData","processPainData","sleepData","processSleepData","mealData","processMealData","rawData","medicationString","med","trimmed","nameMatch","match","name","details","readings","forEach","row","date","Date","i","value","parseFloat","time","type","range","hours","minutes","Number","readingDate","setHours","push","measurementType","systolic","parseInt","diastolic","exerciseByDate","dateKey","toDateString","totalMinutes","activities","Object","values","filter","d","mood","location","level","quality","qualityCode","mealTypes","some","mealType","hasComponents","component"],"sources":["C:/Users/Matteo/Working_Folder/a. MCC Thesis Local/MCC_digital_health_data_visualizations/src/services/dataService_simple.js"],"sourcesContent":["import Papa from 'papaparse';\r\n\r\n// Simple data service for beginner-friendly version\r\nclass SimpleDataService {\r\n  \r\n  // Fetch and parse patient CSV data\r\n  static async getPatientData(patientId) {\r\n    if (!patientId) {\r\n      throw new Error('Patient ID is required');\r\n    }\r\n\r\n    try {\r\n      // Fetch the CSV file\r\n      const response = await fetch(`/synthetic_patients/${patientId}.csv`);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`Could not load data for ${patientId}`);\r\n      }\r\n      \r\n      const csvText = await response.text();\r\n      \r\n      // Parse CSV with PapaParse\r\n      const parsed = Papa.parse(csvText, {\r\n        header: true,\r\n        skipEmptyLines: true,\r\n      });\r\n      \r\n      if (parsed.errors.length > 0) {\r\n        console.warn('CSV parsing warnings:', parsed.errors);\r\n      }\r\n      \r\n      return this.processPatientData(parsed.data, patientId);\r\n      \r\n    } catch (error) {\r\n      console.error('Error loading patient data:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Process raw CSV data into organized structure\r\n  static processPatientData(rows, patientId) {\r\n    if (!rows || rows.length === 0) {\r\n      throw new Error('No data found');\r\n    }\r\n\r\n    const firstRow = rows[0];\r\n    \r\n    // Extract patient info from first row\r\n    const patientInfo = {\r\n      patientId,\r\n      patientNumber: patientId,\r\n      age: firstRow['Age'] || 'Not specified',\r\n      gender: firstRow['Gender'] || 'Not specified',\r\n      conditions: firstRow['Chronic_Conditions'] ? \r\n        firstRow['Chronic_Conditions'].split(';').map(c => c.trim()) : [],\r\n      medications: this.extractMedications(firstRow['Medications'] || ''),\r\n      dataAvailable: 'May 2025'\r\n    };\r\n\r\n    // Process different types of health data\r\n    return {\r\n      patientInfo,\r\n      glucoseData: this.processGlucoseData(rows),\r\n      bloodPressureData: this.processBloodPressureData(rows),\r\n      exerciseData: this.processExerciseData(rows),\r\n      moodData: this.processMoodData(rows),\r\n      painData: this.processPainData(rows),\r\n      sleepData: this.processSleepData(rows),\r\n      mealData: this.processMealData(rows),\r\n      rawData: rows\r\n    };\r\n  }\r\n\r\n  // Extract medications from string\r\n  static extractMedications(medicationString) {\r\n    if (!medicationString) return [];\r\n    \r\n    return medicationString.split(';').map(med => {\r\n      const trimmed = med.trim();\r\n      // Simple parsing - just extract name before first parenthesis\r\n      const nameMatch = trimmed.match(/^([^(]+)/);\r\n      return {\r\n        name: nameMatch ? nameMatch[1].trim() : trimmed,\r\n        details: trimmed\r\n      };\r\n    });\r\n  }\r\n\r\n  // Process glucose readings\r\n  static processGlucoseData(rows) {\r\n    const readings = [];\r\n    \r\n    rows.forEach(row => {\r\n      const date = new Date(row['Date']);\r\n      \r\n      // Check for multi-column glucose data (Glucose_1, Glucose_2, etc.)\r\n      for (let i = 1; i <= 4; i++) {\r\n        const value = parseFloat(row[`Glucose_${i}`]);\r\n        const time = row[`Glucose_Time_${i}`];\r\n        const type = row[`Glucose_Measurement_Type_${i}`];\r\n        const range = row[`Glucose_Range_${i}`];\r\n        \r\n        if (value > 0 && time) {\r\n          const [hours, minutes] = time.split(':').map(Number);\r\n          const readingDate = new Date(date);\r\n          readingDate.setHours(hours, minutes);\r\n          \r\n          readings.push({\r\n            date: readingDate,\r\n            value,\r\n            measurementType: type || 'Unknown',\r\n            range: range || 'unknown'\r\n          });\r\n        }\r\n      }\r\n    });\r\n    \r\n    return readings;\r\n  }\r\n\r\n  // Process blood pressure readings  \r\n  static processBloodPressureData(rows) {\r\n    const readings = [];\r\n    \r\n    rows.forEach(row => {\r\n      const date = new Date(row['Date']);\r\n      \r\n      // Check for multi-column BP data\r\n      for (let i = 1; i <= 4; i++) {\r\n        const systolic = parseInt(row[`Systolic_${i}`]);\r\n        const diastolic = parseInt(row[`Diastolic_${i}`]);\r\n        const time = row[`BP_Time_${i}`];\r\n        \r\n        if (systolic > 0 && diastolic > 0 && time) {\r\n          const [hours, minutes] = time.split(':').map(Number);\r\n          const readingDate = new Date(date);\r\n          readingDate.setHours(hours, minutes);\r\n          \r\n          readings.push({\r\n            date: readingDate,\r\n            systolic,\r\n            diastolic\r\n          });\r\n        }\r\n      }\r\n    });\r\n    \r\n    return readings;\r\n  }\r\n\r\n  // Process exercise data\r\n  static processExerciseData(rows) {\r\n    const exerciseByDate = {};\r\n    \r\n    rows.forEach(row => {\r\n      const date = new Date(row['Date']);\r\n      const dateKey = date.toDateString();\r\n      \r\n      if (!exerciseByDate[dateKey]) {\r\n        exerciseByDate[dateKey] = { \r\n          date, \r\n          totalMinutes: 0, \r\n          activities: [] \r\n        };\r\n      }\r\n      \r\n      // Check for multiple exercise entries\r\n      for (let i = 1; i <= 3; i++) {\r\n        const type = row[`Exercise_Type_${i}`];\r\n        const minutes = parseInt(row[`Exercise_Minutes_${i}`]) || 0;\r\n        \r\n        if (type && minutes > 0) {\r\n          exerciseByDate[dateKey].activities.push({ type, minutes });\r\n          exerciseByDate[dateKey].totalMinutes += minutes;\r\n        }\r\n      }\r\n    });\r\n    \r\n    return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\r\n  }\r\n\r\n  // Process mood data\r\n  static processMoodData(rows) {\r\n    return rows\r\n      .filter(row => row['Mood'])\r\n      .map(row => ({\r\n        date: new Date(row['Date']),\r\n        mood: row['Mood']\r\n      }));\r\n  }\r\n\r\n  // Process pain data\r\n  static processPainData(rows) {\r\n    return rows\r\n      .filter(row => row['Pain_Location'] && row['Pain_Level'])\r\n      .map(row => ({\r\n        date: new Date(row['Date']),\r\n        location: row['Pain_Location'],\r\n        level: parseInt(row['Pain_Level']) || 0\r\n      }));\r\n  }\r\n\r\n  // Process sleep data\r\n  static processSleepData(rows) {\r\n    return rows\r\n      .filter(row => row['Sleep_Hours'] && row['Sleep_Quality'])\r\n      .map(row => ({\r\n        date: new Date(row['Date']),\r\n        hours: parseFloat(row['Sleep_Hours']) || 0,\r\n        quality: row['Sleep_Quality'],\r\n        qualityCode: parseInt(row['Sleep_Quality_Code']) || 0\r\n      }));\r\n  }\r\n\r\n  // Process meal data\r\n  static processMealData(rows) {\r\n    return rows.filter(row => {\r\n      // Check if any meal data exists for this day\r\n      const mealTypes = ['Breakfast', 'Lunch', 'Dinner'];\r\n      return mealTypes.some(mealType => {\r\n        const time = row[`${mealType}_Time`];\r\n        const hasComponents = ['Protein', 'Carbohydrates', 'Vegetables', 'Fruit'].some(\r\n          component => row[`${mealType}_${component}`] === '1'\r\n        );\r\n        return time && hasComponents;\r\n      });\r\n    }).map(row => ({\r\n      date: new Date(row['Date']),\r\n      rawData: row // Keep raw data for meal component processing\r\n    }));\r\n  }\r\n}\r\n\r\nexport default SimpleDataService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}