{"ast":null,"code":"import Papa from 'papaparse';\n\n// Simple CSV config\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: header => header.trim(),\n  transform: value => value === null || value === void 0 ? void 0 : value.trim()\n};\nclass DataService {\n  static async getPatientData(patientId) {\n    try {\n      // Load individual patient CSV file\n      const response = await fetch(`/synthetic_patients/${patientId}.csv`);\n      if (!response.ok) {\n        throw new Error(`No data found for patient ${patientId}`);\n      }\n      const csvText = await response.text();\n      const parsed = Papa.parse(csvText, CSV_CONFIG);\n      if (parsed.errors.length > 0) {\n        console.warn('CSV parsing warnings:', parsed.errors);\n      }\n      return this.processPatientData(parsed.data, patientId);\n    } catch (error) {\n      console.error('Error loading patient data:', error);\n      throw error;\n    }\n  }\n  static processPatientData(rows, patientId) {\n    const firstRow = rows[0];\n\n    // Extract basic patient info\n    // Since CSV parsing has issues with Gender column due to complex medication strings,\n    // we'll generate gender based on patient ID as a temporary solution\n    const generateGender = patientId => {\n      const numericId = parseInt(patientId.replace('Patient_', ''));\n      // Use patient ID to consistently assign gender (slight female bias as in original Python script)\n      return numericId % 3 === 0 ? 'Male' : 'Female';\n    };\n    const patientInfo = {\n      patientId,\n      patientNumber: patientId,\n      age: firstRow['Age'],\n      gender: generateGender(patientId),\n      dataAvailable: 'May 2025'\n    };\n\n    // Process medications with detailed information\n    const medicationsRaw = [...new Set(rows.map(row => row['Medications']).filter(med => med && med.trim()))];\n    const detailedMedications = [];\n    const conditionsSet = new Set();\n    medicationsRaw.forEach(medString => {\n      if (medString) {\n        const meds = medString.split('; ');\n        meds.forEach(med => {\n          const lastParenIndex = med.lastIndexOf('(');\n          if (lastParenIndex === -1) return;\n          const medName = med.substring(0, lastParenIndex).trim();\n          if (medName && !detailedMedications.some(m => m.name === medName)) {\n            const detailsStr = med.substring(lastParenIndex + 1, med.length - 1);\n            const details = detailsStr.split(',').map(d => d.trim());\n            const schedule = details[0] || 'Not specified';\n            const category = details[1] || '';\n            const dosage = details.slice(2).join(', ') || '';\n            detailedMedications.push({\n              name: medName,\n              schedule: schedule,\n              category: category,\n              dosage: dosage\n            });\n          }\n        });\n      }\n    });\n\n    // Also check for direct chronic conditions column\n    const chronicConditionsRaw = [...new Set(rows.map(row => row['Chronic_Conditions']).filter(condition => condition && condition.trim()))];\n    chronicConditionsRaw.forEach(conditionString => {\n      if (conditionString) {\n        const conditions = conditionString.split(',').map(c => c.trim());\n        conditions.forEach(condition => {\n          if (condition) {\n            conditionsSet.add(condition);\n          }\n        });\n      }\n    });\n    const conditions = Array.from(conditionsSet);\n\n    // Process glucose data - use CSV data if available, otherwise generate realistic data\n    const glucoseData = rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const readings = [];\n\n      // Check if we have glucose data in CSV\n      const hasGlucoseData = row['Glucose_1'] !== undefined;\n      if (hasGlucoseData) {\n        // Process CSV glucose data (Glucose_1-4)\n        for (let i = 1; i <= 4; i++) {\n          const glucoseValue = parseFloat(row[`Glucose_${i}`]);\n          const measurementType = row[`Glucose_Measurement_Type_${i}`];\n          const range = row[`Glucose_Range_${i}`];\n          const timeStr = row[`Glucose_Time_${i}`];\n          if (!isNaN(glucoseValue) && glucoseValue > 0) {\n            let readingDate = new Date(baseDate);\n\n            // Parse time if available\n            if (timeStr && timeStr.includes(':')) {\n              const [hours, minutes] = timeStr.split(':').map(Number);\n              readingDate.setHours(hours, minutes, 0, 0);\n            } else {\n              // Fallback to simulated times\n              const hour = 7 + Math.floor(Math.random() * 13); // 7am to 8pm\n              const minute = Math.floor(Math.random() * 60);\n              readingDate.setHours(hour, minute, 0, 0);\n            }\n            readings.push({\n              date: readingDate,\n              value: glucoseValue,\n              range: range || 'Normal',\n              measurementType: measurementType || 'Pre meal'\n            });\n          }\n        }\n      } else {\n        // Generate realistic data for patients without CSV glucose data\n        const patientNum = parseInt(patientId.replace('Patient_', '')) || parseInt(patientId);\n        const isDiabetic = patientNum % 3 === 2; // Every 3rd patient starting with 2 has diabetes\n\n        let baseGlucose;\n        if (isDiabetic) {\n          // Diabetic patient: higher, more variable glucose (6-15 mmol/L)\n          baseGlucose = 7.0 + Math.random() * 8.0;\n        } else {\n          // Non-diabetic patient: normal glucose (4-7 mmol/L)\n          baseGlucose = 4.5 + Math.random() * 2.5;\n        }\n\n        // Create 2-4 readings per day with simulated timestamps\n        const numReadings = Math.floor(Math.random() * 3) + 2; // 2-4 readings\n\n        for (let i = 0; i < numReadings; i++) {\n          // Generate realistic glucose measurement times\n          let hour, measurementType;\n          if (i === 0) {\n            // Fasting/morning reading (6-8am)\n            hour = 6 + Math.floor(Math.random() * 2);\n            measurementType = 'Pre meal';\n          } else if (i === 1) {\n            // Pre-lunch reading (11am-12pm)\n            hour = 11 + Math.floor(Math.random() * 1);\n            measurementType = 'Pre meal';\n          } else if (i === 2) {\n            // Post-meal reading (1-3pm)\n            hour = 13 + Math.floor(Math.random() * 2);\n            measurementType = '2-hour post meal';\n          } else {\n            // Evening reading (6-8pm)\n            hour = 18 + Math.floor(Math.random() * 2);\n            measurementType = Math.random() > 0.5 ? 'Pre meal' : '2-hour post meal';\n          }\n          const minute = Math.floor(Math.random() * 60);\n          const readingDate = new Date(baseDate);\n          readingDate.setHours(hour, minute, 0, 0);\n\n          // Add realistic variation based on measurement type\n          let glucoseValue;\n          if (measurementType === 'Pre meal') {\n            // Pre-meal: slight variation around base value\n            const variation = (Math.random() - 0.5) * 2;\n            glucoseValue = Math.max(3.0, Math.min(15.0, baseGlucose + variation));\n          } else {\n            // Post-meal: typically higher\n            const variation = (Math.random() - 0.5) * 3 + 2;\n            glucoseValue = Math.max(4.0, Math.min(20.0, baseGlucose + variation));\n          }\n\n          // Determine range based on value and type\n          let range;\n          if (measurementType === 'Pre meal') {\n            if (glucoseValue < 4.0) range = 'Low';else if (glucoseValue <= 7.0) range = 'Normal';else range = 'High';\n          } else {\n            if (glucoseValue < 4.0) range = 'Low';else if (glucoseValue <= 10.0) range = 'Normal';else range = 'High';\n          }\n          readings.push({\n            date: readingDate,\n            value: Math.round(glucoseValue * 10) / 10,\n            // Round to 1 decimal\n            range: range,\n            measurementType: measurementType\n          });\n        }\n      }\n      return readings;\n    });\n\n    // Process blood pressure data - robust handling of both new and old CSV structures\n\n    const bloodPressureData = rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const readings = [];\n\n      // Check if we have new multi-column structure\n      const hasNewStructure = row['Systolic_1'] !== undefined;\n      if (hasNewStructure) {\n        // Process new multi-column structure (Systolic_1-4, Diastolic_1-4)\n        for (let i = 1; i <= 4; i++) {\n          const systolic = parseInt(row[`Systolic_${i}`]);\n          const diastolic = parseInt(row[`Diastolic_${i}`]);\n          const bpTime = row[`BP_Time_${i}`];\n          const systolicType = row[`Systolic_Type_${i}`];\n          const diastolicType = row[`Diastolic_Type_${i}`];\n          if (!isNaN(systolic) && !isNaN(diastolic) && systolic > 0 && diastolic > 0) {\n            let readingDate = new Date(baseDate);\n\n            // Parse time if available, otherwise use simulated time\n            if (bpTime && bpTime.includes(':')) {\n              const [hours, minutes] = bpTime.split(':').map(Number);\n              readingDate.setHours(hours, minutes, 0, 0);\n            } else {\n              // Fallback to simulated times\n              const hour = 7 + Math.floor(Math.random() * 13); // 7am to 8pm\n              const minute = Math.floor(Math.random() * 60);\n              readingDate.setHours(hour, minute, 0, 0);\n            }\n            readings.push({\n              date: readingDate,\n              systolic: systolic,\n              diastolic: diastolic,\n              systolicType: systolicType || 'Normal',\n              diastolicType: diastolicType || 'Normal'\n            });\n          }\n        }\n      } else if (row['Systolic'] && row['Diastolic']) {\n        // Process old single column structure\n        const systolic = parseInt(row['Systolic']);\n        const diastolic = parseInt(row['Diastolic']);\n        if (!isNaN(systolic) && !isNaN(diastolic)) {\n          // Create 2-3 readings per day with simulated timestamps\n          const numReadings = Math.floor(Math.random() * 2) + 2; // 2-3 readings\n\n          for (let i = 0; i < numReadings; i++) {\n            // Generate realistic times: morning (7-10), afternoon (12-15), evening (17-20)\n            let hour;\n            if (i === 0) hour = 7 + Math.floor(Math.random() * 3); // Morning\n            else if (i === 1) hour = 12 + Math.floor(Math.random() * 3); // Afternoon  \n            else hour = 17 + Math.floor(Math.random() * 3); // Evening\n\n            const minute = Math.floor(Math.random() * 60);\n            const readingDate = new Date(baseDate);\n            readingDate.setHours(hour, minute, 0, 0);\n\n            // Add some variation to readings\n            const variation = (Math.random() - 0.5) * 10;\n            readings.push({\n              date: readingDate,\n              systolic: Math.max(80, Math.min(200, systolic + Math.floor(variation))),\n              diastolic: Math.max(50, Math.min(120, diastolic + Math.floor(variation / 2))),\n              systolicType: row['Systolic_Type'] || 'Normal',\n              diastolicType: row['Diastolic_Type'] || 'Normal'\n            });\n          }\n        }\n      }\n      return readings;\n    });\n\n    // Process exercise data - robust handling of both new and old CSV structures\n    const exerciseByDate = {};\n\n    // Check if we have new multi-column structure\n    const hasNewExerciseStructure = rows[0] && rows[0]['Exercise_Type_1'] !== undefined;\n    rows.forEach(row => {\n      const date = new Date(row['Date']);\n      const dateKey = date.toDateString();\n      if (!exerciseByDate[dateKey]) {\n        exerciseByDate[dateKey] = {\n          date: date,\n          walking: 0,\n          aerobic: 0,\n          strength: 0,\n          balance: 0,\n          other: 0,\n          totalMinutes: 0\n        };\n      }\n      if (hasNewExerciseStructure) {\n        // Process new multi-column structure (Exercise_Type_1-3, Exercise_Minutes_1-3)\n        for (let i = 1; i <= 3; i++) {\n          const exerciseType = row[`Exercise_Type_${i}`];\n          const exerciseMinutesRaw = row[`Exercise_Minutes_${i}`];\n          const exerciseMinutes = parseFloat(exerciseMinutesRaw);\n          if (exerciseType && exerciseType.trim() && !isNaN(exerciseMinutes) && exerciseMinutes > 0) {\n            const normalizedType = exerciseType.toLowerCase();\n\n            // Map exercise types to chart categories\n            if (normalizedType.includes('walking')) {\n              exerciseByDate[dateKey].walking += exerciseMinutes;\n            } else if (normalizedType.includes('aerobic')) {\n              exerciseByDate[dateKey].aerobic += exerciseMinutes;\n            } else if (normalizedType.includes('strength')) {\n              exerciseByDate[dateKey].strength += exerciseMinutes;\n            } else if (normalizedType.includes('balance')) {\n              exerciseByDate[dateKey].balance += exerciseMinutes;\n            } else {\n              exerciseByDate[dateKey].other += exerciseMinutes;\n            }\n            exerciseByDate[dateKey].totalMinutes += exerciseMinutes;\n          }\n        }\n      } else if (row['Exercise_Type'] && row['Exercise_Minutes']) {\n        // Process old single column structure\n        const exerciseType = row['Exercise_Type'];\n        const exerciseMinutesRaw = row['Exercise_Minutes'];\n        const exerciseMinutes = parseFloat(exerciseMinutesRaw);\n        if (exerciseType && exerciseType.trim() && !isNaN(exerciseMinutes) && exerciseMinutes > 0) {\n          const normalizedType = exerciseType.toLowerCase();\n\n          // Map exercise types to chart categories\n          if (normalizedType.includes('walking')) {\n            exerciseByDate[dateKey].walking += exerciseMinutes;\n          } else if (normalizedType.includes('aerobic')) {\n            exerciseByDate[dateKey].aerobic += exerciseMinutes;\n          } else if (normalizedType.includes('strength')) {\n            exerciseByDate[dateKey].strength += exerciseMinutes;\n          } else if (normalizedType.includes('balance')) {\n            exerciseByDate[dateKey].balance += exerciseMinutes;\n          } else {\n            exerciseByDate[dateKey].other += exerciseMinutes;\n          }\n          exerciseByDate[dateKey].totalMinutes += exerciseMinutes;\n        }\n      }\n    });\n    const exerciseData = Object.values(exerciseByDate).filter(day => day.totalMinutes > 0);\n\n    // Process mood data\n    const moodData = rows.filter(row => row['Mood']).map(row => ({\n      date: new Date(row['Date']),\n      mood: row['Mood'],\n      category: row['Mood'] || 'neutral'\n    }));\n\n    // Process pain data\n    const painData = rows.filter(row => row['Pain_Location'] && row['Pain_Level'] !== undefined).map(row => ({\n      date: new Date(row['Date']),\n      location: row['Pain_Location'].toLowerCase(),\n      level: parseInt(row['Pain_Level']) || 0\n    }));\n\n    // Process sleep data\n    const sleepData = rows.filter(row => row['Sleep_Hours'] && row['Sleep_Quality']).map(row => ({\n      date: new Date(row['Date']),\n      hours: parseFloat(row['Sleep_Hours']),\n      quality: row['Sleep_Quality'],\n      qualityCode: parseInt(row['Sleep_Quality_Code'])\n    }));\n\n    // Process meal data\n    const mealData = rows.map(row => ({\n      Date: row['Date'],\n      Breakfast_Protein: row['Breakfast_Protein'],\n      Breakfast_Vegetables: row['Breakfast_Vegetables'],\n      Breakfast_Fruit: row['Breakfast_Fruit'],\n      Breakfast_Alcohol: row['Breakfast_Alcohol'],\n      Breakfast_Carbohydrates: row['Breakfast_Carbohydrates'],\n      Breakfast_Added_Sugar: row['Breakfast_Added_Sugar'],\n      Lunch_Protein: row['Lunch_Protein'],\n      Lunch_Vegetables: row['Lunch_Vegetables'],\n      Lunch_Fruit: row['Lunch_Fruit'],\n      Lunch_Alcohol: row['Lunch_Alcohol'],\n      Lunch_Carbohydrates: row['Lunch_Carbohydrates'],\n      Lunch_Added_Sugar: row['Lunch_Added_Sugar'],\n      Dinner_Protein: row['Dinner_Protein'],\n      Dinner_Vegetables: row['Dinner_Vegetables'],\n      Dinner_Fruit: row['Dinner_Fruit'],\n      Dinner_Alcohol: row['Dinner_Alcohol'],\n      Dinner_Carbohydrates: row['Dinner_Carbohydrates'],\n      Dinner_Added_Sugar: row['Dinner_Added_Sugar'],\n      Breakfast_Time: row['Breakfast_Time'],\n      Lunch_Time: row['Lunch_Time'],\n      Dinner_Time: row['Dinner_Time']\n    }));\n    return {\n      patientInfo: {\n        ...patientInfo,\n        detailedMedications,\n        conditions\n      },\n      glucoseData,\n      bloodPressureData,\n      exerciseData,\n      moodData,\n      painData,\n      mealData,\n      sleepData,\n      rawData: rows\n    };\n  }\n  static clearCache() {\n    patientDataCache.clear();\n  }\n  static getCacheSize() {\n    return patientDataCache.size;\n  }\n}\nexport default DataService;","map":{"version":3,"names":["Papa","CSV_CONFIG","header","skipEmptyLines","transformHeader","trim","transform","value","DataService","getPatientData","patientId","response","fetch","ok","Error","csvText","text","parsed","parse","errors","length","console","warn","processPatientData","data","error","rows","firstRow","generateGender","numericId","parseInt","replace","patientInfo","patientNumber","age","gender","dataAvailable","medicationsRaw","Set","map","row","filter","med","detailedMedications","conditionsSet","forEach","medString","meds","split","lastParenIndex","lastIndexOf","medName","substring","some","m","name","detailsStr","details","d","schedule","category","dosage","slice","join","push","chronicConditionsRaw","condition","conditionString","conditions","c","add","Array","from","glucoseData","flatMap","baseDate","Date","readings","hasGlucoseData","undefined","i","glucoseValue","parseFloat","measurementType","range","timeStr","isNaN","readingDate","includes","hours","minutes","Number","setHours","hour","Math","floor","random","minute","date","patientNum","isDiabetic","baseGlucose","numReadings","variation","max","min","round","bloodPressureData","hasNewStructure","systolic","diastolic","bpTime","systolicType","diastolicType","exerciseByDate","hasNewExerciseStructure","dateKey","toDateString","walking","aerobic","strength","balance","other","totalMinutes","exerciseType","exerciseMinutesRaw","exerciseMinutes","normalizedType","toLowerCase","exerciseData","Object","values","day","moodData","mood","painData","location","level","sleepData","quality","qualityCode","mealData","Breakfast_Protein","Breakfast_Vegetables","Breakfast_Fruit","Breakfast_Alcohol","Breakfast_Carbohydrates","Breakfast_Added_Sugar","Lunch_Protein","Lunch_Vegetables","Lunch_Fruit","Lunch_Alcohol","Lunch_Carbohydrates","Lunch_Added_Sugar","Dinner_Protein","Dinner_Vegetables","Dinner_Fruit","Dinner_Alcohol","Dinner_Carbohydrates","Dinner_Added_Sugar","Breakfast_Time","Lunch_Time","Dinner_Time","rawData","clearCache","patientDataCache","clear","getCacheSize","size"],"sources":["C:/Users/Matteo/Working_Folder/a. MCC Thesis Local/MCC_digital_health_data_visualizations/src/services/dataService.js"],"sourcesContent":["import Papa from 'papaparse';\n\n// Simple CSV config\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: (header) => header.trim(),\n  transform: (value) => value?.trim()\n};\n\nclass DataService {\n  static async getPatientData(patientId) {\n    try {\n      // Load individual patient CSV file\n      const response = await fetch(`/synthetic_patients/${patientId}.csv`);\n      if (!response.ok) {\n        throw new Error(`No data found for patient ${patientId}`);\n      }\n      \n      const csvText = await response.text();\n      const parsed = Papa.parse(csvText, CSV_CONFIG);\n      \n      if (parsed.errors.length > 0) {\n        console.warn('CSV parsing warnings:', parsed.errors);\n      }\n      \n      return this.processPatientData(parsed.data, patientId);\n    } catch (error) {\n      console.error('Error loading patient data:', error);\n      throw error;\n    }\n  }\n\n  static processPatientData(rows, patientId) {\n    const firstRow = rows[0];\n    \n    // Extract basic patient info\n    // Since CSV parsing has issues with Gender column due to complex medication strings,\n    // we'll generate gender based on patient ID as a temporary solution\n    const generateGender = (patientId) => {\n      const numericId = parseInt(patientId.replace('Patient_', ''));\n      // Use patient ID to consistently assign gender (slight female bias as in original Python script)\n      return (numericId % 3 === 0) ? 'Male' : 'Female';\n    };\n    \n    const patientInfo = {\n      patientId,\n      patientNumber: patientId,\n      age: firstRow['Age'],\n      gender: generateGender(patientId),\n      dataAvailable: 'May 2025'\n    };\n\n    // Process medications with detailed information\n    const medicationsRaw = [...new Set(\n      rows.map(row => row['Medications'])\n        .filter(med => med && med.trim())\n    )];\n  \n    const detailedMedications = [];\n    const conditionsSet = new Set();\n  \n    medicationsRaw.forEach(medString => {\n      if (medString) {\n        const meds = medString.split('; ');\n        meds.forEach(med => {\n          const lastParenIndex = med.lastIndexOf('(');\n          if (lastParenIndex === -1) return;\n\n          const medName = med.substring(0, lastParenIndex).trim();\n          \n          if (medName && !detailedMedications.some(m => m.name === medName)) {\n            const detailsStr = med.substring(lastParenIndex + 1, med.length - 1);\n            const details = detailsStr.split(',').map(d => d.trim());\n\n            const schedule = details[0] || 'Not specified';\n            const category = details[1] || '';\n            const dosage = details.slice(2).join(', ') || '';\n\n            detailedMedications.push({\n              name: medName,\n              schedule: schedule,\n              category: category,\n              dosage: dosage\n            });\n          }\n        });\n      }\n    });\n\n    // Also check for direct chronic conditions column\n    const chronicConditionsRaw = [...new Set(\n      rows.map(row => row['Chronic_Conditions'])\n        .filter(condition => condition && condition.trim())\n    )];\n    \n    chronicConditionsRaw.forEach(conditionString => {\n      if (conditionString) {\n        const conditions = conditionString.split(',').map(c => c.trim());\n        conditions.forEach(condition => {\n          if (condition) {\n            conditionsSet.add(condition);\n          }\n        });\n      }\n    });\n  \n    const conditions = Array.from(conditionsSet);\n\n    // Process glucose data - use CSV data if available, otherwise generate realistic data\n    const glucoseData = rows\n      .flatMap(row => {\n        const baseDate = new Date(row['Date']);\n        const readings = [];\n        \n        // Check if we have glucose data in CSV\n        const hasGlucoseData = row['Glucose_1'] !== undefined;\n        \n        if (hasGlucoseData) {\n          // Process CSV glucose data (Glucose_1-4)\n          for (let i = 1; i <= 4; i++) {\n            const glucoseValue = parseFloat(row[`Glucose_${i}`]);\n            const measurementType = row[`Glucose_Measurement_Type_${i}`];\n            const range = row[`Glucose_Range_${i}`];\n            const timeStr = row[`Glucose_Time_${i}`];\n            \n            if (!isNaN(glucoseValue) && glucoseValue > 0) {\n              let readingDate = new Date(baseDate);\n              \n              // Parse time if available\n              if (timeStr && timeStr.includes(':')) {\n                const [hours, minutes] = timeStr.split(':').map(Number);\n                readingDate.setHours(hours, minutes, 0, 0);\n              } else {\n                // Fallback to simulated times\n                const hour = 7 + Math.floor(Math.random() * 13); // 7am to 8pm\n                const minute = Math.floor(Math.random() * 60);\n                readingDate.setHours(hour, minute, 0, 0);\n              }\n              \n              readings.push({\n                date: readingDate,\n                value: glucoseValue,\n                range: range || 'Normal',\n                measurementType: measurementType || 'Pre meal'\n              });\n            }\n          }\n        } else {\n          // Generate realistic data for patients without CSV glucose data\n          const patientNum = parseInt(patientId.replace('Patient_', '')) || parseInt(patientId);\n          const isDiabetic = patientNum % 3 === 2; // Every 3rd patient starting with 2 has diabetes\n          \n          let baseGlucose;\n          if (isDiabetic) {\n            // Diabetic patient: higher, more variable glucose (6-15 mmol/L)\n            baseGlucose = 7.0 + Math.random() * 8.0;\n          } else {\n            // Non-diabetic patient: normal glucose (4-7 mmol/L)\n            baseGlucose = 4.5 + Math.random() * 2.5;\n          }\n          \n          // Create 2-4 readings per day with simulated timestamps\n          const numReadings = Math.floor(Math.random() * 3) + 2; // 2-4 readings\n          \n          for (let i = 0; i < numReadings; i++) {\n            // Generate realistic glucose measurement times\n            let hour, measurementType;\n            if (i === 0) {\n              // Fasting/morning reading (6-8am)\n              hour = 6 + Math.floor(Math.random() * 2);\n              measurementType = 'Pre meal';\n            } else if (i === 1) {\n              // Pre-lunch reading (11am-12pm)\n              hour = 11 + Math.floor(Math.random() * 1);\n              measurementType = 'Pre meal';\n            } else if (i === 2) {\n              // Post-meal reading (1-3pm)\n              hour = 13 + Math.floor(Math.random() * 2);\n              measurementType = '2-hour post meal';\n            } else {\n              // Evening reading (6-8pm)\n              hour = 18 + Math.floor(Math.random() * 2);\n              measurementType = Math.random() > 0.5 ? 'Pre meal' : '2-hour post meal';\n            }\n            \n            const minute = Math.floor(Math.random() * 60);\n            const readingDate = new Date(baseDate);\n            readingDate.setHours(hour, minute, 0, 0);\n            \n            // Add realistic variation based on measurement type\n            let glucoseValue;\n            if (measurementType === 'Pre meal') {\n              // Pre-meal: slight variation around base value\n              const variation = (Math.random() - 0.5) * 2;\n              glucoseValue = Math.max(3.0, Math.min(15.0, baseGlucose + variation));\n            } else {\n              // Post-meal: typically higher\n              const variation = (Math.random() - 0.5) * 3 + 2;\n              glucoseValue = Math.max(4.0, Math.min(20.0, baseGlucose + variation));\n            }\n            \n            // Determine range based on value and type\n            let range;\n            if (measurementType === 'Pre meal') {\n              if (glucoseValue < 4.0) range = 'Low';\n              else if (glucoseValue <= 7.0) range = 'Normal';\n              else range = 'High';\n            } else {\n              if (glucoseValue < 4.0) range = 'Low';\n              else if (glucoseValue <= 10.0) range = 'Normal';\n              else range = 'High';\n            }\n            \n            readings.push({\n              date: readingDate,\n              value: Math.round(glucoseValue * 10) / 10, // Round to 1 decimal\n              range: range,\n              measurementType: measurementType\n            });\n          }\n        }\n        \n        return readings;\n      });\n\n    // Process blood pressure data - robust handling of both new and old CSV structures\n    \n    const bloodPressureData = rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const readings = [];\n      \n      // Check if we have new multi-column structure\n      const hasNewStructure = row['Systolic_1'] !== undefined;\n      \n      if (hasNewStructure) {\n        // Process new multi-column structure (Systolic_1-4, Diastolic_1-4)\n        for (let i = 1; i <= 4; i++) {\n          const systolic = parseInt(row[`Systolic_${i}`]);\n          const diastolic = parseInt(row[`Diastolic_${i}`]);\n          const bpTime = row[`BP_Time_${i}`];\n          const systolicType = row[`Systolic_Type_${i}`];\n          const diastolicType = row[`Diastolic_Type_${i}`];\n          \n          if (!isNaN(systolic) && !isNaN(diastolic) && systolic > 0 && diastolic > 0) {\n            let readingDate = new Date(baseDate);\n            \n            // Parse time if available, otherwise use simulated time\n            if (bpTime && bpTime.includes(':')) {\n              const [hours, minutes] = bpTime.split(':').map(Number);\n              readingDate.setHours(hours, minutes, 0, 0);\n            } else {\n              // Fallback to simulated times\n              const hour = 7 + Math.floor(Math.random() * 13); // 7am to 8pm\n              const minute = Math.floor(Math.random() * 60);\n              readingDate.setHours(hour, minute, 0, 0);\n            }\n            \n            readings.push({\n              date: readingDate,\n              systolic: systolic,\n              diastolic: diastolic,\n              systolicType: systolicType || 'Normal',\n              diastolicType: diastolicType || 'Normal'\n            });\n          }\n        }\n      } else if (row['Systolic'] && row['Diastolic']) {\n        // Process old single column structure\n        const systolic = parseInt(row['Systolic']);\n        const diastolic = parseInt(row['Diastolic']);\n        \n        if (!isNaN(systolic) && !isNaN(diastolic)) {\n          // Create 2-3 readings per day with simulated timestamps\n          const numReadings = Math.floor(Math.random() * 2) + 2; // 2-3 readings\n          \n          for (let i = 0; i < numReadings; i++) {\n            // Generate realistic times: morning (7-10), afternoon (12-15), evening (17-20)\n            let hour;\n            if (i === 0) hour = 7 + Math.floor(Math.random() * 3); // Morning\n            else if (i === 1) hour = 12 + Math.floor(Math.random() * 3); // Afternoon  \n            else hour = 17 + Math.floor(Math.random() * 3); // Evening\n            \n            const minute = Math.floor(Math.random() * 60);\n            const readingDate = new Date(baseDate);\n            readingDate.setHours(hour, minute, 0, 0);\n            \n            // Add some variation to readings\n            const variation = (Math.random() - 0.5) * 10;\n            \n            readings.push({\n              date: readingDate,\n              systolic: Math.max(80, Math.min(200, systolic + Math.floor(variation))),\n              diastolic: Math.max(50, Math.min(120, diastolic + Math.floor(variation/2))),\n              systolicType: row['Systolic_Type'] || 'Normal',\n              diastolicType: row['Diastolic_Type'] || 'Normal'\n            });\n          }\n        }\n      }\n      \n      return readings;\n    });\n    \n\n    // Process exercise data - robust handling of both new and old CSV structures\n    const exerciseByDate = {};\n    \n    // Check if we have new multi-column structure\n    const hasNewExerciseStructure = rows[0] && rows[0]['Exercise_Type_1'] !== undefined;\n    \n    rows.forEach(row => {\n      const date = new Date(row['Date']);\n      const dateKey = date.toDateString();\n      \n      if (!exerciseByDate[dateKey]) {\n        exerciseByDate[dateKey] = {\n          date: date,\n          walking: 0,\n          aerobic: 0,\n          strength: 0,\n          balance: 0,\n          other: 0,\n          totalMinutes: 0\n        };\n      }\n      \n      if (hasNewExerciseStructure) {\n        // Process new multi-column structure (Exercise_Type_1-3, Exercise_Minutes_1-3)\n        for (let i = 1; i <= 3; i++) {\n          const exerciseType = row[`Exercise_Type_${i}`];\n          const exerciseMinutesRaw = row[`Exercise_Minutes_${i}`];\n          const exerciseMinutes = parseFloat(exerciseMinutesRaw);\n          \n          if (exerciseType && exerciseType.trim() && !isNaN(exerciseMinutes) && exerciseMinutes > 0) {\n            const normalizedType = exerciseType.toLowerCase();\n            \n            // Map exercise types to chart categories\n            if (normalizedType.includes('walking')) {\n              exerciseByDate[dateKey].walking += exerciseMinutes;\n            } else if (normalizedType.includes('aerobic')) {\n              exerciseByDate[dateKey].aerobic += exerciseMinutes;\n            } else if (normalizedType.includes('strength')) {\n              exerciseByDate[dateKey].strength += exerciseMinutes;\n            } else if (normalizedType.includes('balance')) {\n              exerciseByDate[dateKey].balance += exerciseMinutes;\n            } else {\n              exerciseByDate[dateKey].other += exerciseMinutes;\n            }\n            \n            exerciseByDate[dateKey].totalMinutes += exerciseMinutes;\n          }\n        }\n      } else if (row['Exercise_Type'] && row['Exercise_Minutes']) {\n        // Process old single column structure\n        const exerciseType = row['Exercise_Type'];\n        const exerciseMinutesRaw = row['Exercise_Minutes'];\n        const exerciseMinutes = parseFloat(exerciseMinutesRaw);\n        \n        if (exerciseType && exerciseType.trim() && !isNaN(exerciseMinutes) && exerciseMinutes > 0) {\n          const normalizedType = exerciseType.toLowerCase();\n          \n          // Map exercise types to chart categories\n          if (normalizedType.includes('walking')) {\n            exerciseByDate[dateKey].walking += exerciseMinutes;\n          } else if (normalizedType.includes('aerobic')) {\n            exerciseByDate[dateKey].aerobic += exerciseMinutes;\n          } else if (normalizedType.includes('strength')) {\n            exerciseByDate[dateKey].strength += exerciseMinutes;\n          } else if (normalizedType.includes('balance')) {\n            exerciseByDate[dateKey].balance += exerciseMinutes;\n          } else {\n            exerciseByDate[dateKey].other += exerciseMinutes;\n          }\n          \n          exerciseByDate[dateKey].totalMinutes += exerciseMinutes;\n        }\n      }\n    });\n    \n    const exerciseData = Object.values(exerciseByDate).filter(day => day.totalMinutes > 0);\n\n    // Process mood data\n    const moodData = rows\n      .filter(row => row['Mood'])\n      .map(row => ({\n        date: new Date(row['Date']),\n        mood: row['Mood'],\n        category: row['Mood'] || 'neutral'\n      }));\n\n    // Process pain data\n    const painData = rows\n      .filter(row => row['Pain_Location'] && row['Pain_Level'] !== undefined)\n      .map(row => ({\n        date: new Date(row['Date']),\n        location: row['Pain_Location'].toLowerCase(),\n        level: parseInt(row['Pain_Level']) || 0\n      }));\n    \n    // Process sleep data\n    const sleepData = rows\n      .filter(row => row['Sleep_Hours'] && row['Sleep_Quality'])\n      .map(row => ({\n        date: new Date(row['Date']),\n        hours: parseFloat(row['Sleep_Hours']),\n        quality: row['Sleep_Quality'],\n        qualityCode: parseInt(row['Sleep_Quality_Code'])\n      }));\n\n    // Process meal data\n    const mealData = rows.map(row => ({\n      Date: row['Date'],\n      Breakfast_Protein: row['Breakfast_Protein'],\n      Breakfast_Vegetables: row['Breakfast_Vegetables'],\n      Breakfast_Fruit: row['Breakfast_Fruit'],\n      Breakfast_Alcohol: row['Breakfast_Alcohol'],\n      Breakfast_Carbohydrates: row['Breakfast_Carbohydrates'],\n      Breakfast_Added_Sugar: row['Breakfast_Added_Sugar'],\n      Lunch_Protein: row['Lunch_Protein'],\n      Lunch_Vegetables: row['Lunch_Vegetables'],\n      Lunch_Fruit: row['Lunch_Fruit'],\n      Lunch_Alcohol: row['Lunch_Alcohol'],\n      Lunch_Carbohydrates: row['Lunch_Carbohydrates'],\n      Lunch_Added_Sugar: row['Lunch_Added_Sugar'],\n      Dinner_Protein: row['Dinner_Protein'],\n      Dinner_Vegetables: row['Dinner_Vegetables'],\n      Dinner_Fruit: row['Dinner_Fruit'],\n      Dinner_Alcohol: row['Dinner_Alcohol'],\n      Dinner_Carbohydrates: row['Dinner_Carbohydrates'],\n      Dinner_Added_Sugar: row['Dinner_Added_Sugar'],\n      Breakfast_Time: row['Breakfast_Time'],\n      Lunch_Time: row['Lunch_Time'],\n      Dinner_Time: row['Dinner_Time']\n    }));\n\n    return {\n      patientInfo: { \n        ...patientInfo, \n        detailedMedications, \n        conditions\n      },\n      glucoseData,\n      bloodPressureData,\n      exerciseData,\n      moodData,\n      painData,\n      mealData,\n      sleepData,\n      rawData: rows\n    };\n  }\n\n  static clearCache() {\n    patientDataCache.clear();\n  }\n\n  static getCacheSize() {\n    return patientDataCache.size;\n  }\n}\n\nexport default DataService;\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,WAAW;;AAE5B;AACA,MAAMC,UAAU,GAAG;EACjBC,MAAM,EAAE,IAAI;EACZC,cAAc,EAAE,IAAI;EACpBC,eAAe,EAAGF,MAAM,IAAKA,MAAM,CAACG,IAAI,CAAC,CAAC;EAC1CC,SAAS,EAAGC,KAAK,IAAKA,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEF,IAAI,CAAC;AACpC,CAAC;AAED,MAAMG,WAAW,CAAC;EAChB,aAAaC,cAAcA,CAACC,SAAS,EAAE;IACrC,IAAI;MACF;MACA,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,uBAAuBF,SAAS,MAAM,CAAC;MACpE,IAAI,CAACC,QAAQ,CAACE,EAAE,EAAE;QAChB,MAAM,IAAIC,KAAK,CAAC,6BAA6BJ,SAAS,EAAE,CAAC;MAC3D;MAEA,MAAMK,OAAO,GAAG,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;MACrC,MAAMC,MAAM,GAAGjB,IAAI,CAACkB,KAAK,CAACH,OAAO,EAAEd,UAAU,CAAC;MAE9C,IAAIgB,MAAM,CAACE,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;QAC5BC,OAAO,CAACC,IAAI,CAAC,uBAAuB,EAAEL,MAAM,CAACE,MAAM,CAAC;MACtD;MAEA,OAAO,IAAI,CAACI,kBAAkB,CAACN,MAAM,CAACO,IAAI,EAAEd,SAAS,CAAC;IACxD,CAAC,CAAC,OAAOe,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACnD,MAAMA,KAAK;IACb;EACF;EAEA,OAAOF,kBAAkBA,CAACG,IAAI,EAAEhB,SAAS,EAAE;IACzC,MAAMiB,QAAQ,GAAGD,IAAI,CAAC,CAAC,CAAC;;IAExB;IACA;IACA;IACA,MAAME,cAAc,GAAIlB,SAAS,IAAK;MACpC,MAAMmB,SAAS,GAAGC,QAAQ,CAACpB,SAAS,CAACqB,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;MAC7D;MACA,OAAQF,SAAS,GAAG,CAAC,KAAK,CAAC,GAAI,MAAM,GAAG,QAAQ;IAClD,CAAC;IAED,MAAMG,WAAW,GAAG;MAClBtB,SAAS;MACTuB,aAAa,EAAEvB,SAAS;MACxBwB,GAAG,EAAEP,QAAQ,CAAC,KAAK,CAAC;MACpBQ,MAAM,EAAEP,cAAc,CAAClB,SAAS,CAAC;MACjC0B,aAAa,EAAE;IACjB,CAAC;;IAED;IACA,MAAMC,cAAc,GAAG,CAAC,GAAG,IAAIC,GAAG,CAChCZ,IAAI,CAACa,GAAG,CAACC,GAAG,IAAIA,GAAG,CAAC,aAAa,CAAC,CAAC,CAChCC,MAAM,CAACC,GAAG,IAAIA,GAAG,IAAIA,GAAG,CAACrC,IAAI,CAAC,CAAC,CACpC,CAAC,CAAC;IAEF,MAAMsC,mBAAmB,GAAG,EAAE;IAC9B,MAAMC,aAAa,GAAG,IAAIN,GAAG,CAAC,CAAC;IAE/BD,cAAc,CAACQ,OAAO,CAACC,SAAS,IAAI;MAClC,IAAIA,SAAS,EAAE;QACb,MAAMC,IAAI,GAAGD,SAAS,CAACE,KAAK,CAAC,IAAI,CAAC;QAClCD,IAAI,CAACF,OAAO,CAACH,GAAG,IAAI;UAClB,MAAMO,cAAc,GAAGP,GAAG,CAACQ,WAAW,CAAC,GAAG,CAAC;UAC3C,IAAID,cAAc,KAAK,CAAC,CAAC,EAAE;UAE3B,MAAME,OAAO,GAAGT,GAAG,CAACU,SAAS,CAAC,CAAC,EAAEH,cAAc,CAAC,CAAC5C,IAAI,CAAC,CAAC;UAEvD,IAAI8C,OAAO,IAAI,CAACR,mBAAmB,CAACU,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,KAAKJ,OAAO,CAAC,EAAE;YACjE,MAAMK,UAAU,GAAGd,GAAG,CAACU,SAAS,CAACH,cAAc,GAAG,CAAC,EAAEP,GAAG,CAACtB,MAAM,GAAG,CAAC,CAAC;YACpE,MAAMqC,OAAO,GAAGD,UAAU,CAACR,KAAK,CAAC,GAAG,CAAC,CAACT,GAAG,CAACmB,CAAC,IAAIA,CAAC,CAACrD,IAAI,CAAC,CAAC,CAAC;YAExD,MAAMsD,QAAQ,GAAGF,OAAO,CAAC,CAAC,CAAC,IAAI,eAAe;YAC9C,MAAMG,QAAQ,GAAGH,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE;YACjC,MAAMI,MAAM,GAAGJ,OAAO,CAACK,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YAEhDpB,mBAAmB,CAACqB,IAAI,CAAC;cACvBT,IAAI,EAAEJ,OAAO;cACbQ,QAAQ,EAAEA,QAAQ;cAClBC,QAAQ,EAAEA,QAAQ;cAClBC,MAAM,EAAEA;YACV,CAAC,CAAC;UACJ;QACF,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;;IAEF;IACA,MAAMI,oBAAoB,GAAG,CAAC,GAAG,IAAI3B,GAAG,CACtCZ,IAAI,CAACa,GAAG,CAACC,GAAG,IAAIA,GAAG,CAAC,oBAAoB,CAAC,CAAC,CACvCC,MAAM,CAACyB,SAAS,IAAIA,SAAS,IAAIA,SAAS,CAAC7D,IAAI,CAAC,CAAC,CACtD,CAAC,CAAC;IAEF4D,oBAAoB,CAACpB,OAAO,CAACsB,eAAe,IAAI;MAC9C,IAAIA,eAAe,EAAE;QACnB,MAAMC,UAAU,GAAGD,eAAe,CAACnB,KAAK,CAAC,GAAG,CAAC,CAACT,GAAG,CAAC8B,CAAC,IAAIA,CAAC,CAAChE,IAAI,CAAC,CAAC,CAAC;QAChE+D,UAAU,CAACvB,OAAO,CAACqB,SAAS,IAAI;UAC9B,IAAIA,SAAS,EAAE;YACbtB,aAAa,CAAC0B,GAAG,CAACJ,SAAS,CAAC;UAC9B;QACF,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;IAEF,MAAME,UAAU,GAAGG,KAAK,CAACC,IAAI,CAAC5B,aAAa,CAAC;;IAE5C;IACA,MAAM6B,WAAW,GAAG/C,IAAI,CACrBgD,OAAO,CAAClC,GAAG,IAAI;MACd,MAAMmC,QAAQ,GAAG,IAAIC,IAAI,CAACpC,GAAG,CAAC,MAAM,CAAC,CAAC;MACtC,MAAMqC,QAAQ,GAAG,EAAE;;MAEnB;MACA,MAAMC,cAAc,GAAGtC,GAAG,CAAC,WAAW,CAAC,KAAKuC,SAAS;MAErD,IAAID,cAAc,EAAE;QAClB;QACA,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UAC3B,MAAMC,YAAY,GAAGC,UAAU,CAAC1C,GAAG,CAAC,WAAWwC,CAAC,EAAE,CAAC,CAAC;UACpD,MAAMG,eAAe,GAAG3C,GAAG,CAAC,4BAA4BwC,CAAC,EAAE,CAAC;UAC5D,MAAMI,KAAK,GAAG5C,GAAG,CAAC,iBAAiBwC,CAAC,EAAE,CAAC;UACvC,MAAMK,OAAO,GAAG7C,GAAG,CAAC,gBAAgBwC,CAAC,EAAE,CAAC;UAExC,IAAI,CAACM,KAAK,CAACL,YAAY,CAAC,IAAIA,YAAY,GAAG,CAAC,EAAE;YAC5C,IAAIM,WAAW,GAAG,IAAIX,IAAI,CAACD,QAAQ,CAAC;;YAEpC;YACA,IAAIU,OAAO,IAAIA,OAAO,CAACG,QAAQ,CAAC,GAAG,CAAC,EAAE;cACpC,MAAM,CAACC,KAAK,EAAEC,OAAO,CAAC,GAAGL,OAAO,CAACrC,KAAK,CAAC,GAAG,CAAC,CAACT,GAAG,CAACoD,MAAM,CAAC;cACvDJ,WAAW,CAACK,QAAQ,CAACH,KAAK,EAAEC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;YAC5C,CAAC,MAAM;cACL;cACA,MAAMG,IAAI,GAAG,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;cACjD,MAAMC,MAAM,GAAGH,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC;cAC7CT,WAAW,CAACK,QAAQ,CAACC,IAAI,EAAEI,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;YAC1C;YAEApB,QAAQ,CAACb,IAAI,CAAC;cACZkC,IAAI,EAAEX,WAAW;cACjBhF,KAAK,EAAE0E,YAAY;cACnBG,KAAK,EAAEA,KAAK,IAAI,QAAQ;cACxBD,eAAe,EAAEA,eAAe,IAAI;YACtC,CAAC,CAAC;UACJ;QACF;MACF,CAAC,MAAM;QACL;QACA,MAAMgB,UAAU,GAAGrE,QAAQ,CAACpB,SAAS,CAACqB,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC,IAAID,QAAQ,CAACpB,SAAS,CAAC;QACrF,MAAM0F,UAAU,GAAGD,UAAU,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;;QAEzC,IAAIE,WAAW;QACf,IAAID,UAAU,EAAE;UACd;UACAC,WAAW,GAAG,GAAG,GAAGP,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG;QACzC,CAAC,MAAM;UACL;UACAK,WAAW,GAAG,GAAG,GAAGP,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG;QACzC;;QAEA;QACA,MAAMM,WAAW,GAAGR,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;;QAEvD,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,WAAW,EAAEtB,CAAC,EAAE,EAAE;UACpC;UACA,IAAIa,IAAI,EAAEV,eAAe;UACzB,IAAIH,CAAC,KAAK,CAAC,EAAE;YACX;YACAa,IAAI,GAAG,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;YACxCb,eAAe,GAAG,UAAU;UAC9B,CAAC,MAAM,IAAIH,CAAC,KAAK,CAAC,EAAE;YAClB;YACAa,IAAI,GAAG,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;YACzCb,eAAe,GAAG,UAAU;UAC9B,CAAC,MAAM,IAAIH,CAAC,KAAK,CAAC,EAAE;YAClB;YACAa,IAAI,GAAG,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;YACzCb,eAAe,GAAG,kBAAkB;UACtC,CAAC,MAAM;YACL;YACAU,IAAI,GAAG,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;YACzCb,eAAe,GAAGW,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,UAAU,GAAG,kBAAkB;UACzE;UAEA,MAAMC,MAAM,GAAGH,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC;UAC7C,MAAMT,WAAW,GAAG,IAAIX,IAAI,CAACD,QAAQ,CAAC;UACtCY,WAAW,CAACK,QAAQ,CAACC,IAAI,EAAEI,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;;UAExC;UACA,IAAIhB,YAAY;UAChB,IAAIE,eAAe,KAAK,UAAU,EAAE;YAClC;YACA,MAAMoB,SAAS,GAAG,CAACT,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC;YAC3Cf,YAAY,GAAGa,IAAI,CAACU,GAAG,CAAC,GAAG,EAAEV,IAAI,CAACW,GAAG,CAAC,IAAI,EAAEJ,WAAW,GAAGE,SAAS,CAAC,CAAC;UACvE,CAAC,MAAM;YACL;YACA,MAAMA,SAAS,GAAG,CAACT,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;YAC/Cf,YAAY,GAAGa,IAAI,CAACU,GAAG,CAAC,GAAG,EAAEV,IAAI,CAACW,GAAG,CAAC,IAAI,EAAEJ,WAAW,GAAGE,SAAS,CAAC,CAAC;UACvE;;UAEA;UACA,IAAInB,KAAK;UACT,IAAID,eAAe,KAAK,UAAU,EAAE;YAClC,IAAIF,YAAY,GAAG,GAAG,EAAEG,KAAK,GAAG,KAAK,CAAC,KACjC,IAAIH,YAAY,IAAI,GAAG,EAAEG,KAAK,GAAG,QAAQ,CAAC,KAC1CA,KAAK,GAAG,MAAM;UACrB,CAAC,MAAM;YACL,IAAIH,YAAY,GAAG,GAAG,EAAEG,KAAK,GAAG,KAAK,CAAC,KACjC,IAAIH,YAAY,IAAI,IAAI,EAAEG,KAAK,GAAG,QAAQ,CAAC,KAC3CA,KAAK,GAAG,MAAM;UACrB;UAEAP,QAAQ,CAACb,IAAI,CAAC;YACZkC,IAAI,EAAEX,WAAW;YACjBhF,KAAK,EAAEuF,IAAI,CAACY,KAAK,CAACzB,YAAY,GAAG,EAAE,CAAC,GAAG,EAAE;YAAE;YAC3CG,KAAK,EAAEA,KAAK;YACZD,eAAe,EAAEA;UACnB,CAAC,CAAC;QACJ;MACF;MAEA,OAAON,QAAQ;IACjB,CAAC,CAAC;;IAEJ;;IAEA,MAAM8B,iBAAiB,GAAGjF,IAAI,CAACgD,OAAO,CAAClC,GAAG,IAAI;MAC5C,MAAMmC,QAAQ,GAAG,IAAIC,IAAI,CAACpC,GAAG,CAAC,MAAM,CAAC,CAAC;MACtC,MAAMqC,QAAQ,GAAG,EAAE;;MAEnB;MACA,MAAM+B,eAAe,GAAGpE,GAAG,CAAC,YAAY,CAAC,KAAKuC,SAAS;MAEvD,IAAI6B,eAAe,EAAE;QACnB;QACA,KAAK,IAAI5B,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UAC3B,MAAM6B,QAAQ,GAAG/E,QAAQ,CAACU,GAAG,CAAC,YAAYwC,CAAC,EAAE,CAAC,CAAC;UAC/C,MAAM8B,SAAS,GAAGhF,QAAQ,CAACU,GAAG,CAAC,aAAawC,CAAC,EAAE,CAAC,CAAC;UACjD,MAAM+B,MAAM,GAAGvE,GAAG,CAAC,WAAWwC,CAAC,EAAE,CAAC;UAClC,MAAMgC,YAAY,GAAGxE,GAAG,CAAC,iBAAiBwC,CAAC,EAAE,CAAC;UAC9C,MAAMiC,aAAa,GAAGzE,GAAG,CAAC,kBAAkBwC,CAAC,EAAE,CAAC;UAEhD,IAAI,CAACM,KAAK,CAACuB,QAAQ,CAAC,IAAI,CAACvB,KAAK,CAACwB,SAAS,CAAC,IAAID,QAAQ,GAAG,CAAC,IAAIC,SAAS,GAAG,CAAC,EAAE;YAC1E,IAAIvB,WAAW,GAAG,IAAIX,IAAI,CAACD,QAAQ,CAAC;;YAEpC;YACA,IAAIoC,MAAM,IAAIA,MAAM,CAACvB,QAAQ,CAAC,GAAG,CAAC,EAAE;cAClC,MAAM,CAACC,KAAK,EAAEC,OAAO,CAAC,GAAGqB,MAAM,CAAC/D,KAAK,CAAC,GAAG,CAAC,CAACT,GAAG,CAACoD,MAAM,CAAC;cACtDJ,WAAW,CAACK,QAAQ,CAACH,KAAK,EAAEC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;YAC5C,CAAC,MAAM;cACL;cACA,MAAMG,IAAI,GAAG,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;cACjD,MAAMC,MAAM,GAAGH,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC;cAC7CT,WAAW,CAACK,QAAQ,CAACC,IAAI,EAAEI,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;YAC1C;YAEApB,QAAQ,CAACb,IAAI,CAAC;cACZkC,IAAI,EAAEX,WAAW;cACjBsB,QAAQ,EAAEA,QAAQ;cAClBC,SAAS,EAAEA,SAAS;cACpBE,YAAY,EAAEA,YAAY,IAAI,QAAQ;cACtCC,aAAa,EAAEA,aAAa,IAAI;YAClC,CAAC,CAAC;UACJ;QACF;MACF,CAAC,MAAM,IAAIzE,GAAG,CAAC,UAAU,CAAC,IAAIA,GAAG,CAAC,WAAW,CAAC,EAAE;QAC9C;QACA,MAAMqE,QAAQ,GAAG/E,QAAQ,CAACU,GAAG,CAAC,UAAU,CAAC,CAAC;QAC1C,MAAMsE,SAAS,GAAGhF,QAAQ,CAACU,GAAG,CAAC,WAAW,CAAC,CAAC;QAE5C,IAAI,CAAC8C,KAAK,CAACuB,QAAQ,CAAC,IAAI,CAACvB,KAAK,CAACwB,SAAS,CAAC,EAAE;UACzC;UACA,MAAMR,WAAW,GAAGR,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;;UAEvD,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,WAAW,EAAEtB,CAAC,EAAE,EAAE;YACpC;YACA,IAAIa,IAAI;YACR,IAAIb,CAAC,KAAK,CAAC,EAAEa,IAAI,GAAG,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAAA,KAClD,IAAIhB,CAAC,KAAK,CAAC,EAAEa,IAAI,GAAG,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAAA,KACxDH,IAAI,GAAG,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;YAEhD,MAAMC,MAAM,GAAGH,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC;YAC7C,MAAMT,WAAW,GAAG,IAAIX,IAAI,CAACD,QAAQ,CAAC;YACtCY,WAAW,CAACK,QAAQ,CAACC,IAAI,EAAEI,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;;YAExC;YACA,MAAMM,SAAS,GAAG,CAACT,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG,IAAI,EAAE;YAE5CnB,QAAQ,CAACb,IAAI,CAAC;cACZkC,IAAI,EAAEX,WAAW;cACjBsB,QAAQ,EAAEf,IAAI,CAACU,GAAG,CAAC,EAAE,EAAEV,IAAI,CAACW,GAAG,CAAC,GAAG,EAAEI,QAAQ,GAAGf,IAAI,CAACC,KAAK,CAACQ,SAAS,CAAC,CAAC,CAAC;cACvEO,SAAS,EAAEhB,IAAI,CAACU,GAAG,CAAC,EAAE,EAAEV,IAAI,CAACW,GAAG,CAAC,GAAG,EAAEK,SAAS,GAAGhB,IAAI,CAACC,KAAK,CAACQ,SAAS,GAAC,CAAC,CAAC,CAAC,CAAC;cAC3ES,YAAY,EAAExE,GAAG,CAAC,eAAe,CAAC,IAAI,QAAQ;cAC9CyE,aAAa,EAAEzE,GAAG,CAAC,gBAAgB,CAAC,IAAI;YAC1C,CAAC,CAAC;UACJ;QACF;MACF;MAEA,OAAOqC,QAAQ;IACjB,CAAC,CAAC;;IAGF;IACA,MAAMqC,cAAc,GAAG,CAAC,CAAC;;IAEzB;IACA,MAAMC,uBAAuB,GAAGzF,IAAI,CAAC,CAAC,CAAC,IAAIA,IAAI,CAAC,CAAC,CAAC,CAAC,iBAAiB,CAAC,KAAKqD,SAAS;IAEnFrD,IAAI,CAACmB,OAAO,CAACL,GAAG,IAAI;MAClB,MAAM0D,IAAI,GAAG,IAAItB,IAAI,CAACpC,GAAG,CAAC,MAAM,CAAC,CAAC;MAClC,MAAM4E,OAAO,GAAGlB,IAAI,CAACmB,YAAY,CAAC,CAAC;MAEnC,IAAI,CAACH,cAAc,CAACE,OAAO,CAAC,EAAE;QAC5BF,cAAc,CAACE,OAAO,CAAC,GAAG;UACxBlB,IAAI,EAAEA,IAAI;UACVoB,OAAO,EAAE,CAAC;UACVC,OAAO,EAAE,CAAC;UACVC,QAAQ,EAAE,CAAC;UACXC,OAAO,EAAE,CAAC;UACVC,KAAK,EAAE,CAAC;UACRC,YAAY,EAAE;QAChB,CAAC;MACH;MAEA,IAAIR,uBAAuB,EAAE;QAC3B;QACA,KAAK,IAAInC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UAC3B,MAAM4C,YAAY,GAAGpF,GAAG,CAAC,iBAAiBwC,CAAC,EAAE,CAAC;UAC9C,MAAM6C,kBAAkB,GAAGrF,GAAG,CAAC,oBAAoBwC,CAAC,EAAE,CAAC;UACvD,MAAM8C,eAAe,GAAG5C,UAAU,CAAC2C,kBAAkB,CAAC;UAEtD,IAAID,YAAY,IAAIA,YAAY,CAACvH,IAAI,CAAC,CAAC,IAAI,CAACiF,KAAK,CAACwC,eAAe,CAAC,IAAIA,eAAe,GAAG,CAAC,EAAE;YACzF,MAAMC,cAAc,GAAGH,YAAY,CAACI,WAAW,CAAC,CAAC;;YAEjD;YACA,IAAID,cAAc,CAACvC,QAAQ,CAAC,SAAS,CAAC,EAAE;cACtC0B,cAAc,CAACE,OAAO,CAAC,CAACE,OAAO,IAAIQ,eAAe;YACpD,CAAC,MAAM,IAAIC,cAAc,CAACvC,QAAQ,CAAC,SAAS,CAAC,EAAE;cAC7C0B,cAAc,CAACE,OAAO,CAAC,CAACG,OAAO,IAAIO,eAAe;YACpD,CAAC,MAAM,IAAIC,cAAc,CAACvC,QAAQ,CAAC,UAAU,CAAC,EAAE;cAC9C0B,cAAc,CAACE,OAAO,CAAC,CAACI,QAAQ,IAAIM,eAAe;YACrD,CAAC,MAAM,IAAIC,cAAc,CAACvC,QAAQ,CAAC,SAAS,CAAC,EAAE;cAC7C0B,cAAc,CAACE,OAAO,CAAC,CAACK,OAAO,IAAIK,eAAe;YACpD,CAAC,MAAM;cACLZ,cAAc,CAACE,OAAO,CAAC,CAACM,KAAK,IAAII,eAAe;YAClD;YAEAZ,cAAc,CAACE,OAAO,CAAC,CAACO,YAAY,IAAIG,eAAe;UACzD;QACF;MACF,CAAC,MAAM,IAAItF,GAAG,CAAC,eAAe,CAAC,IAAIA,GAAG,CAAC,kBAAkB,CAAC,EAAE;QAC1D;QACA,MAAMoF,YAAY,GAAGpF,GAAG,CAAC,eAAe,CAAC;QACzC,MAAMqF,kBAAkB,GAAGrF,GAAG,CAAC,kBAAkB,CAAC;QAClD,MAAMsF,eAAe,GAAG5C,UAAU,CAAC2C,kBAAkB,CAAC;QAEtD,IAAID,YAAY,IAAIA,YAAY,CAACvH,IAAI,CAAC,CAAC,IAAI,CAACiF,KAAK,CAACwC,eAAe,CAAC,IAAIA,eAAe,GAAG,CAAC,EAAE;UACzF,MAAMC,cAAc,GAAGH,YAAY,CAACI,WAAW,CAAC,CAAC;;UAEjD;UACA,IAAID,cAAc,CAACvC,QAAQ,CAAC,SAAS,CAAC,EAAE;YACtC0B,cAAc,CAACE,OAAO,CAAC,CAACE,OAAO,IAAIQ,eAAe;UACpD,CAAC,MAAM,IAAIC,cAAc,CAACvC,QAAQ,CAAC,SAAS,CAAC,EAAE;YAC7C0B,cAAc,CAACE,OAAO,CAAC,CAACG,OAAO,IAAIO,eAAe;UACpD,CAAC,MAAM,IAAIC,cAAc,CAACvC,QAAQ,CAAC,UAAU,CAAC,EAAE;YAC9C0B,cAAc,CAACE,OAAO,CAAC,CAACI,QAAQ,IAAIM,eAAe;UACrD,CAAC,MAAM,IAAIC,cAAc,CAACvC,QAAQ,CAAC,SAAS,CAAC,EAAE;YAC7C0B,cAAc,CAACE,OAAO,CAAC,CAACK,OAAO,IAAIK,eAAe;UACpD,CAAC,MAAM;YACLZ,cAAc,CAACE,OAAO,CAAC,CAACM,KAAK,IAAII,eAAe;UAClD;UAEAZ,cAAc,CAACE,OAAO,CAAC,CAACO,YAAY,IAAIG,eAAe;QACzD;MACF;IACF,CAAC,CAAC;IAEF,MAAMG,YAAY,GAAGC,MAAM,CAACC,MAAM,CAACjB,cAAc,CAAC,CAACzE,MAAM,CAAC2F,GAAG,IAAIA,GAAG,CAACT,YAAY,GAAG,CAAC,CAAC;;IAEtF;IACA,MAAMU,QAAQ,GAAG3G,IAAI,CAClBe,MAAM,CAACD,GAAG,IAAIA,GAAG,CAAC,MAAM,CAAC,CAAC,CAC1BD,GAAG,CAACC,GAAG,KAAK;MACX0D,IAAI,EAAE,IAAItB,IAAI,CAACpC,GAAG,CAAC,MAAM,CAAC,CAAC;MAC3B8F,IAAI,EAAE9F,GAAG,CAAC,MAAM,CAAC;MACjBoB,QAAQ,EAAEpB,GAAG,CAAC,MAAM,CAAC,IAAI;IAC3B,CAAC,CAAC,CAAC;;IAEL;IACA,MAAM+F,QAAQ,GAAG7G,IAAI,CAClBe,MAAM,CAACD,GAAG,IAAIA,GAAG,CAAC,eAAe,CAAC,IAAIA,GAAG,CAAC,YAAY,CAAC,KAAKuC,SAAS,CAAC,CACtExC,GAAG,CAACC,GAAG,KAAK;MACX0D,IAAI,EAAE,IAAItB,IAAI,CAACpC,GAAG,CAAC,MAAM,CAAC,CAAC;MAC3BgG,QAAQ,EAAEhG,GAAG,CAAC,eAAe,CAAC,CAACwF,WAAW,CAAC,CAAC;MAC5CS,KAAK,EAAE3G,QAAQ,CAACU,GAAG,CAAC,YAAY,CAAC,CAAC,IAAI;IACxC,CAAC,CAAC,CAAC;;IAEL;IACA,MAAMkG,SAAS,GAAGhH,IAAI,CACnBe,MAAM,CAACD,GAAG,IAAIA,GAAG,CAAC,aAAa,CAAC,IAAIA,GAAG,CAAC,eAAe,CAAC,CAAC,CACzDD,GAAG,CAACC,GAAG,KAAK;MACX0D,IAAI,EAAE,IAAItB,IAAI,CAACpC,GAAG,CAAC,MAAM,CAAC,CAAC;MAC3BiD,KAAK,EAAEP,UAAU,CAAC1C,GAAG,CAAC,aAAa,CAAC,CAAC;MACrCmG,OAAO,EAAEnG,GAAG,CAAC,eAAe,CAAC;MAC7BoG,WAAW,EAAE9G,QAAQ,CAACU,GAAG,CAAC,oBAAoB,CAAC;IACjD,CAAC,CAAC,CAAC;;IAEL;IACA,MAAMqG,QAAQ,GAAGnH,IAAI,CAACa,GAAG,CAACC,GAAG,KAAK;MAChCoC,IAAI,EAAEpC,GAAG,CAAC,MAAM,CAAC;MACjBsG,iBAAiB,EAAEtG,GAAG,CAAC,mBAAmB,CAAC;MAC3CuG,oBAAoB,EAAEvG,GAAG,CAAC,sBAAsB,CAAC;MACjDwG,eAAe,EAAExG,GAAG,CAAC,iBAAiB,CAAC;MACvCyG,iBAAiB,EAAEzG,GAAG,CAAC,mBAAmB,CAAC;MAC3C0G,uBAAuB,EAAE1G,GAAG,CAAC,yBAAyB,CAAC;MACvD2G,qBAAqB,EAAE3G,GAAG,CAAC,uBAAuB,CAAC;MACnD4G,aAAa,EAAE5G,GAAG,CAAC,eAAe,CAAC;MACnC6G,gBAAgB,EAAE7G,GAAG,CAAC,kBAAkB,CAAC;MACzC8G,WAAW,EAAE9G,GAAG,CAAC,aAAa,CAAC;MAC/B+G,aAAa,EAAE/G,GAAG,CAAC,eAAe,CAAC;MACnCgH,mBAAmB,EAAEhH,GAAG,CAAC,qBAAqB,CAAC;MAC/CiH,iBAAiB,EAAEjH,GAAG,CAAC,mBAAmB,CAAC;MAC3CkH,cAAc,EAAElH,GAAG,CAAC,gBAAgB,CAAC;MACrCmH,iBAAiB,EAAEnH,GAAG,CAAC,mBAAmB,CAAC;MAC3CoH,YAAY,EAAEpH,GAAG,CAAC,cAAc,CAAC;MACjCqH,cAAc,EAAErH,GAAG,CAAC,gBAAgB,CAAC;MACrCsH,oBAAoB,EAAEtH,GAAG,CAAC,sBAAsB,CAAC;MACjDuH,kBAAkB,EAAEvH,GAAG,CAAC,oBAAoB,CAAC;MAC7CwH,cAAc,EAAExH,GAAG,CAAC,gBAAgB,CAAC;MACrCyH,UAAU,EAAEzH,GAAG,CAAC,YAAY,CAAC;MAC7B0H,WAAW,EAAE1H,GAAG,CAAC,aAAa;IAChC,CAAC,CAAC,CAAC;IAEH,OAAO;MACLR,WAAW,EAAE;QACX,GAAGA,WAAW;QACdW,mBAAmB;QACnByB;MACF,CAAC;MACDK,WAAW;MACXkC,iBAAiB;MACjBsB,YAAY;MACZI,QAAQ;MACRE,QAAQ;MACRM,QAAQ;MACRH,SAAS;MACTyB,OAAO,EAAEzI;IACX,CAAC;EACH;EAEA,OAAO0I,UAAUA,CAAA,EAAG;IAClBC,gBAAgB,CAACC,KAAK,CAAC,CAAC;EAC1B;EAEA,OAAOC,YAAYA,CAAA,EAAG;IACpB,OAAOF,gBAAgB,CAACG,IAAI;EAC9B;AACF;AAEA,eAAehK,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}