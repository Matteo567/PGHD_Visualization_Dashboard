{"ast":null,"code":"/*\r\n dataService.js - Patient Data Service\r\n \r\n This service handles all data operations for the health dashboard:\r\n - Fetches patient CSV data from the server\r\n - Parses and processes CSV data using PapaParse\r\n - Transforms raw data into structured health metrics\r\n - Provides data validation and error handling\r\n - Manages patient information, medications, and health tracking data\r\n - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\r\n \r\n Architecture:\r\n - Uses PapaParse library for CSV parsing\r\n - Implements service class pattern for data operations\r\n - Provides comprehensive error handling and validation\r\n - Supports multiple data formats and structures\r\n \r\n Data Processing:\r\n - CSV parsing with header validation\r\n - Data transformation and normalization\r\n - Type conversion and validation\r\n - Error recovery and fallback mechanisms\r\n \r\n Health Metrics Supported:\r\n - Blood glucose monitoring with meal context\r\n - Blood pressure tracking with risk categorization\r\n - Exercise activity tracking and categorization\r\n - Mood assessment and tracking\r\n - Pain reporting with anatomical mapping\r\n - Sleep quality and duration analysis\r\n - Nutritional intake and meal composition\r\n \r\n Error Handling:\r\n - Network error recovery\r\n - CSV parsing error handling\r\n - Data validation and sanitization\r\n - Graceful degradation for missing data\r\n \r\n Core service for data management and processing throughout the application.\r\n */\n\nimport Papa from 'papaparse';\n\n// Configuration for CSV parsing\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: header => header.trim(),\n  transform: value => value === null || value === void 0 ? void 0 : value.trim()\n};\n\n/*\r\n Fetches and parses CSV data for a specific patient\r\n \r\n - @param {string} patientId - The patient identifier\r\n - @returns {Promise<Array>} Parsed CSV data as array of objects\r\n - @throws {Error} If CSV fetch or parsing fails\r\n */\nconst fetchPatientCsvData = async patientId => {\n  try {\n    // Add cache busting to ensure fresh data\n    const response = await fetch(`/synthetic_patients/${patientId}.csv?v=${Date.now()}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\n    }\n    const csvText = await response.text();\n    if (!csvText || csvText.trim().length === 0) {\n      throw new Error(`Empty CSV file for patient ${patientId}`);\n    }\n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    if (parsed.errors.length > 0) {\n      // Log parsing errors for debugging but don't throw\n      console.error(`CSV parsing errors for ${patientId}:`, parsed.errors);\n    }\n    return parsed.data;\n  } catch (error) {\n    console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    throw error;\n  }\n};\n\n/*\r\n Service class for handling patient data operations\r\n Provides methods for fetching and processing patient health data from CSV files\r\n */\nclass DataService {\n  /*\r\n   Retrieves and processes all data for a specific patient\r\n   \r\n   - @param {string} patientId - The patient identifier\r\n   - @returns {Promise<Object>} Processed patient data including all health metrics\r\n   - @throws {Error} If patient data cannot be retrieved or processed\r\n   */\n  static async getPatientData(patientId) {\n    if (!patientId) {\n      throw new Error('Patient ID is required');\n    }\n    try {\n      const patientRows = await fetchPatientCsvData(patientId);\n      if (!Array.isArray(patientRows) || patientRows.length === 0) {\n        throw new Error(`No data found for patient ${patientId}`);\n      }\n      return this.processPatientData(patientRows, patientId);\n    } catch (error) {\n      console.error(`Error fetching patient data for ${patientId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\r\n   Processes raw CSV data into structured patient information and health metrics\r\n   \r\n   - @param {Array} rows - Raw CSV data rows\r\n   - @param {string} patientId - The patient identifier\r\n   - @returns {Object} Structured patient data object\r\n   -  @throws {Error} If data structure is invalid or processing fails\r\n   */\n  static processPatientData(rows, patientId) {\n    if (!Array.isArray(rows) || rows.length === 0) {\n      throw new Error(`Invalid data structure for patient ${patientId}`);\n    }\n    const firstRowData = rows[0];\n    if (!firstRowData) {\n      throw new Error(`No valid data rows found for patient ${patientId}`);\n    }\n    const patientInfo = {\n      patientId,\n      patientNumber: patientId,\n      name: firstRowData['Name'] || 'Not specified',\n      age: firstRowData['Age'] || 'Not specified',\n      gender: firstRowData['Gender'] || 'Not specified',\n      dataAvailable: 'May 2025'\n    };\n\n    // Process medications using the cleaner individual medication fields\n    const detailedMedications = [];\n\n    // Get medication data from the first row (should be consistent across all rows for a patient)\n    const medicationNamesStr = firstRowData['Medication_Names'] || '';\n    const medicationTypesStr = firstRowData['Medication_Types'] || '';\n    const medicationCategoriesStr = firstRowData['Medication_Categories'] || '';\n    const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\n\n    // Split the semicolon-separated strings into arrays\n    const medicationNames = medicationNamesStr ? medicationNamesStr.split('; ').filter(Boolean) : [];\n    const medicationTypes = medicationTypesStr ? medicationTypesStr.split('; ').filter(Boolean) : [];\n    const medicationCategories = medicationCategoriesStr ? medicationCategoriesStr.split('; ').filter(Boolean) : [];\n    const medicationDosages = medicationDosagesStr ? medicationDosagesStr.split('; ').filter(Boolean) : [];\n\n    // Process each medication\n    for (let i = 0; i < Math.max(medicationNames.length, medicationTypes.length, medicationCategories.length, medicationDosages.length); i++) {\n      const name = medicationNames[i] || '';\n      const type = medicationTypes[i] || '';\n      const category = medicationCategories[i] || '';\n      const dosage = medicationDosages[i] || '';\n      if (name && name.trim() && !name.includes('Dose not specified') && name.length < 100 &&\n      // Filter out extremely long medication names\n      !name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) {\n        detailedMedications.push({\n          name: name.trim(),\n          schedule: dosage.trim(),\n          // Use dosage as schedule\n          category: '',\n          // Don't include category in visualization\n          dosage: ''\n        });\n      }\n    }\n\n    // Process conditions\n    const conditionsSet = new Set();\n    const conditionsRaw = [...new Set(rows.map(row => row['Chronic_Conditions'] || row['Conditions']).filter(Boolean))];\n    conditionsRaw.forEach(conditionString => {\n      conditionString.split(',').forEach(c => conditionsSet.add(c.trim()));\n    });\n\n    // Process all data types\n    const glucoseData = this.processGlucoseData(rows);\n    const bloodPressureData = this.processBloodPressureData(rows);\n    const exerciseData = this.processExerciseData(rows);\n    const moodData = this.processMoodData(rows);\n    const painData = this.processPainData(rows);\n    const sleepData = this.processSleepData(rows);\n    const mealData = this.processMealData(rows);\n    return {\n      patientInfo: {\n        ...patientInfo,\n        detailedMedications,\n        conditions: Array.from(conditionsSet)\n      },\n      glucoseData,\n      bloodPressureData,\n      exerciseData,\n      moodData,\n      painData,\n      mealData,\n      sleepData,\n      rawData: rows\n    };\n  }\n\n  /**\r\n   Processes blood glucose data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed glucose data with timestamps and ranges\r\n   */\n  static processGlucoseData(rows) {\n    return rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const readings = [];\n      const hasMultiColumn = row['Glucose_1'] !== undefined;\n      if (hasMultiColumn) {\n        for (let i = 1; i <= 4; i++) {\n          const value = parseFloat(row[`Glucose_${i}`]);\n          const timeStr = row[`Glucose_Time_${i}`];\n          if (value > 0 && timeStr) {\n            const [hours, minutes] = timeStr.split(':').map(Number);\n            const date = new Date(baseDate);\n            date.setHours(hours, minutes);\n            readings.push({\n              date,\n              value,\n              range: row[`Glucose_Range_${i}`],\n              measurementType: row[`Glucose_Measurement_Type_${i}`]\n            });\n          }\n        }\n      } else {\n        const value = parseFloat(row['Glucose_Level']);\n        if (value > 0) {\n          const randomHour = Math.floor(Math.random() * 24);\n          const randomMinute = Math.floor(Math.random() * 60);\n          const date = new Date(baseDate);\n          date.setHours(randomHour, randomMinute);\n          let range = 'in range';\n          if (value < 70) range = 'below range';else if (value > 180) range = 'above range';\n          readings.push({\n            date,\n            value,\n            range,\n            measurementType: 'Random'\n          });\n        }\n      }\n      return readings;\n    });\n  }\n\n  /**\r\n   Processes blood pressure data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed blood pressure data with systolic/diastolic values\r\n   */\n  static processBloodPressureData(rows) {\n    return rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const readings = [];\n      const hasMultiColumn = row['Systolic_1'] !== undefined;\n      if (hasMultiColumn) {\n        for (let i = 1; i <= 4; i++) {\n          const systolic = parseInt(row[`Systolic_${i}`]);\n          const diastolic = parseInt(row[`Diastolic_${i}`]);\n          const timeStr = row[`BP_Time_${i}`];\n          if (systolic > 0 && diastolic > 0 && timeStr) {\n            const [hours, minutes] = timeStr.split(':').map(Number);\n            const date = new Date(baseDate);\n            date.setHours(hours, minutes);\n            readings.push({\n              date,\n              systolic,\n              diastolic,\n              systolicType: row[`Systolic_Type_${i}`],\n              diastolicType: row[`Diastolic_Type_${i}`]\n            });\n          }\n        }\n      } else {\n        const systolic = parseInt(row['Systolic_BP']);\n        const diastolic = parseInt(row['Diastolic_BP']);\n        if (systolic > 0 && diastolic > 0) {\n          const randomHour = Math.floor(Math.random() * 24);\n          const randomMinute = Math.floor(Math.random() * 60);\n          const date = new Date(baseDate);\n          date.setHours(randomHour, randomMinute);\n          let systolicType = 'normal';\n          let diastolicType = 'normal';\n          if (systolic >= 180 || diastolic >= 120) {\n            systolicType = 'hypertensive crisis';\n            diastolicType = 'hypertensive crisis';\n          } else if (systolic >= 140 || diastolic >= 90) {\n            systolicType = 'high';\n            diastolicType = 'high';\n          } else if (systolic >= 130 || diastolic >= 80) {\n            systolicType = 'elevated';\n            diastolicType = 'elevated';\n          }\n          readings.push({\n            date,\n            systolic,\n            diastolic,\n            systolicType,\n            diastolicType\n          });\n        }\n      }\n      return readings;\n    });\n  }\n\n  /**\r\n   Processes exercise data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed exercise data with activity types and durations\r\n   */\n  static processExerciseData(rows) {\n    const exerciseByDate = {};\n    rows.forEach(row => {\n      const date = new Date(row['Date']);\n      const dateKey = date.toDateString();\n      if (!exerciseByDate[dateKey]) {\n        exerciseByDate[dateKey] = {\n          date,\n          walking: 0,\n          swimming: 0,\n          running: 0,\n          'resistance/weights': 0,\n          biking: 0,\n          'balance/stretching': 0,\n          other: 0,\n          totalMinutes: 0\n        };\n      }\n      const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\n      if (hasMultiColumn) {\n        for (let i = 1; i <= 3; i++) {\n          var _row;\n          const type = (_row = row[`Exercise_Type_${i}`]) === null || _row === void 0 ? void 0 : _row.toLowerCase();\n          const minutes = parseFloat(row[`Exercise_Minutes_${i}`]);\n          if (type && minutes > 0) {\n            this.categorizeExercise(type, minutes, exerciseByDate[dateKey]);\n          }\n        }\n      } else {\n        var _row$Exercise_Type;\n        const type = (_row$Exercise_Type = row['Exercise_Type']) === null || _row$Exercise_Type === void 0 ? void 0 : _row$Exercise_Type.toLowerCase();\n        const minutes = parseFloat(row['Exercise_Minutes']);\n        if (type && minutes > 0) {\n          this.categorizeExercise(type, minutes, exerciseByDate[dateKey]);\n        }\n      }\n    });\n    return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n  }\n\n  /**\r\n   Categorizes exercise activities into predefined types\r\n   \r\n   - @param {string} type - Exercise type from CSV\r\n   - @param {number} minutes - Duration in minutes\r\n   - @param {Object} dayData - Daily exercise data object\r\n   */\n  static categorizeExercise(type, minutes, dayData) {\n    if (type.includes('walking')) dayData.walking += minutes;else if (type.includes('swimming')) dayData.swimming += minutes;else if (type.includes('running')) dayData.running += minutes;else if (type.includes('resistance') || type.includes('weights')) dayData['resistance/weights'] += minutes;else if (type.includes('biking')) dayData.biking += minutes;else if (type.includes('balance') || type.includes('stretching')) dayData['balance/stretching'] += minutes;else dayData.other += minutes;\n    dayData.totalMinutes += minutes;\n  }\n\n  /**\r\n   Processes mood data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed mood data with categories\r\n   */\n  static processMoodData(rows) {\n    return rows.filter(row => row['Mood']).map(row => ({\n      date: new Date(row['Date']),\n      mood: row['Mood'],\n      category: row['Mood'] || 'neutral'\n    }));\n  }\n\n  /**\r\n   Processes pain data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed pain data with location and intensity\r\n   */\n  static processPainData(rows) {\n    return rows.filter(row => row['Pain_Location'] && row['Pain_Level']).map(row => ({\n      date: new Date(row['Date']),\n      location: row['Pain_Location'].toLowerCase(),\n      level: parseInt(row['Pain_Level'])\n    }));\n  }\n\n  /**\r\n   Processes sleep data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed sleep data with duration and quality\r\n   */\n  static processSleepData(rows) {\n    return rows.filter(row => row['Sleep_Hours'] && row['Sleep_Quality']).map(row => ({\n      date: new Date(row['Date']),\n      hours: parseFloat(row['Sleep_Hours']),\n      quality: row['Sleep_Quality'],\n      qualityCode: parseInt(row['Sleep_Quality_Code'])\n    }));\n  }\n\n  /**\r\n   Processes meal data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed meal data with nutritional components\r\n   */\n  static processMealData(rows) {\n    // Return the raw rows with meal data since MealContentsChart expects individual meal components\n    const filteredRows = rows.filter(row => {\n      // Check if any meal data exists for this row\n      const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\n      const hasMealData = mealTypes.some(mealType => {\n        const time = row[`${mealType}_Time`];\n        const protein = row[`${mealType}_Protein`];\n        const carbs = row[`${mealType}_Carbohydrates`];\n        const vegetables = row[`${mealType}_Vegetables`];\n        const fruit = row[`${mealType}_Fruit`];\n        const alcohol = row[`${mealType}_Alcohol`];\n        const sugar = row[`${mealType}_Added_Sugar`];\n\n        // Check if time exists and at least one food component is present\n        // Handle both numeric (1, 0) and string ('1', '0') values\n        const hasFood = protein === 1 || protein === '1' || carbs === 1 || carbs === '1' || vegetables === 1 || vegetables === '1' || fruit === 1 || fruit === '1' || alcohol === 1 || alcohol === '1' || sugar && sugar !== '' && sugar !== 'NaN';\n        return time && hasFood;\n      });\n      return hasMealData;\n    });\n    return filteredRows;\n  }\n}\nexport default DataService;","map":{"version":3,"names":["Papa","CSV_CONFIG","header","skipEmptyLines","transformHeader","trim","transform","value","fetchPatientCsvData","patientId","response","fetch","Date","now","ok","Error","status","statusText","csvText","text","length","parsed","parse","errors","console","error","data","DataService","getPatientData","patientRows","Array","isArray","processPatientData","rows","firstRowData","patientInfo","patientNumber","name","age","gender","dataAvailable","detailedMedications","medicationNamesStr","medicationTypesStr","medicationCategoriesStr","medicationDosagesStr","medicationNames","split","filter","Boolean","medicationTypes","medicationCategories","medicationDosages","i","Math","max","type","category","dosage","includes","push","schedule","conditionsSet","Set","conditionsRaw","map","row","forEach","conditionString","c","add","glucoseData","processGlucoseData","bloodPressureData","processBloodPressureData","exerciseData","processExerciseData","moodData","processMoodData","painData","processPainData","sleepData","processSleepData","mealData","processMealData","conditions","from","rawData","flatMap","baseDate","readings","hasMultiColumn","undefined","parseFloat","timeStr","hours","minutes","Number","date","setHours","range","measurementType","randomHour","floor","random","randomMinute","systolic","parseInt","diastolic","systolicType","diastolicType","exerciseByDate","dateKey","toDateString","walking","swimming","running","biking","other","totalMinutes","_row","toLowerCase","categorizeExercise","_row$Exercise_Type","Object","values","d","dayData","mood","location","level","quality","qualityCode","filteredRows","mealTypes","hasMealData","some","mealType","time","protein","carbs","vegetables","fruit","alcohol","sugar","hasFood"],"sources":["C:/Users/Matteo/Working_Folder/a. MCC Thesis Local/Health_data_dashboard-MCC_project_checkpoint/src/services/dataService.js"],"sourcesContent":["/*\r\n dataService.js - Patient Data Service\r\n \r\n This service handles all data operations for the health dashboard:\r\n - Fetches patient CSV data from the server\r\n - Parses and processes CSV data using PapaParse\r\n - Transforms raw data into structured health metrics\r\n - Provides data validation and error handling\r\n - Manages patient information, medications, and health tracking data\r\n - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\r\n \r\n Architecture:\r\n - Uses PapaParse library for CSV parsing\r\n - Implements service class pattern for data operations\r\n - Provides comprehensive error handling and validation\r\n - Supports multiple data formats and structures\r\n \r\n Data Processing:\r\n - CSV parsing with header validation\r\n - Data transformation and normalization\r\n - Type conversion and validation\r\n - Error recovery and fallback mechanisms\r\n \r\n Health Metrics Supported:\r\n - Blood glucose monitoring with meal context\r\n - Blood pressure tracking with risk categorization\r\n - Exercise activity tracking and categorization\r\n - Mood assessment and tracking\r\n - Pain reporting with anatomical mapping\r\n - Sleep quality and duration analysis\r\n - Nutritional intake and meal composition\r\n \r\n Error Handling:\r\n - Network error recovery\r\n - CSV parsing error handling\r\n - Data validation and sanitization\r\n - Graceful degradation for missing data\r\n \r\n Core service for data management and processing throughout the application.\r\n */\r\n\r\nimport Papa from 'papaparse';\r\n\r\n// Configuration for CSV parsing\r\nconst CSV_CONFIG = {\r\n  header: true,\r\n  skipEmptyLines: true,\r\n  transformHeader: (header) => header.trim(),\r\n  transform: (value) => value?.trim(),\r\n};\r\n\r\n/*\r\n Fetches and parses CSV data for a specific patient\r\n \r\n - @param {string} patientId - The patient identifier\r\n - @returns {Promise<Array>} Parsed CSV data as array of objects\r\n - @throws {Error} If CSV fetch or parsing fails\r\n */\r\nconst fetchPatientCsvData = async (patientId) => {\r\n  try {\r\n    // Add cache busting to ensure fresh data\r\n    const response = await fetch(`/synthetic_patients/${patientId}.csv?v=${Date.now()}`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\r\n    }\r\n    \r\n    const csvText = await response.text();\r\n    \r\n    if (!csvText || csvText.trim().length === 0) {\r\n      throw new Error(`Empty CSV file for patient ${patientId}`);\r\n    }\r\n    \r\n    const parsed = Papa.parse(csvText, CSV_CONFIG);\r\n    \r\n    if (parsed.errors.length > 0) {\r\n      // Log parsing errors for debugging but don't throw\r\n      console.error(`CSV parsing errors for ${patientId}:`, parsed.errors);\r\n    }\r\n    \r\n    return parsed.data;\r\n  } catch (error) {\r\n    console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/*\r\n Service class for handling patient data operations\r\n Provides methods for fetching and processing patient health data from CSV files\r\n */\r\nclass DataService {\r\n  /*\r\n   Retrieves and processes all data for a specific patient\r\n   \r\n   - @param {string} patientId - The patient identifier\r\n   - @returns {Promise<Object>} Processed patient data including all health metrics\r\n   - @throws {Error} If patient data cannot be retrieved or processed\r\n   */\r\n  static async getPatientData(patientId) {\r\n    if (!patientId) {\r\n      throw new Error('Patient ID is required');\r\n    }\r\n\r\n    try {\r\n      const patientRows = await fetchPatientCsvData(patientId);\r\n\r\n      if (!Array.isArray(patientRows) || patientRows.length === 0) {\r\n        throw new Error(`No data found for patient ${patientId}`);\r\n      }\r\n\r\n      return this.processPatientData(patientRows, patientId);\r\n    } catch (error) {\r\n      console.error(`Error fetching patient data for ${patientId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   Processes raw CSV data into structured patient information and health metrics\r\n   \r\n   - @param {Array} rows - Raw CSV data rows\r\n   - @param {string} patientId - The patient identifier\r\n   - @returns {Object} Structured patient data object\r\n   -  @throws {Error} If data structure is invalid or processing fails\r\n   */\r\n  static processPatientData(rows, patientId) {\r\n    if (!Array.isArray(rows) || rows.length === 0) {\r\n      throw new Error(`Invalid data structure for patient ${patientId}`);\r\n    }\r\n\r\n    const firstRowData = rows[0];\r\n    if (!firstRowData) {\r\n      throw new Error(`No valid data rows found for patient ${patientId}`);\r\n    }\r\n\r\n    const patientInfo = {\r\n      patientId,\r\n      patientNumber: patientId,\r\n      name: firstRowData['Name'] || 'Not specified',\r\n      age: firstRowData['Age'] || 'Not specified',\r\n      gender: firstRowData['Gender'] || 'Not specified',\r\n      dataAvailable: 'May 2025'\r\n    };\r\n\r\n    // Process medications using the cleaner individual medication fields\r\n    const detailedMedications = [];\r\n    \r\n    // Get medication data from the first row (should be consistent across all rows for a patient)\r\n    const medicationNamesStr = firstRowData['Medication_Names'] || '';\r\n    const medicationTypesStr = firstRowData['Medication_Types'] || '';\r\n    const medicationCategoriesStr = firstRowData['Medication_Categories'] || '';\r\n    const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\r\n    \r\n    // Split the semicolon-separated strings into arrays\r\n    const medicationNames = medicationNamesStr ? medicationNamesStr.split('; ').filter(Boolean) : [];\r\n    const medicationTypes = medicationTypesStr ? medicationTypesStr.split('; ').filter(Boolean) : [];\r\n    const medicationCategories = medicationCategoriesStr ? medicationCategoriesStr.split('; ').filter(Boolean) : [];\r\n    const medicationDosages = medicationDosagesStr ? medicationDosagesStr.split('; ').filter(Boolean) : [];\r\n    \r\n    // Process each medication\r\n    for (let i = 0; i < Math.max(medicationNames.length, medicationTypes.length, medicationCategories.length, medicationDosages.length); i++) {\r\n        const name = medicationNames[i] || '';\r\n        const type = medicationTypes[i] || '';\r\n        const category = medicationCategories[i] || '';\r\n        const dosage = medicationDosages[i] || '';\r\n        \r\n        if (name && name.trim() && \r\n            !name.includes('Dose not specified') && \r\n            name.length < 100 && // Filter out extremely long medication names\r\n            !name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) {\r\n            detailedMedications.push({\r\n                name: name.trim(),\r\n                schedule: dosage.trim(), // Use dosage as schedule\r\n                category: '', // Don't include category in visualization\r\n                dosage: ''\r\n            });\r\n        }\r\n    }\r\n\r\n    // Process conditions\r\n    const conditionsSet = new Set();\r\n    const conditionsRaw = [...new Set(rows.map(row => row['Chronic_Conditions'] || row['Conditions']).filter(Boolean))];\r\n    conditionsRaw.forEach(conditionString => {\r\n        conditionString.split(',').forEach(c => conditionsSet.add(c.trim()));\r\n    });\r\n\r\n    // Process all data types\r\n    const glucoseData = this.processGlucoseData(rows);\r\n    const bloodPressureData = this.processBloodPressureData(rows);\r\n    const exerciseData = this.processExerciseData(rows);\r\n    const moodData = this.processMoodData(rows);\r\n    const painData = this.processPainData(rows);\r\n    const sleepData = this.processSleepData(rows);\r\n    const mealData = this.processMealData(rows);\r\n\r\n    return {\r\n      patientInfo: { \r\n        ...patientInfo, \r\n        detailedMedications, \r\n        conditions: Array.from(conditionsSet)\r\n      },\r\n      glucoseData,\r\n      bloodPressureData,\r\n      exerciseData,\r\n      moodData,\r\n      painData,\r\n      mealData,\r\n      sleepData,\r\n      rawData: rows\r\n    };\r\n  }\r\n\r\n  /**\r\n   Processes blood glucose data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed glucose data with timestamps and ranges\r\n   */\r\n  static processGlucoseData(rows) {\r\n    return rows.flatMap(row => {\r\n      const baseDate = new Date(row['Date']);\r\n      const readings = [];\r\n      \r\n      const hasMultiColumn = row['Glucose_1'] !== undefined;\r\n      \r\n      if (hasMultiColumn) {\r\n        for (let i = 1; i <= 4; i++) {\r\n          const value = parseFloat(row[`Glucose_${i}`]);\r\n          const timeStr = row[`Glucose_Time_${i}`];\r\n          if (value > 0 && timeStr) {\r\n            const [hours, minutes] = timeStr.split(':').map(Number);\r\n            const date = new Date(baseDate);\r\n            date.setHours(hours, minutes);\r\n            readings.push({\r\n              date,\r\n              value,\r\n              range: row[`Glucose_Range_${i}`],\r\n              measurementType: row[`Glucose_Measurement_Type_${i}`]\r\n            });\r\n          }\r\n        }\r\n      } else {\r\n        const value = parseFloat(row['Glucose_Level']);\r\n        if (value > 0) {\r\n          const randomHour = Math.floor(Math.random() * 24);\r\n          const randomMinute = Math.floor(Math.random() * 60);\r\n          const date = new Date(baseDate);\r\n          date.setHours(randomHour, randomMinute);\r\n          \r\n          let range = 'in range';\r\n          if (value < 70) range = 'below range';\r\n          else if (value > 180) range = 'above range';\r\n          \r\n          readings.push({\r\n            date,\r\n            value,\r\n            range,\r\n            measurementType: 'Random'\r\n          });\r\n        }\r\n      }\r\n      \r\n      return readings;\r\n    });\r\n  }\r\n\r\n  /**\r\n   Processes blood pressure data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed blood pressure data with systolic/diastolic values\r\n   */\r\n  static processBloodPressureData(rows) {\r\n    return rows.flatMap(row => {\r\n        const baseDate = new Date(row['Date']);\r\n        const readings = [];\r\n        \r\n        const hasMultiColumn = row['Systolic_1'] !== undefined;\r\n        \r\n        if (hasMultiColumn) {\r\n            for (let i = 1; i <= 4; i++) {\r\n                const systolic = parseInt(row[`Systolic_${i}`]);\r\n                const diastolic = parseInt(row[`Diastolic_${i}`]);\r\n                const timeStr = row[`BP_Time_${i}`];\r\n                if (systolic > 0 && diastolic > 0 && timeStr) {\r\n                    const [hours, minutes] = timeStr.split(':').map(Number);\r\n                    const date = new Date(baseDate);\r\n                    date.setHours(hours, minutes);\r\n                    readings.push({ \r\n                        date, \r\n                        systolic, \r\n                        diastolic, \r\n                        systolicType: row[`Systolic_Type_${i}`],\r\n                        diastolicType: row[`Diastolic_Type_${i}`]\r\n                    });\r\n                }\r\n            }\r\n        } else {\r\n            const systolic = parseInt(row['Systolic_BP']);\r\n            const diastolic = parseInt(row['Diastolic_BP']);\r\n            if (systolic > 0 && diastolic > 0) {\r\n                const randomHour = Math.floor(Math.random() * 24);\r\n                const randomMinute = Math.floor(Math.random() * 60);\r\n                const date = new Date(baseDate);\r\n                date.setHours(randomHour, randomMinute);\r\n                \r\n                let systolicType = 'normal';\r\n                let diastolicType = 'normal';\r\n                if (systolic >= 180 || diastolic >= 120) {\r\n                    systolicType = 'hypertensive crisis';\r\n                    diastolicType = 'hypertensive crisis';\r\n                } else if (systolic >= 140 || diastolic >= 90) {\r\n                    systolicType = 'high';\r\n                    diastolicType = 'high';\r\n                } else if (systolic >= 130 || diastolic >= 80) {\r\n                    systolicType = 'elevated';\r\n                    diastolicType = 'elevated';\r\n                }\r\n                \r\n                readings.push({ \r\n                    date, \r\n                    systolic, \r\n                    diastolic, \r\n                    systolicType,\r\n                    diastolicType\r\n                });\r\n            }\r\n        }\r\n        \r\n        return readings;\r\n    });\r\n  }\r\n\r\n  /**\r\n   Processes exercise data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed exercise data with activity types and durations\r\n   */\r\n  static processExerciseData(rows) {\r\n    const exerciseByDate = {};\r\n    \r\n    rows.forEach(row => {\r\n        const date = new Date(row['Date']);\r\n        const dateKey = date.toDateString();\r\n        if (!exerciseByDate[dateKey]) {\r\n            exerciseByDate[dateKey] = { date, walking: 0, swimming: 0, running: 0, 'resistance/weights': 0, biking: 0, 'balance/stretching': 0, other: 0, totalMinutes: 0 };\r\n        }\r\n        \r\n        const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\r\n        \r\n        if (hasMultiColumn) {\r\n            for (let i = 1; i <= 3; i++) {\r\n                const type = row[`Exercise_Type_${i}`]?.toLowerCase();\r\n                const minutes = parseFloat(row[`Exercise_Minutes_${i}`]);\r\n                if (type && minutes > 0) {\r\n                    this.categorizeExercise(type, minutes, exerciseByDate[dateKey]);\r\n                }\r\n            }\r\n        } else {\r\n            const type = row['Exercise_Type']?.toLowerCase();\r\n            const minutes = parseFloat(row['Exercise_Minutes']);\r\n            if (type && minutes > 0) {\r\n                this.categorizeExercise(type, minutes, exerciseByDate[dateKey]);\r\n            }\r\n        }\r\n    });\r\n    \r\n    return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\r\n  }\r\n\r\n  /**\r\n   Categorizes exercise activities into predefined types\r\n   \r\n   - @param {string} type - Exercise type from CSV\r\n   - @param {number} minutes - Duration in minutes\r\n   - @param {Object} dayData - Daily exercise data object\r\n   */\r\n  static categorizeExercise(type, minutes, dayData) {\r\n    if (type.includes('walking')) dayData.walking += minutes;\r\n    else if (type.includes('swimming')) dayData.swimming += minutes;\r\n    else if (type.includes('running')) dayData.running += minutes;\r\n    else if (type.includes('resistance') || type.includes('weights')) dayData['resistance/weights'] += minutes;\r\n    else if (type.includes('biking')) dayData.biking += minutes;\r\n    else if (type.includes('balance') || type.includes('stretching')) dayData['balance/stretching'] += minutes;\r\n    else dayData.other += minutes;\r\n    dayData.totalMinutes += minutes;\r\n  }\r\n\r\n  /**\r\n   Processes mood data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed mood data with categories\r\n   */\r\n  static processMoodData(rows) {\r\n    return rows.filter(row => row['Mood']).map(row => ({\r\n        date: new Date(row['Date']),\r\n        mood: row['Mood'],\r\n        category: row['Mood'] || 'neutral'\r\n    }));\r\n  }\r\n\r\n  /**\r\n   Processes pain data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed pain data with location and intensity\r\n   */\r\n  static processPainData(rows) {\r\n    return rows.filter(row => row['Pain_Location'] && row['Pain_Level']).map(row => ({\r\n        date: new Date(row['Date']),\r\n        location: row['Pain_Location'].toLowerCase(),\r\n        level: parseInt(row['Pain_Level'])\r\n    }));\r\n  }\r\n\r\n  /**\r\n   Processes sleep data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed sleep data with duration and quality\r\n   */\r\n  static processSleepData(rows) {\r\n    return rows.filter(row => row['Sleep_Hours'] && row['Sleep_Quality']).map(row => ({\r\n        date: new Date(row['Date']),\r\n        hours: parseFloat(row['Sleep_Hours']),\r\n        quality: row['Sleep_Quality'],\r\n        qualityCode: parseInt(row['Sleep_Quality_Code'])\r\n    }));\r\n  }\r\n\r\n  /**\r\n   Processes meal data from CSV rows\r\n   \r\n   - @param {Array} rows - CSV data rows\r\n   - @returns {Array} Processed meal data with nutritional components\r\n   */\r\n  static processMealData(rows) {\r\n    // Return the raw rows with meal data since MealContentsChart expects individual meal components\r\n    const filteredRows = rows.filter(row => {\r\n      // Check if any meal data exists for this row\r\n      const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\r\n      \r\n      const hasMealData = mealTypes.some(mealType => {\r\n        const time = row[`${mealType}_Time`];\r\n        const protein = row[`${mealType}_Protein`];\r\n        const carbs = row[`${mealType}_Carbohydrates`];\r\n        const vegetables = row[`${mealType}_Vegetables`];\r\n        const fruit = row[`${mealType}_Fruit`];\r\n        const alcohol = row[`${mealType}_Alcohol`];\r\n        const sugar = row[`${mealType}_Added_Sugar`];\r\n        \r\n        // Check if time exists and at least one food component is present\r\n        // Handle both numeric (1, 0) and string ('1', '0') values\r\n        const hasFood = protein === 1 || protein === '1' || \r\n                       carbs === 1 || carbs === '1' || \r\n                       vegetables === 1 || vegetables === '1' || \r\n                       fruit === 1 || fruit === '1' || \r\n                       alcohol === 1 || alcohol === '1' || \r\n                       (sugar && sugar !== '' && sugar !== 'NaN');\r\n        \r\n        return time && hasFood;\r\n      });\r\n      \r\n      return hasMealData;\r\n    });\r\n    \r\n    return filteredRows;\r\n  }\r\n}\r\n\r\nexport default DataService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}