{"ast":null,"code":"import _objectSpread from\"C:/Users/Matteo/Working_Folder/a. MCC Thesis Local/MCC_digital_health_data_visualizations/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/**\n * dataService.js - Patient Data Service\n * \n * This service handles all data operations for the health dashboard:\n * - Fetches patient CSV data from the server\n * - Parses and processes CSV data using PapaParse\n * - Transforms raw data into structured health metrics\n * - Provides data validation and error handling\n * - Manages patient information, medications, and health tracking data\n * - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\n * \n * ARCHITECTURE:\n * - Uses PapaParse library for CSV parsing\n * - Implements service class pattern for data operations\n * - Provides comprehensive error handling and validation\n * - Supports multiple data formats and structures\n * \n * DATA PROCESSING:\n * - CSV parsing with header validation\n * - Data transformation and normalization\n * - Type conversion and validation\n * - Error recovery and fallback mechanisms\n * \n * HEALTH METRICS SUPPORTED:\n * - Blood glucose monitoring with meal context\n * - Blood pressure tracking with risk categorization\n * - Exercise activity tracking and categorization\n * - Mood assessment and tracking\n * - Pain reporting with anatomical mapping\n * - Sleep quality and duration analysis\n * - Nutritional intake and meal composition\n * \n * ERROR HANDLING:\n * - Network error recovery\n * - CSV parsing error handling\n * - Data validation and sanitization\n * - Graceful degradation for missing data\n * \n * Core service for data management and processing throughout the application.\n */import Papa from'papaparse';// Configuration for CSV parsing\nconst CSV_CONFIG={header:true,skipEmptyLines:true,transformHeader:header=>header.trim(),transform:value=>value===null||value===void 0?void 0:value.trim()};/**\n * Fetches and parses CSV data for a specific patient\n * \n * @param {string} patientId - The patient identifier\n * @returns {Promise<Array>} Parsed CSV data as array of objects\n * @throws {Error} If CSV fetch or parsing fails\n */const fetchPatientCsvData=async patientId=>{try{// Add cache busting to ensure fresh data\nconst response=await fetch(\"/synthetic_patients/\".concat(patientId,\".csv?v=\").concat(Date.now()));if(!response.ok){throw new Error(\"Failed to fetch CSV for \".concat(patientId,\": \").concat(response.status,\" \").concat(response.statusText));}const csvText=await response.text();if(!csvText||csvText.trim().length===0){throw new Error(\"Empty CSV file for patient \".concat(patientId));}const parsed=Papa.parse(csvText,CSV_CONFIG);if(parsed.errors.length>0){// Log parsing errors for debugging but don't throw\nconsole.error(\"CSV parsing errors for \".concat(patientId,\":\"),parsed.errors);}return parsed.data;}catch(error){console.error(\"Error fetching or parsing CSV for \".concat(patientId,\":\"),error);throw error;}};/**\n * Service class for handling patient data operations\n * Provides methods for fetching and processing patient health data from CSV files\n */class DataService{/**\n   * Retrieves and processes all data for a specific patient\n   * \n   * @param {string} patientId - The patient identifier\n   * @returns {Promise<Object>} Processed patient data including all health metrics\n   * @throws {Error} If patient data cannot be retrieved or processed\n   */static async getPatientData(patientId){if(!patientId){throw new Error('Patient ID is required');}try{const patientRows=await fetchPatientCsvData(patientId);if(!Array.isArray(patientRows)||patientRows.length===0){throw new Error(\"No data found for patient \".concat(patientId));}return this.processPatientData(patientRows,patientId);}catch(error){console.error(\"Error fetching patient data for \".concat(patientId,\":\"),error);throw error;}}/**\n   * Processes raw CSV data into structured patient information and health metrics\n   * \n   * @param {Array} rows - Raw CSV data rows\n   * @param {string} patientId - The patient identifier\n   * @returns {Object} Structured patient data object\n   * @throws {Error} If data structure is invalid or processing fails\n   */static processPatientData(rows,patientId){if(!Array.isArray(rows)||rows.length===0){throw new Error(\"Invalid data structure for patient \".concat(patientId));}const firstRowData=rows[0];if(!firstRowData){throw new Error(\"No valid data rows found for patient \".concat(patientId));}const patientInfo={patientId,patientNumber:patientId,name:firstRowData['Name']||'Not specified',age:firstRowData['Age']||'Not specified',gender:firstRowData['Gender']||'Not specified',dataAvailable:'May 2025'};// Process medications using the cleaner individual medication fields\nconst detailedMedications=[];// Get medication data from the first row (should be consistent across all rows for a patient)\nconst medicationNamesStr=firstRowData['Medication_Names']||'';const medicationTypesStr=firstRowData['Medication_Types']||'';const medicationCategoriesStr=firstRowData['Medication_Categories']||'';const medicationDosagesStr=firstRowData['Medication_Dosages']||'';// Split the semicolon-separated strings into arrays\nconst medicationNames=medicationNamesStr?medicationNamesStr.split('; ').filter(Boolean):[];const medicationTypes=medicationTypesStr?medicationTypesStr.split('; ').filter(Boolean):[];const medicationCategories=medicationCategoriesStr?medicationCategoriesStr.split('; ').filter(Boolean):[];const medicationDosages=medicationDosagesStr?medicationDosagesStr.split('; ').filter(Boolean):[];// Process each medication\nfor(let i=0;i<Math.max(medicationNames.length,medicationTypes.length,medicationCategories.length,medicationDosages.length);i++){const name=medicationNames[i]||'';const type=medicationTypes[i]||'';const category=medicationCategories[i]||'';const dosage=medicationDosages[i]||'';if(name&&name.trim()&&!name.includes('Dose not specified')&&name.length<100&&// Filter out extremely long medication names\n!name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')){detailedMedications.push({name:name.trim(),schedule:dosage.trim(),// Use dosage as schedule\ncategory:'',// Don't include category in visualization\ndosage:''});}}// Process conditions\nconst conditionsSet=new Set();const conditionsRaw=[...new Set(rows.map(row=>row['Chronic_Conditions']||row['Conditions']).filter(Boolean))];conditionsRaw.forEach(conditionString=>{conditionString.split(',').forEach(c=>conditionsSet.add(c.trim()));});// Process all data types\nconst glucoseData=this.processGlucoseData(rows);const bloodPressureData=this.processBloodPressureData(rows);const exerciseData=this.processExerciseData(rows);const moodData=this.processMoodData(rows);const painData=this.processPainData(rows);const sleepData=this.processSleepData(rows);const mealData=this.processMealData(rows);return{patientInfo:_objectSpread(_objectSpread({},patientInfo),{},{detailedMedications,conditions:Array.from(conditionsSet)}),glucoseData,bloodPressureData,exerciseData,moodData,painData,mealData,sleepData,rawData:rows};}/**\n   * Processes blood glucose data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed glucose data with timestamps and ranges\n   */static processGlucoseData(rows){return rows.flatMap(row=>{const baseDate=new Date(row['Date']);const readings=[];const hasMultiColumn=row['Glucose_1']!==undefined;if(hasMultiColumn){for(let i=1;i<=4;i++){const value=parseFloat(row[\"Glucose_\".concat(i)]);const timeStr=row[\"Glucose_Time_\".concat(i)];if(value>0&&timeStr){const[hours,minutes]=timeStr.split(':').map(Number);const date=new Date(baseDate);date.setHours(hours,minutes);readings.push({date,value,range:row[\"Glucose_Range_\".concat(i)],measurementType:row[\"Glucose_Measurement_Type_\".concat(i)]});}}}else{const value=parseFloat(row['Glucose_Level']);if(value>0){const randomHour=Math.floor(Math.random()*24);const randomMinute=Math.floor(Math.random()*60);const date=new Date(baseDate);date.setHours(randomHour,randomMinute);let range='in range';if(value<70)range='below range';else if(value>180)range='above range';readings.push({date,value,range,measurementType:'Random'});}}return readings;});}/**\n   * Processes blood pressure data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed blood pressure data with systolic/diastolic values\n   */static processBloodPressureData(rows){return rows.flatMap(row=>{const baseDate=new Date(row['Date']);const readings=[];const hasMultiColumn=row['Systolic_1']!==undefined;if(hasMultiColumn){for(let i=1;i<=4;i++){const systolic=parseInt(row[\"Systolic_\".concat(i)]);const diastolic=parseInt(row[\"Diastolic_\".concat(i)]);const timeStr=row[\"BP_Time_\".concat(i)];if(systolic>0&&diastolic>0&&timeStr){const[hours,minutes]=timeStr.split(':').map(Number);const date=new Date(baseDate);date.setHours(hours,minutes);readings.push({date,systolic,diastolic,systolicType:row[\"Systolic_Type_\".concat(i)],diastolicType:row[\"Diastolic_Type_\".concat(i)]});}}}else{const systolic=parseInt(row['Systolic_BP']);const diastolic=parseInt(row['Diastolic_BP']);if(systolic>0&&diastolic>0){const randomHour=Math.floor(Math.random()*24);const randomMinute=Math.floor(Math.random()*60);const date=new Date(baseDate);date.setHours(randomHour,randomMinute);let systolicType='normal';let diastolicType='normal';if(systolic>=180||diastolic>=120){systolicType='hypertensive crisis';diastolicType='hypertensive crisis';}else if(systolic>=140||diastolic>=90){systolicType='high';diastolicType='high';}else if(systolic>=130||diastolic>=80){systolicType='elevated';diastolicType='elevated';}readings.push({date,systolic,diastolic,systolicType,diastolicType});}}return readings;});}/**\n   * Processes exercise data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed exercise data with activity types and durations\n   */static processExerciseData(rows){const exerciseByDate={};rows.forEach(row=>{const date=new Date(row['Date']);const dateKey=date.toDateString();if(!exerciseByDate[dateKey]){exerciseByDate[dateKey]={date,walking:0,swimming:0,running:0,'resistance/weights':0,biking:0,'balance/stretching':0,other:0,totalMinutes:0};}const hasMultiColumn=row['Exercise_Type_1']!==undefined;if(hasMultiColumn){for(let i=1;i<=3;i++){var _row;const type=(_row=row[\"Exercise_Type_\".concat(i)])===null||_row===void 0?void 0:_row.toLowerCase();const minutes=parseFloat(row[\"Exercise_Minutes_\".concat(i)]);if(type&&minutes>0){this.categorizeExercise(type,minutes,exerciseByDate[dateKey]);}}}else{var _row$Exercise_Type;const type=(_row$Exercise_Type=row['Exercise_Type'])===null||_row$Exercise_Type===void 0?void 0:_row$Exercise_Type.toLowerCase();const minutes=parseFloat(row['Exercise_Minutes']);if(type&&minutes>0){this.categorizeExercise(type,minutes,exerciseByDate[dateKey]);}}});return Object.values(exerciseByDate).filter(d=>d.totalMinutes>0);}/**\n   * Categorizes exercise activities into predefined types\n   * \n   * @param {string} type - Exercise type from CSV\n   * @param {number} minutes - Duration in minutes\n   * @param {Object} dayData - Daily exercise data object\n   */static categorizeExercise(type,minutes,dayData){if(type.includes('walking'))dayData.walking+=minutes;else if(type.includes('swimming'))dayData.swimming+=minutes;else if(type.includes('running'))dayData.running+=minutes;else if(type.includes('resistance')||type.includes('weights'))dayData['resistance/weights']+=minutes;else if(type.includes('biking'))dayData.biking+=minutes;else if(type.includes('balance')||type.includes('stretching'))dayData['balance/stretching']+=minutes;else dayData.other+=minutes;dayData.totalMinutes+=minutes;}/**\n   * Processes mood data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed mood data with categories\n   */static processMoodData(rows){return rows.filter(row=>row['Mood']).map(row=>({date:new Date(row['Date']),mood:row['Mood'],category:row['Mood']||'neutral'}));}/**\n   * Processes pain data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed pain data with location and intensity\n   */static processPainData(rows){return rows.filter(row=>row['Pain_Location']&&row['Pain_Level']).map(row=>({date:new Date(row['Date']),location:row['Pain_Location'].toLowerCase(),level:parseInt(row['Pain_Level'])}));}/**\n   * Processes sleep data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed sleep data with duration and quality\n   */static processSleepData(rows){return rows.filter(row=>row['Sleep_Hours']&&row['Sleep_Quality']).map(row=>({date:new Date(row['Date']),hours:parseFloat(row['Sleep_Hours']),quality:row['Sleep_Quality'],qualityCode:parseInt(row['Sleep_Quality_Code'])}));}/**\n   * Processes meal data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed meal data with nutritional components\n   */static processMealData(rows){// Return the raw rows with meal data since MealContentsChart expects individual meal components\nconst filteredRows=rows.filter(row=>{// Check if any meal data exists for this row\nconst mealTypes=['Breakfast','Lunch','Dinner','Late Night Snack'];const hasMealData=mealTypes.some(mealType=>{const time=row[\"\".concat(mealType,\"_Time\")];const protein=row[\"\".concat(mealType,\"_Protein\")];const carbs=row[\"\".concat(mealType,\"_Carbohydrates\")];const vegetables=row[\"\".concat(mealType,\"_Vegetables\")];const fruit=row[\"\".concat(mealType,\"_Fruit\")];const alcohol=row[\"\".concat(mealType,\"_Alcohol\")];const sugar=row[\"\".concat(mealType,\"_Added_Sugar\")];// Check if time exists and at least one food component is present\n// Handle both numeric (1, 0) and string ('1', '0') values\nconst hasFood=protein===1||protein==='1'||carbs===1||carbs==='1'||vegetables===1||vegetables==='1'||fruit===1||fruit==='1'||alcohol===1||alcohol==='1'||sugar&&sugar!==''&&sugar!=='NaN';return time&&hasFood;});return hasMealData;});return filteredRows;}}export default DataService;","map":{"version":3,"names":["Papa","CSV_CONFIG","header","skipEmptyLines","transformHeader","trim","transform","value","fetchPatientCsvData","patientId","response","fetch","concat","Date","now","ok","Error","status","statusText","csvText","text","length","parsed","parse","errors","console","error","data","DataService","getPatientData","patientRows","Array","isArray","processPatientData","rows","firstRowData","patientInfo","patientNumber","name","age","gender","dataAvailable","detailedMedications","medicationNamesStr","medicationTypesStr","medicationCategoriesStr","medicationDosagesStr","medicationNames","split","filter","Boolean","medicationTypes","medicationCategories","medicationDosages","i","Math","max","type","category","dosage","includes","push","schedule","conditionsSet","Set","conditionsRaw","map","row","forEach","conditionString","c","add","glucoseData","processGlucoseData","bloodPressureData","processBloodPressureData","exerciseData","processExerciseData","moodData","processMoodData","painData","processPainData","sleepData","processSleepData","mealData","processMealData","_objectSpread","conditions","from","rawData","flatMap","baseDate","readings","hasMultiColumn","undefined","parseFloat","timeStr","hours","minutes","Number","date","setHours","range","measurementType","randomHour","floor","random","randomMinute","systolic","parseInt","diastolic","systolicType","diastolicType","exerciseByDate","dateKey","toDateString","walking","swimming","running","biking","other","totalMinutes","_row","toLowerCase","categorizeExercise","_row$Exercise_Type","Object","values","d","dayData","mood","location","level","quality","qualityCode","filteredRows","mealTypes","hasMealData","some","mealType","time","protein","carbs","vegetables","fruit","alcohol","sugar","hasFood"],"sources":["C:/Users/Matteo/Working_Folder/a. MCC Thesis Local/MCC_digital_health_data_visualizations/src/services/dataService.js"],"sourcesContent":["/**\n * dataService.js - Patient Data Service\n * \n * This service handles all data operations for the health dashboard:\n * - Fetches patient CSV data from the server\n * - Parses and processes CSV data using PapaParse\n * - Transforms raw data into structured health metrics\n * - Provides data validation and error handling\n * - Manages patient information, medications, and health tracking data\n * - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\n * \n * ARCHITECTURE:\n * - Uses PapaParse library for CSV parsing\n * - Implements service class pattern for data operations\n * - Provides comprehensive error handling and validation\n * - Supports multiple data formats and structures\n * \n * DATA PROCESSING:\n * - CSV parsing with header validation\n * - Data transformation and normalization\n * - Type conversion and validation\n * - Error recovery and fallback mechanisms\n * \n * HEALTH METRICS SUPPORTED:\n * - Blood glucose monitoring with meal context\n * - Blood pressure tracking with risk categorization\n * - Exercise activity tracking and categorization\n * - Mood assessment and tracking\n * - Pain reporting with anatomical mapping\n * - Sleep quality and duration analysis\n * - Nutritional intake and meal composition\n * \n * ERROR HANDLING:\n * - Network error recovery\n * - CSV parsing error handling\n * - Data validation and sanitization\n * - Graceful degradation for missing data\n * \n * Core service for data management and processing throughout the application.\n */\n\nimport Papa from 'papaparse';\n\n// Configuration for CSV parsing\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: (header) => header.trim(),\n  transform: (value) => value?.trim(),\n};\n\n/**\n * Fetches and parses CSV data for a specific patient\n * \n * @param {string} patientId - The patient identifier\n * @returns {Promise<Array>} Parsed CSV data as array of objects\n * @throws {Error} If CSV fetch or parsing fails\n */\nconst fetchPatientCsvData = async (patientId) => {\n  try {\n    // Add cache busting to ensure fresh data\n    const response = await fetch(`/synthetic_patients/${patientId}.csv?v=${Date.now()}`);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\n    }\n    \n    const csvText = await response.text();\n    \n    if (!csvText || csvText.trim().length === 0) {\n      throw new Error(`Empty CSV file for patient ${patientId}`);\n    }\n    \n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    \n    if (parsed.errors.length > 0) {\n      // Log parsing errors for debugging but don't throw\n      console.error(`CSV parsing errors for ${patientId}:`, parsed.errors);\n    }\n    \n    return parsed.data;\n  } catch (error) {\n    console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Service class for handling patient data operations\n * Provides methods for fetching and processing patient health data from CSV files\n */\nclass DataService {\n  /**\n   * Retrieves and processes all data for a specific patient\n   * \n   * @param {string} patientId - The patient identifier\n   * @returns {Promise<Object>} Processed patient data including all health metrics\n   * @throws {Error} If patient data cannot be retrieved or processed\n   */\n  static async getPatientData(patientId) {\n    if (!patientId) {\n      throw new Error('Patient ID is required');\n    }\n\n    try {\n      const patientRows = await fetchPatientCsvData(patientId);\n\n      if (!Array.isArray(patientRows) || patientRows.length === 0) {\n        throw new Error(`No data found for patient ${patientId}`);\n      }\n\n      return this.processPatientData(patientRows, patientId);\n    } catch (error) {\n      console.error(`Error fetching patient data for ${patientId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Processes raw CSV data into structured patient information and health metrics\n   * \n   * @param {Array} rows - Raw CSV data rows\n   * @param {string} patientId - The patient identifier\n   * @returns {Object} Structured patient data object\n   * @throws {Error} If data structure is invalid or processing fails\n   */\n  static processPatientData(rows, patientId) {\n    if (!Array.isArray(rows) || rows.length === 0) {\n      throw new Error(`Invalid data structure for patient ${patientId}`);\n    }\n\n    const firstRowData = rows[0];\n    if (!firstRowData) {\n      throw new Error(`No valid data rows found for patient ${patientId}`);\n    }\n\n    const patientInfo = {\n      patientId,\n      patientNumber: patientId,\n      name: firstRowData['Name'] || 'Not specified',\n      age: firstRowData['Age'] || 'Not specified',\n      gender: firstRowData['Gender'] || 'Not specified',\n      dataAvailable: 'May 2025'\n    };\n\n    // Process medications using the cleaner individual medication fields\n    const detailedMedications = [];\n    \n    // Get medication data from the first row (should be consistent across all rows for a patient)\n    const medicationNamesStr = firstRowData['Medication_Names'] || '';\n    const medicationTypesStr = firstRowData['Medication_Types'] || '';\n    const medicationCategoriesStr = firstRowData['Medication_Categories'] || '';\n    const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\n    \n    // Split the semicolon-separated strings into arrays\n    const medicationNames = medicationNamesStr ? medicationNamesStr.split('; ').filter(Boolean) : [];\n    const medicationTypes = medicationTypesStr ? medicationTypesStr.split('; ').filter(Boolean) : [];\n    const medicationCategories = medicationCategoriesStr ? medicationCategoriesStr.split('; ').filter(Boolean) : [];\n    const medicationDosages = medicationDosagesStr ? medicationDosagesStr.split('; ').filter(Boolean) : [];\n    \n    // Process each medication\n    for (let i = 0; i < Math.max(medicationNames.length, medicationTypes.length, medicationCategories.length, medicationDosages.length); i++) {\n        const name = medicationNames[i] || '';\n        const type = medicationTypes[i] || '';\n        const category = medicationCategories[i] || '';\n        const dosage = medicationDosages[i] || '';\n        \n        if (name && name.trim() && \n            !name.includes('Dose not specified') && \n            name.length < 100 && // Filter out extremely long medication names\n            !name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) {\n            detailedMedications.push({\n                name: name.trim(),\n                schedule: dosage.trim(), // Use dosage as schedule\n                category: '', // Don't include category in visualization\n                dosage: ''\n            });\n        }\n    }\n\n    // Process conditions\n    const conditionsSet = new Set();\n    const conditionsRaw = [...new Set(rows.map(row => row['Chronic_Conditions'] || row['Conditions']).filter(Boolean))];\n    conditionsRaw.forEach(conditionString => {\n        conditionString.split(',').forEach(c => conditionsSet.add(c.trim()));\n    });\n\n    // Process all data types\n    const glucoseData = this.processGlucoseData(rows);\n    const bloodPressureData = this.processBloodPressureData(rows);\n    const exerciseData = this.processExerciseData(rows);\n    const moodData = this.processMoodData(rows);\n    const painData = this.processPainData(rows);\n    const sleepData = this.processSleepData(rows);\n    const mealData = this.processMealData(rows);\n\n    return {\n      patientInfo: { \n        ...patientInfo, \n        detailedMedications, \n        conditions: Array.from(conditionsSet)\n      },\n      glucoseData,\n      bloodPressureData,\n      exerciseData,\n      moodData,\n      painData,\n      mealData,\n      sleepData,\n      rawData: rows\n    };\n  }\n\n  /**\n   * Processes blood glucose data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed glucose data with timestamps and ranges\n   */\n  static processGlucoseData(rows) {\n    return rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const readings = [];\n      \n      const hasMultiColumn = row['Glucose_1'] !== undefined;\n      \n      if (hasMultiColumn) {\n        for (let i = 1; i <= 4; i++) {\n          const value = parseFloat(row[`Glucose_${i}`]);\n          const timeStr = row[`Glucose_Time_${i}`];\n          if (value > 0 && timeStr) {\n            const [hours, minutes] = timeStr.split(':').map(Number);\n            const date = new Date(baseDate);\n            date.setHours(hours, minutes);\n            readings.push({\n              date,\n              value,\n              range: row[`Glucose_Range_${i}`],\n              measurementType: row[`Glucose_Measurement_Type_${i}`]\n            });\n          }\n        }\n      } else {\n        const value = parseFloat(row['Glucose_Level']);\n        if (value > 0) {\n          const randomHour = Math.floor(Math.random() * 24);\n          const randomMinute = Math.floor(Math.random() * 60);\n          const date = new Date(baseDate);\n          date.setHours(randomHour, randomMinute);\n          \n          let range = 'in range';\n          if (value < 70) range = 'below range';\n          else if (value > 180) range = 'above range';\n          \n          readings.push({\n            date,\n            value,\n            range,\n            measurementType: 'Random'\n          });\n        }\n      }\n      \n      return readings;\n    });\n  }\n\n  /**\n   * Processes blood pressure data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed blood pressure data with systolic/diastolic values\n   */\n  static processBloodPressureData(rows) {\n    return rows.flatMap(row => {\n        const baseDate = new Date(row['Date']);\n        const readings = [];\n        \n        const hasMultiColumn = row['Systolic_1'] !== undefined;\n        \n        if (hasMultiColumn) {\n            for (let i = 1; i <= 4; i++) {\n                const systolic = parseInt(row[`Systolic_${i}`]);\n                const diastolic = parseInt(row[`Diastolic_${i}`]);\n                const timeStr = row[`BP_Time_${i}`];\n                if (systolic > 0 && diastolic > 0 && timeStr) {\n                    const [hours, minutes] = timeStr.split(':').map(Number);\n                    const date = new Date(baseDate);\n                    date.setHours(hours, minutes);\n                    readings.push({ \n                        date, \n                        systolic, \n                        diastolic, \n                        systolicType: row[`Systolic_Type_${i}`],\n                        diastolicType: row[`Diastolic_Type_${i}`]\n                    });\n                }\n            }\n        } else {\n            const systolic = parseInt(row['Systolic_BP']);\n            const diastolic = parseInt(row['Diastolic_BP']);\n            if (systolic > 0 && diastolic > 0) {\n                const randomHour = Math.floor(Math.random() * 24);\n                const randomMinute = Math.floor(Math.random() * 60);\n                const date = new Date(baseDate);\n                date.setHours(randomHour, randomMinute);\n                \n                let systolicType = 'normal';\n                let diastolicType = 'normal';\n                if (systolic >= 180 || diastolic >= 120) {\n                    systolicType = 'hypertensive crisis';\n                    diastolicType = 'hypertensive crisis';\n                } else if (systolic >= 140 || diastolic >= 90) {\n                    systolicType = 'high';\n                    diastolicType = 'high';\n                } else if (systolic >= 130 || diastolic >= 80) {\n                    systolicType = 'elevated';\n                    diastolicType = 'elevated';\n                }\n                \n                readings.push({ \n                    date, \n                    systolic, \n                    diastolic, \n                    systolicType,\n                    diastolicType\n                });\n            }\n        }\n        \n        return readings;\n    });\n  }\n\n  /**\n   * Processes exercise data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed exercise data with activity types and durations\n   */\n  static processExerciseData(rows) {\n    const exerciseByDate = {};\n    \n    rows.forEach(row => {\n        const date = new Date(row['Date']);\n        const dateKey = date.toDateString();\n        if (!exerciseByDate[dateKey]) {\n            exerciseByDate[dateKey] = { date, walking: 0, swimming: 0, running: 0, 'resistance/weights': 0, biking: 0, 'balance/stretching': 0, other: 0, totalMinutes: 0 };\n        }\n        \n        const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\n        \n        if (hasMultiColumn) {\n            for (let i = 1; i <= 3; i++) {\n                const type = row[`Exercise_Type_${i}`]?.toLowerCase();\n                const minutes = parseFloat(row[`Exercise_Minutes_${i}`]);\n                if (type && minutes > 0) {\n                    this.categorizeExercise(type, minutes, exerciseByDate[dateKey]);\n                }\n            }\n        } else {\n            const type = row['Exercise_Type']?.toLowerCase();\n            const minutes = parseFloat(row['Exercise_Minutes']);\n            if (type && minutes > 0) {\n                this.categorizeExercise(type, minutes, exerciseByDate[dateKey]);\n            }\n        }\n    });\n    \n    return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n  }\n\n  /**\n   * Categorizes exercise activities into predefined types\n   * \n   * @param {string} type - Exercise type from CSV\n   * @param {number} minutes - Duration in minutes\n   * @param {Object} dayData - Daily exercise data object\n   */\n  static categorizeExercise(type, minutes, dayData) {\n    if (type.includes('walking')) dayData.walking += minutes;\n    else if (type.includes('swimming')) dayData.swimming += minutes;\n    else if (type.includes('running')) dayData.running += minutes;\n    else if (type.includes('resistance') || type.includes('weights')) dayData['resistance/weights'] += minutes;\n    else if (type.includes('biking')) dayData.biking += minutes;\n    else if (type.includes('balance') || type.includes('stretching')) dayData['balance/stretching'] += minutes;\n    else dayData.other += minutes;\n    dayData.totalMinutes += minutes;\n  }\n\n  /**\n   * Processes mood data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed mood data with categories\n   */\n  static processMoodData(rows) {\n    return rows.filter(row => row['Mood']).map(row => ({\n        date: new Date(row['Date']),\n        mood: row['Mood'],\n        category: row['Mood'] || 'neutral'\n    }));\n  }\n\n  /**\n   * Processes pain data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed pain data with location and intensity\n   */\n  static processPainData(rows) {\n    return rows.filter(row => row['Pain_Location'] && row['Pain_Level']).map(row => ({\n        date: new Date(row['Date']),\n        location: row['Pain_Location'].toLowerCase(),\n        level: parseInt(row['Pain_Level'])\n    }));\n  }\n\n  /**\n   * Processes sleep data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed sleep data with duration and quality\n   */\n  static processSleepData(rows) {\n    return rows.filter(row => row['Sleep_Hours'] && row['Sleep_Quality']).map(row => ({\n        date: new Date(row['Date']),\n        hours: parseFloat(row['Sleep_Hours']),\n        quality: row['Sleep_Quality'],\n        qualityCode: parseInt(row['Sleep_Quality_Code'])\n    }));\n  }\n\n  /**\n   * Processes meal data from CSV rows\n   * \n   * @param {Array} rows - CSV data rows\n   * @returns {Array} Processed meal data with nutritional components\n   */\n  static processMealData(rows) {\n    // Return the raw rows with meal data since MealContentsChart expects individual meal components\n    const filteredRows = rows.filter(row => {\n      // Check if any meal data exists for this row\n      const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\n      \n      const hasMealData = mealTypes.some(mealType => {\n        const time = row[`${mealType}_Time`];\n        const protein = row[`${mealType}_Protein`];\n        const carbs = row[`${mealType}_Carbohydrates`];\n        const vegetables = row[`${mealType}_Vegetables`];\n        const fruit = row[`${mealType}_Fruit`];\n        const alcohol = row[`${mealType}_Alcohol`];\n        const sugar = row[`${mealType}_Added_Sugar`];\n        \n        // Check if time exists and at least one food component is present\n        // Handle both numeric (1, 0) and string ('1', '0') values\n        const hasFood = protein === 1 || protein === '1' || \n                       carbs === 1 || carbs === '1' || \n                       vegetables === 1 || vegetables === '1' || \n                       fruit === 1 || fruit === '1' || \n                       alcohol === 1 || alcohol === '1' || \n                       (sugar && sugar !== '' && sugar !== 'NaN');\n        \n        return time && hasFood;\n      });\n      \n      return hasMealData;\n    });\n    \n    return filteredRows;\n  }\n}\n\nexport default DataService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}