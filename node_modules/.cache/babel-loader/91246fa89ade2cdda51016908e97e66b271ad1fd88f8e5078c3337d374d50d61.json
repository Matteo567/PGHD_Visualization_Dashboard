{"ast":null,"code":"/*\n dataService.js - Patient Data Service\n \n This service handles all data operations for the health dashboard. It fetches patient CSV data from the server and parses and processes CSV data using PapaParse. It transforms raw data into structured health metrics and provides data validation and error handling. The service manages patient information, medications, and health tracking data. It supports all health metric types including glucose, blood pressure, exercise, mood, pain, sleep, and meals. The service uses the PapaParse library for CSV parsing and implements a service class pattern for data operations. It provides error handling and validation and supports multiple data formats and structures. Data processing includes CSV parsing with header validation, data transformation and normalization, type conversion and validation, and error recovery and fallback mechanisms. The service handles blood glucose monitoring with meal context, blood pressure tracking with risk categorization, exercise activity tracking and categorization, mood assessment and tracking, pain reporting with anatomical mapping, sleep quality and duration analysis, and nutritional intake and meal composition. Error handling includes network error recovery, CSV parsing error handling, data validation and sanitization, and graceful degradation for missing data.\n */\n\nimport Papa from 'papaparse';\n\n// Configuration for CSV parsing\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: header => (header === null || header === void 0 ? void 0 : header.trim()) || '',\n  transform: value => (value === null || value === void 0 ? void 0 : value.trim()) || '',\n  dynamicTyping: false,\n  // Keep everything as strings to avoid parsing issues\n  delimiter: ',',\n  quoteChar: '\"',\n  escapeChar: '\"'\n};\n\n/*\n Fetches and parses CSV data for a specific patient. Returns parsed CSV data as array of objects. Throws error if CSV fetch or parsing fails.\n */\nconst fetchPatientCsvData = async patientId => {\n  try {\n    // Use relative path for both dev and production (works with PUBLIC_URL)\n    const url = `${process.env.PUBLIC_URL}/synthetic_patients/${patientId}.csv?v=${Date.now()}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\n    }\n    const csvText = await response.text();\n    if (!csvText || csvText.trim().length === 0) {\n      throw new Error(`Empty CSV file for patient ${patientId}`);\n    }\n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    if (parsed.errors.length > 0) {\n      // Log parsing errors for debugging but don't throw (only in development)\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`CSV parsing warnings for ${patientId}:`, parsed.errors);\n      }\n    }\n    return parsed.data;\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    }\n    throw error;\n  }\n};\n\n/*\n Service class for handling patient data operations\n Provides methods for fetching and processing patient health data from CSV files\n */\n/*\n| Retrieves and processes all data for a specific patient\n| \n| @param {string} patientId - The patient identifier\n| @returns {Promise<Object>} Processed patient data including all health metrics\n| @throws {Error} If patient data cannot be retrieved or processed\n| */\nexport async function getPatientData(patientId) {\n  if (!patientId) {\n    throw new Error('Patient ID is required');\n  }\n  try {\n    const patientRows = await fetchPatientCsvData(patientId);\n    if (!Array.isArray(patientRows) || patientRows.length === 0) {\n      throw new Error(`No data found for patient ${patientId}`);\n    }\n    return processPatientData(patientRows, patientId);\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching patient data for ${patientId}:`, error);\n    }\n    throw error;\n  }\n}\n\n/**\n Processes raw CSV data into structured patient information and health metrics. Returns structured patient data object. Throws error if data structure is invalid or processing fails.\n */\nfunction processPatientData(rows, patientId) {\n  if (!Array.isArray(rows) || rows.length === 0) {\n    throw new Error(`Invalid data structure for patient ${patientId}`);\n  }\n  const firstRowData = rows[0];\n  if (!firstRowData) {\n    throw new Error(`No valid data rows found for patient ${patientId}`);\n  }\n  const patientInfo = {\n    patientId,\n    patientNumber: patientId,\n    name: firstRowData['Name'] || 'Not specified',\n    age: firstRowData['Age'] || 'Not specified',\n    gender: firstRowData['Gender'] || 'Not specified',\n    dataAvailable: 'May 2025'\n  };\n\n  // Process medications from the first row\n  const detailedMedications = [];\n  const medicationNamesStr = firstRowData['Medication_Names'] || '';\n  const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\n  if (medicationNamesStr && medicationDosagesStr) {\n    const medicationNames = medicationNamesStr.split('; ').filter(Boolean);\n    const medicationDosages = medicationDosagesStr.split('; ').filter(Boolean);\n\n    // Validates if a medication name is valid for processing\n    function isValidMedicationName(name) {\n      if (name.length === 0 || name.length >= 100) return false;\n      if (name.includes('Dose not specified')) return false;\n      if (name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) return false;\n      return true;\n    }\n    medicationNames.forEach((medicationName, index) => {\n      var _medicationDosages$in;\n      const name = medicationName.trim();\n      const dosage = ((_medicationDosages$in = medicationDosages[index]) === null || _medicationDosages$in === void 0 ? void 0 : _medicationDosages$in.trim()) || '';\n      if (isValidMedicationName(name)) {\n        detailedMedications.push({\n          name: name,\n          schedule: dosage,\n          category: '',\n          dosage: ''\n        });\n      }\n    });\n  }\n\n  // Process conditions from all rows\n  const conditionsSet = new Set();\n  rows.forEach(row => {\n    const conditionString = row['Chronic_Conditions'] || row['Conditions'] || '';\n    if (conditionString) {\n      const conditions = conditionString.split(';');\n      conditions.forEach(condition => {\n        const trimmed = condition.trim();\n        if (trimmed) {\n          conditionsSet.add(trimmed);\n        }\n      });\n    }\n  });\n\n  // Process all data types\n  const glucoseData = processGlucoseData(rows);\n  const bloodPressureData = processBloodPressureData(rows);\n  const exerciseData = processExerciseData(rows);\n  const moodData = processMoodData(rows);\n  const painData = processPainData(rows);\n  const sleepData = processSleepData(rows);\n  const mealData = processMealData(rows);\n  return {\n    patientInfo: {\n      ...patientInfo,\n      detailedMedications,\n      conditions: Array.from(conditionsSet)\n    },\n    glucoseData,\n    bloodPressureData,\n    exerciseData,\n    moodData,\n    painData,\n    mealData,\n    sleepData\n  };\n}\n\n// Helper functions for processing glucose data\nfunction parseTimeString(timeStr) {\n  if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {\n    return {\n      hours: 0,\n      minutes: 0\n    };\n  }\n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) {\n    return {\n      hours: 0,\n      minutes: 0\n    };\n  }\n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  return {\n    hours: isNaN(hours) ? 0 : hours,\n    minutes: isNaN(minutes) ? 0 : minutes\n  };\n}\nfunction createGlucoseReading(baseDate, value, timeStr, range, measurementType) {\n  const {\n    hours,\n    minutes\n  } = parseTimeString(timeStr);\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  return {\n    date: date,\n    value: value,\n    range: range,\n    measurementType: measurementType\n  };\n}\nfunction processMultiColumnGlucose(row, baseDate) {\n  const readings = [];\n  for (let i = 1; i <= 4; i++) {\n    const value = parseFloat(row[`Glucose_${i}`]);\n    const timeStr = row[`Glucose_Time_${i}`];\n    if (!isNaN(value) && value > 0 && timeStr && timeStr.trim() !== '') {\n      const reading = createGlucoseReading(baseDate, value, timeStr, row[`Glucose_Range_${i}`], row[`Glucose_Measurement_Type_${i}`]);\n      readings.push(reading);\n    }\n  }\n  return readings;\n}\nfunction processSingleColumnGlucose(row, baseDate) {\n  const value = parseFloat(row['Glucose_Level']);\n  if (!isNaN(value) && value > 0) {\n    const randomHour = Math.floor(Math.random() * 24);\n    const randomMinute = Math.floor(Math.random() * 60);\n    const date = new Date(baseDate);\n    date.setHours(randomHour, randomMinute);\n    let range = 'in range';\n    if (value < 70) range = 'below range';else if (value > 180) range = 'above range';\n    return [{\n      date: date,\n      value: value,\n      range: range,\n      measurementType: 'Random'\n    }];\n  }\n  return [];\n}\n\n/**\n Processes blood glucose data from CSV rows.\n */\nfunction processGlucoseData(rows) {\n  const readings = [];\n  rows.forEach(row => {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Glucose_1'] !== undefined;\n    if (hasMultiColumn) {\n      readings.push(...processMultiColumnGlucose(row, baseDate));\n    } else {\n      readings.push(...processSingleColumnGlucose(row, baseDate));\n    }\n  });\n  return readings;\n}\n\n/**\n Creates a date with time from a base date and time string.\n */\nfunction createDateWithTime(baseDate, timeStr) {\n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) return null;\n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  if (isNaN(hours) || isNaN(minutes)) return null;\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  return date;\n}\n\n/**\n Determines blood pressure type based on systolic and diastolic values.\n */\nfunction getBPType(systolic, diastolic) {\n  if (systolic >= 180 || diastolic >= 120) return 'hypertensive crisis';\n  if (systolic >= 140 || diastolic >= 90) return 'high';\n  if (systolic >= 130 || diastolic >= 80) return 'elevated';\n  return 'normal';\n}\n\n/**\n * Processes a single blood pressure reading from multi-column format.\n */\nfunction processMultiColumnBPReading(row, index, baseDate) {\n  const systolic = parseInt(row[`Systolic_${index}`]);\n  const diastolic = parseInt(row[`Diastolic_${index}`]);\n  const timeStr = row[`BP_Time_${index}`];\n  const isValid = !isNaN(systolic) && !isNaN(diastolic) && systolic > 0 && diastolic > 0 && timeStr && timeStr.trim() !== '';\n  if (!isValid) return null;\n  const date = createDateWithTime(baseDate, timeStr);\n  if (!date) return null;\n  return {\n    date,\n    systolic,\n    diastolic,\n    systolicType: row[`Systolic_Type_${index}`],\n    diastolicType: row[`Diastolic_Type_${index}`]\n  };\n}\n\n/**\n * Processes a single blood pressure reading from single-column format.\n */\nfunction processSingleColumnBPReading(row, baseDate) {\n  const systolic = parseInt(row['Systolic_BP']);\n  const diastolic = parseInt(row['Diastolic_BP']);\n  if (isNaN(systolic) || isNaN(diastolic) || systolic <= 0 || diastolic <= 0) {\n    return null;\n  }\n\n  // Generate random time for single reading format when timestamp is not available\n  const randomHour = Math.floor(Math.random() * 24);\n  const randomMinute = Math.floor(Math.random() * 60);\n  const date = new Date(baseDate);\n  date.setHours(randomHour, randomMinute);\n  const bpType = getBPType(systolic, diastolic);\n  return {\n    date,\n    systolic,\n    diastolic,\n    systolicType: bpType,\n    diastolicType: bpType\n  };\n}\n\n/**\n * Processes blood pressure data from CSV rows.\n */\nfunction processBloodPressureData(rows) {\n  const readings = [];\n  for (const row of rows) {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Systolic_1'] !== undefined;\n    if (hasMultiColumn) {\n      // Process up to 4 readings per day\n      for (let j = 1; j <= 4; j++) {\n        const reading = processMultiColumnBPReading(row, j, baseDate);\n        if (reading) readings.push(reading);\n      }\n    } else {\n      // Single reading format\n      const reading = processSingleColumnBPReading(row, baseDate);\n      if (reading) readings.push(reading);\n    }\n  }\n  return readings;\n}\n\n/**\n * Creates initial exercise data structure for a date.\n */\nfunction createExerciseDayData(date) {\n  return {\n    date,\n    walking: 0,\n    swimming: 0,\n    running: 0,\n    biking: 0,\n    'muscle-strengthening': 0,\n    balance: 0,\n    other: 0,\n    totalMinutes: 0\n  };\n}\n\n/**\n * Processes a single exercise entry.\n */\nfunction processExerciseEntry(row, index, dayData) {\n  var _row$typeKey;\n  const typeKey = index ? `Exercise_Type_${index}` : 'Exercise_Type';\n  const minutesKey = index ? `Exercise_Minutes_${index}` : 'Exercise_Minutes';\n  const type = (_row$typeKey = row[typeKey]) === null || _row$typeKey === void 0 ? void 0 : _row$typeKey.toLowerCase();\n  const minutes = parseFloat(row[minutesKey]);\n  if (type && type.trim() !== '' && !isNaN(minutes) && minutes > 0) {\n    categorizeExercise(type, minutes, dayData);\n  }\n}\n\n/**\n * Processes exercise data from CSV rows. Returns processed exercise data with activity types and durations.\n */\nfunction processExerciseData(rows) {\n  const exerciseByDate = {};\n  for (const row of rows) {\n    const date = new Date(row['Date']);\n    const dateKey = date.toDateString();\n    if (!exerciseByDate[dateKey]) {\n      exerciseByDate[dateKey] = createExerciseDayData(date);\n    }\n    const dayData = exerciseByDate[dateKey];\n    const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\n    if (hasMultiColumn) {\n      // Process up to 5 exercise entries per day\n      for (let j = 1; j <= 5; j++) {\n        processExerciseEntry(row, j, dayData);\n      }\n    } else {\n      // Single exercise entry\n      processExerciseEntry(row, null, dayData);\n    }\n  }\n  return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n}\n\n/**\n * Categorizes exercise activities into predefined types and adds them to the daily exercise data object.\n */\nfunction categorizeExercise(type, minutes, dayData) {\n  if (type.includes('walking')) dayData.walking += minutes;else if (type.includes('swimming')) dayData.swimming += minutes;else if (type.includes('running')) dayData.running += minutes;else if (type.includes('biking')) dayData.biking += minutes;else if (type.includes('muscle-strengthening') || type.includes('muscle strengthening') || type.includes('strength')) dayData['muscle-strengthening'] += minutes;else if (type.includes('balance')) dayData.balance += minutes;else dayData.other += minutes;\n  dayData.totalMinutes += minutes;\n}\n\n/**\n * Processes mood data from CSV rows.\n */\nfunction processMoodData(rows) {\n  const moodData = [];\n  rows.forEach(row => {\n    if (row['Mood'] && row['Mood'].trim() !== '') {\n      moodData.push({\n        date: new Date(row['Date']),\n        mood: row['Mood'],\n        category: row['Mood'] || 'neutral'\n      });\n    }\n  });\n  return moodData;\n}\n\n/**\n * Processes pain data from CSV rows.\n */\nfunction processPainData(rows) {\n  const painData = [];\n  rows.forEach(row => {\n    if (row['Pain_Location'] && row['Pain_Location'].trim() !== '' && row['Pain_Level'] !== undefined) {\n      const painLevel = parseInt(row['Pain_Level']);\n      if (!isNaN(painLevel)) {\n        painData.push({\n          date: new Date(row['Date']),\n          location: row['Pain_Location'].toLowerCase(),\n          level: painLevel\n        });\n      }\n    }\n  });\n  return painData;\n}\n\n/**\n * Processes sleep data from CSV rows.\n */\nfunction processSleepData(rows) {\n  const sleepData = [];\n  rows.forEach(row => {\n    if (row['Sleep_Hours'] && row['Sleep_Quality']) {\n      const hours = parseFloat(row['Sleep_Hours']);\n      const qualityCode = parseInt(row['Sleep_Quality_Code']);\n      if (!isNaN(hours) && !isNaN(qualityCode)) {\n        sleepData.push({\n          date: new Date(row['Date']),\n          hours: hours,\n          quality: row['Sleep_Quality'],\n          qualityCode: qualityCode\n        });\n      }\n    }\n  });\n  return sleepData;\n}\n\n/**\n * Checks if a meal has any food components.\n */\nfunction hasMealComponents(row, mealType) {\n  const components = [row[`${mealType}_Protein`], row[`${mealType}_Carbohydrates`], row[`${mealType}_Vegetables`], row[`${mealType}_Fruit`], row[`${mealType}_Alcohol`], row[`${mealType}_Added_Sugar`]];\n  return components.some(comp => comp === 1 || comp === '1' || comp && comp !== '' && comp !== 'NaN');\n}\n\n/**\n * Checks if a row has any meal data.\n */\nfunction hasAnyMealData(row) {\n  const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\n  return mealTypes.some(mealType => {\n    const time = row[`${mealType}_Time`];\n    return time && hasMealComponents(row, mealType);\n  });\n}\n\n/**\n * Processes meal data from CSV rows and returns rows that have meal data.\n */\nfunction processMealData(rows) {\n  return rows.filter(row => hasAnyMealData(row));\n}","map":{"version":3,"names":["Papa","CSV_CONFIG","header","skipEmptyLines","transformHeader","trim","transform","value","dynamicTyping","delimiter","quoteChar","escapeChar","fetchPatientCsvData","patientId","url","process","env","PUBLIC_URL","Date","now","response","fetch","ok","Error","status","statusText","csvText","text","length","parsed","parse","errors","NODE_ENV","console","warn","data","error","getPatientData","patientRows","Array","isArray","processPatientData","rows","firstRowData","patientInfo","patientNumber","name","age","gender","dataAvailable","detailedMedications","medicationNamesStr","medicationDosagesStr","medicationNames","split","filter","Boolean","medicationDosages","isValidMedicationName","includes","forEach","medicationName","index","_medicationDosages$in","dosage","push","schedule","category","conditionsSet","Set","row","conditionString","conditions","condition","trimmed","add","glucoseData","processGlucoseData","bloodPressureData","processBloodPressureData","exerciseData","processExerciseData","moodData","processMoodData","painData","processPainData","sleepData","processSleepData","mealData","processMealData","from","parseTimeString","timeStr","hours","minutes","timeParts","parseInt","isNaN","createGlucoseReading","baseDate","range","measurementType","date","setHours","processMultiColumnGlucose","readings","i","parseFloat","reading","processSingleColumnGlucose","randomHour","Math","floor","random","randomMinute","hasMultiColumn","undefined","createDateWithTime","getBPType","systolic","diastolic","processMultiColumnBPReading","isValid","systolicType","diastolicType","processSingleColumnBPReading","bpType","j","createExerciseDayData","walking","swimming","running","biking","balance","other","totalMinutes","processExerciseEntry","dayData","_row$typeKey","typeKey","minutesKey","type","toLowerCase","categorizeExercise","exerciseByDate","dateKey","toDateString","Object","values","d","mood","painLevel","location","level","qualityCode","quality","hasMealComponents","mealType","components","some","comp","hasAnyMealData","mealTypes","time"],"sources":["C:/Users/Matteo/Working_Folder/a. MCC Thesis Local Experimental/PGHD_Visualization_Dashboard/src/services/dataService.js"],"sourcesContent":["/*\n dataService.js - Patient Data Service\n \n This service handles all data operations for the health dashboard. It fetches patient CSV data from the server and parses and processes CSV data using PapaParse. It transforms raw data into structured health metrics and provides data validation and error handling. The service manages patient information, medications, and health tracking data. It supports all health metric types including glucose, blood pressure, exercise, mood, pain, sleep, and meals. The service uses the PapaParse library for CSV parsing and implements a service class pattern for data operations. It provides error handling and validation and supports multiple data formats and structures. Data processing includes CSV parsing with header validation, data transformation and normalization, type conversion and validation, and error recovery and fallback mechanisms. The service handles blood glucose monitoring with meal context, blood pressure tracking with risk categorization, exercise activity tracking and categorization, mood assessment and tracking, pain reporting with anatomical mapping, sleep quality and duration analysis, and nutritional intake and meal composition. Error handling includes network error recovery, CSV parsing error handling, data validation and sanitization, and graceful degradation for missing data.\n */\n\nimport Papa from 'papaparse';\n\n// Configuration for CSV parsing\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: (header) => header?.trim() || '',\n  transform: (value) => value?.trim() || '',\n  dynamicTyping: false, // Keep everything as strings to avoid parsing issues\n  delimiter: ',',\n  quoteChar: '\"',\n  escapeChar: '\"'\n};\n\n/*\n Fetches and parses CSV data for a specific patient. Returns parsed CSV data as array of objects. Throws error if CSV fetch or parsing fails.\n */\nconst fetchPatientCsvData = async (patientId) => {\n  try {\n    // Use relative path for both dev and production (works with PUBLIC_URL)\n    const url = `${process.env.PUBLIC_URL}/synthetic_patients/${patientId}.csv?v=${Date.now()}`;\n    const response = await fetch(url);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\n    }\n    \n    const csvText = await response.text();\n    \n    if (!csvText || csvText.trim().length === 0) {\n      throw new Error(`Empty CSV file for patient ${patientId}`);\n    }\n    \n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    \n    if (parsed.errors.length > 0) {\n      // Log parsing errors for debugging but don't throw (only in development)\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`CSV parsing warnings for ${patientId}:`, parsed.errors);\n      }\n    }\n    \n    return parsed.data;\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    }\n    throw error;\n  }\n};\n\n/*\n Service class for handling patient data operations\n Provides methods for fetching and processing patient health data from CSV files\n */\n/*\n| Retrieves and processes all data for a specific patient\n| \n| @param {string} patientId - The patient identifier\n| @returns {Promise<Object>} Processed patient data including all health metrics\n| @throws {Error} If patient data cannot be retrieved or processed\n| */\nexport async function getPatientData(patientId) {\n  if (!patientId) {\n    throw new Error('Patient ID is required');\n  }\n\n  try {\n    const patientRows = await fetchPatientCsvData(patientId);\n\n    if (!Array.isArray(patientRows) || patientRows.length === 0) {\n      throw new Error(`No data found for patient ${patientId}`);\n    }\n\n    return processPatientData(patientRows, patientId);\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching patient data for ${patientId}:`, error);\n    }\n    throw error;\n  }\n}\n\n/**\n Processes raw CSV data into structured patient information and health metrics. Returns structured patient data object. Throws error if data structure is invalid or processing fails.\n */\nfunction processPatientData(rows, patientId) {\n  if (!Array.isArray(rows) || rows.length === 0) {\n    throw new Error(`Invalid data structure for patient ${patientId}`);\n  }\n\n  const firstRowData = rows[0];\n  if (!firstRowData) {\n    throw new Error(`No valid data rows found for patient ${patientId}`);\n  }\n\n  const patientInfo = {\n    patientId,\n    patientNumber: patientId,\n    name: firstRowData['Name'] || 'Not specified',\n    age: firstRowData['Age'] || 'Not specified',\n    gender: firstRowData['Gender'] || 'Not specified',\n    dataAvailable: 'May 2025'\n  };\n\n  // Process medications from the first row\n  const detailedMedications = [];\n  const medicationNamesStr = firstRowData['Medication_Names'] || '';\n  const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\n  \n  if (medicationNamesStr && medicationDosagesStr) {\n    const medicationNames = medicationNamesStr.split('; ').filter(Boolean);\n    const medicationDosages = medicationDosagesStr.split('; ').filter(Boolean);\n    \n    // Validates if a medication name is valid for processing\n    function isValidMedicationName(name) {\n      if (name.length === 0 || name.length >= 100) return false;\n      if (name.includes('Dose not specified')) return false;\n      if (name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) return false;\n      return true;\n    }\n    \n    medicationNames.forEach((medicationName, index) => {\n      const name = medicationName.trim();\n      const dosage = medicationDosages[index]?.trim() || '';\n      \n      if (isValidMedicationName(name)) {\n        detailedMedications.push({\n          name: name,\n          schedule: dosage,\n          category: '',\n          dosage: ''\n        });\n      }\n    });\n  }\n\n  // Process conditions from all rows\n  const conditionsSet = new Set();\n  rows.forEach(row => {\n    const conditionString = row['Chronic_Conditions'] || row['Conditions'] || '';\n    if (conditionString) {\n      const conditions = conditionString.split(';');\n      conditions.forEach(condition => {\n        const trimmed = condition.trim();\n        if (trimmed) {\n          conditionsSet.add(trimmed);\n        }\n      });\n    }\n  });\n\n  // Process all data types\n  const glucoseData = processGlucoseData(rows);\n  const bloodPressureData = processBloodPressureData(rows);\n  const exerciseData = processExerciseData(rows);\n  const moodData = processMoodData(rows);\n  const painData = processPainData(rows);\n  const sleepData = processSleepData(rows);\n  const mealData = processMealData(rows);\n\n  return {\n    patientInfo: { \n      ...patientInfo, \n      detailedMedications, \n      conditions: Array.from(conditionsSet)\n    },\n    glucoseData,\n    bloodPressureData,\n    exerciseData,\n    moodData,\n    painData,\n    mealData,\n    sleepData\n  };\n}\n\n// Helper functions for processing glucose data\nfunction parseTimeString(timeStr) {\n  if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {\n    return { hours: 0, minutes: 0 };\n  }\n  \n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) {\n    return { hours: 0, minutes: 0 };\n  }\n  \n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  \n  return {\n    hours: isNaN(hours) ? 0 : hours,\n    minutes: isNaN(minutes) ? 0 : minutes\n  };\n}\n\nfunction createGlucoseReading(baseDate, value, timeStr, range, measurementType) {\n  const { hours, minutes } = parseTimeString(timeStr);\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  \n  return {\n    date: date,\n    value: value,\n    range: range,\n    measurementType: measurementType\n  };\n}\n\nfunction processMultiColumnGlucose(row, baseDate) {\n  const readings = [];\n  \n  for (let i = 1; i <= 4; i++) {\n    const value = parseFloat(row[`Glucose_${i}`]);\n    const timeStr = row[`Glucose_Time_${i}`];\n    \n    if (!isNaN(value) && value > 0 && timeStr && timeStr.trim() !== '') {\n      const reading = createGlucoseReading(\n        baseDate,\n        value,\n        timeStr,\n        row[`Glucose_Range_${i}`],\n        row[`Glucose_Measurement_Type_${i}`]\n      );\n      readings.push(reading);\n    }\n  }\n  \n  return readings;\n}\n\nfunction processSingleColumnGlucose(row, baseDate) {\n  const value = parseFloat(row['Glucose_Level']);\n  if (!isNaN(value) && value > 0) {\n    const randomHour = Math.floor(Math.random() * 24);\n    const randomMinute = Math.floor(Math.random() * 60);\n    const date = new Date(baseDate);\n    date.setHours(randomHour, randomMinute);\n    \n    let range = 'in range';\n    if (value < 70) range = 'below range';\n    else if (value > 180) range = 'above range';\n    \n    return [{\n      date: date,\n      value: value,\n      range: range,\n      measurementType: 'Random'\n    }];\n  }\n  return [];\n}\n\n/**\n Processes blood glucose data from CSV rows.\n */\nfunction processGlucoseData(rows) {\n  const readings = [];\n  \n  rows.forEach(row => {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Glucose_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      readings.push(...processMultiColumnGlucose(row, baseDate));\n    } else {\n      readings.push(...processSingleColumnGlucose(row, baseDate));\n    }\n  });\n  \n  return readings;\n}\n\n/**\n Creates a date with time from a base date and time string.\n */\nfunction createDateWithTime(baseDate, timeStr) {\n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) return null;\n  \n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  \n  if (isNaN(hours) || isNaN(minutes)) return null;\n  \n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  return date;\n}\n\n/**\n Determines blood pressure type based on systolic and diastolic values.\n */\nfunction getBPType(systolic, diastolic) {\n  if (systolic >= 180 || diastolic >= 120) return 'hypertensive crisis';\n  if (systolic >= 140 || diastolic >= 90) return 'high';\n  if (systolic >= 130 || diastolic >= 80) return 'elevated';\n  return 'normal';\n}\n\n/**\n * Processes a single blood pressure reading from multi-column format.\n */\nfunction processMultiColumnBPReading(row, index, baseDate) {\n  const systolic = parseInt(row[`Systolic_${index}`]);\n  const diastolic = parseInt(row[`Diastolic_${index}`]);\n  const timeStr = row[`BP_Time_${index}`];\n  \n  const isValid = !isNaN(systolic) && !isNaN(diastolic) && \n                  systolic > 0 && diastolic > 0 && \n                  timeStr && timeStr.trim() !== '';\n  \n  if (!isValid) return null;\n  \n  const date = createDateWithTime(baseDate, timeStr);\n  if (!date) return null;\n  \n  return {\n    date,\n    systolic,\n    diastolic,\n    systolicType: row[`Systolic_Type_${index}`],\n    diastolicType: row[`Diastolic_Type_${index}`]\n  };\n}\n\n/**\n * Processes a single blood pressure reading from single-column format.\n */\nfunction processSingleColumnBPReading(row, baseDate) {\n  const systolic = parseInt(row['Systolic_BP']);\n  const diastolic = parseInt(row['Diastolic_BP']);\n  \n  if (isNaN(systolic) || isNaN(diastolic) || systolic <= 0 || diastolic <= 0) {\n    return null;\n  }\n  \n  // Generate random time for single reading format when timestamp is not available\n  const randomHour = Math.floor(Math.random() * 24);\n  const randomMinute = Math.floor(Math.random() * 60);\n  const date = new Date(baseDate);\n  date.setHours(randomHour, randomMinute);\n  \n  const bpType = getBPType(systolic, diastolic);\n  \n  return {\n    date,\n    systolic,\n    diastolic,\n    systolicType: bpType,\n    diastolicType: bpType\n  };\n}\n\n/**\n * Processes blood pressure data from CSV rows.\n */\nfunction processBloodPressureData(rows) {\n  const readings = [];\n  \n  for (const row of rows) {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Systolic_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      // Process up to 4 readings per day\n      for (let j = 1; j <= 4; j++) {\n        const reading = processMultiColumnBPReading(row, j, baseDate);\n        if (reading) readings.push(reading);\n      }\n    } else {\n      // Single reading format\n      const reading = processSingleColumnBPReading(row, baseDate);\n      if (reading) readings.push(reading);\n    }\n  }\n  \n  return readings;\n}\n\n/**\n * Creates initial exercise data structure for a date.\n */\nfunction createExerciseDayData(date) {\n  return {\n    date,\n    walking: 0,\n    swimming: 0,\n    running: 0,\n    biking: 0,\n    'muscle-strengthening': 0,\n    balance: 0,\n    other: 0,\n    totalMinutes: 0\n  };\n}\n\n/**\n * Processes a single exercise entry.\n */\nfunction processExerciseEntry(row, index, dayData) {\n  const typeKey = index ? `Exercise_Type_${index}` : 'Exercise_Type';\n  const minutesKey = index ? `Exercise_Minutes_${index}` : 'Exercise_Minutes';\n  \n  const type = row[typeKey]?.toLowerCase();\n  const minutes = parseFloat(row[minutesKey]);\n  \n  if (type && type.trim() !== '' && !isNaN(minutes) && minutes > 0) {\n    categorizeExercise(type, minutes, dayData);\n  }\n}\n\n/**\n * Processes exercise data from CSV rows. Returns processed exercise data with activity types and durations.\n */\nfunction processExerciseData(rows) {\n  const exerciseByDate = {};\n  \n  for (const row of rows) {\n    const date = new Date(row['Date']);\n    const dateKey = date.toDateString();\n    \n    if (!exerciseByDate[dateKey]) {\n      exerciseByDate[dateKey] = createExerciseDayData(date);\n    }\n    \n    const dayData = exerciseByDate[dateKey];\n    const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      // Process up to 5 exercise entries per day\n      for (let j = 1; j <= 5; j++) {\n        processExerciseEntry(row, j, dayData);\n      }\n    } else {\n      // Single exercise entry\n      processExerciseEntry(row, null, dayData);\n    }\n  }\n  \n  return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n}\n\n/**\n * Categorizes exercise activities into predefined types and adds them to the daily exercise data object.\n */\nfunction categorizeExercise(type, minutes, dayData) {\n  if (type.includes('walking')) dayData.walking += minutes;\n    else if (type.includes('swimming')) dayData.swimming += minutes;\n    else if (type.includes('running')) dayData.running += minutes;\n    else if (type.includes('biking')) dayData.biking += minutes;\n    else if (type.includes('muscle-strengthening') || type.includes('muscle strengthening') || type.includes('strength')) dayData['muscle-strengthening'] += minutes;\n    else if (type.includes('balance')) dayData.balance += minutes;\n  else dayData.other += minutes;\n  dayData.totalMinutes += minutes;\n}\n\n/**\n * Processes mood data from CSV rows.\n */\nfunction processMoodData(rows) {\n  const moodData = [];\n    \n  rows.forEach(row => {\n    if (row['Mood'] && row['Mood'].trim() !== '') {\n      moodData.push({\n        date: new Date(row['Date']),\n        mood: row['Mood'],\n        category: row['Mood'] || 'neutral'\n      });\n    }\n  });\n  \n  return moodData;\n}\n\n/**\n * Processes pain data from CSV rows.\n */\nfunction processPainData(rows) {\n  const painData = [];\n    \n  rows.forEach(row => {\n    if (row['Pain_Location'] && row['Pain_Location'].trim() !== '' && row['Pain_Level'] !== undefined) {\n      const painLevel = parseInt(row['Pain_Level']);\n      if (!isNaN(painLevel)) {\n        painData.push({\n          date: new Date(row['Date']),\n          location: row['Pain_Location'].toLowerCase(),\n          level: painLevel\n        });\n      }\n    }\n  });\n  \n  return painData;\n}\n\n/**\n * Processes sleep data from CSV rows.\n */\nfunction processSleepData(rows) {\n  const sleepData = [];\n    \n  rows.forEach(row => {\n    if (row['Sleep_Hours'] && row['Sleep_Quality']) {\n      const hours = parseFloat(row['Sleep_Hours']);\n      const qualityCode = parseInt(row['Sleep_Quality_Code']);\n      if (!isNaN(hours) && !isNaN(qualityCode)) {\n        sleepData.push({\n          date: new Date(row['Date']),\n          hours: hours,\n          quality: row['Sleep_Quality'],\n          qualityCode: qualityCode\n        });\n      }\n    }\n  });\n  \n  return sleepData;\n}\n\n/**\n * Checks if a meal has any food components.\n */\nfunction hasMealComponents(row, mealType) {\n  const components = [\n    row[`${mealType}_Protein`],\n    row[`${mealType}_Carbohydrates`],\n    row[`${mealType}_Vegetables`],\n    row[`${mealType}_Fruit`],\n    row[`${mealType}_Alcohol`],\n    row[`${mealType}_Added_Sugar`]\n  ];\n  \n  return components.some(comp => \n    comp === 1 || comp === '1' || (comp && comp !== '' && comp !== 'NaN')\n  );\n}\n\n/**\n * Checks if a row has any meal data.\n */\nfunction hasAnyMealData(row) {\n  const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\n  \n  return mealTypes.some(mealType => {\n    const time = row[`${mealType}_Time`];\n    return time && hasMealComponents(row, mealType);\n  });\n}\n\n/**\n * Processes meal data from CSV rows and returns rows that have meal data.\n */\nfunction processMealData(rows) {\n  return rows.filter(row => hasAnyMealData(row));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}