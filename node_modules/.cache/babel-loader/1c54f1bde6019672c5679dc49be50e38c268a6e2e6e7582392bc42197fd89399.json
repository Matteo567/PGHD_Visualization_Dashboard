{"ast":null,"code":"/*\n dataService.js - Patient Data Service\n \n This service handles all data operations for the health dashboard:\n - Fetches patient CSV data from the server\n - Parses and processes CSV data using PapaParse\n - Transforms raw data into structured health metrics\n - Provides data validation and error handling\n - Manages patient information, medications, and health tracking data\n - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\n \n Architecture:\n - Uses PapaParse library for CSV parsing\n - Implements service class pattern for data operations\n - Provides comprehensive error handling and validation\n - Supports multiple data formats and structures\n \n Data Processing:\n - CSV parsing with header validation\n - Data transformation and normalization\n - Type conversion and validation\n - Error recovery and fallback mechanisms\n \n Health Metrics Supported:\n - Blood glucose monitoring with meal context\n - Blood pressure tracking with risk categorization\n - Exercise activity tracking and categorization\n - Mood assessment and tracking\n - Pain reporting with anatomical mapping\n - Sleep quality and duration analysis\n - Nutritional intake and meal composition\n \n Error Handling:\n - Network error recovery\n - CSV parsing error handling\n - Data validation and sanitization\n - Graceful degradation for missing data\n \n Core service for data management and processing throughout the application.\n */\n\nimport Papa from 'papaparse';\n\n// Configuration for CSV parsing\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: header => (header === null || header === void 0 ? void 0 : header.trim()) || '',\n  transform: value => (value === null || value === void 0 ? void 0 : value.trim()) || '',\n  dynamicTyping: false,\n  // Keep everything as strings to avoid parsing issues\n  delimiter: ',',\n  quoteChar: '\"',\n  escapeChar: '\"'\n};\n\n/*\n Fetches and parses CSV data for a specific patient\n \n - @param {string} patientId - The patient identifier\n - @returns {Promise<Array>} Parsed CSV data as array of objects\n - @throws {Error} If CSV fetch or parsing fails\n */\nconst fetchPatientCsvData = async patientId => {\n  try {\n    // Use relative path for both dev and production (works with PUBLIC_URL)\n    const url = `${process.env.PUBLIC_URL}/synthetic_patients/${patientId}.csv?v=${Date.now()}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\n    }\n    const csvText = await response.text();\n    if (!csvText || csvText.trim().length === 0) {\n      throw new Error(`Empty CSV file for patient ${patientId}`);\n    }\n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    if (parsed.errors.length > 0) {\n      // Log parsing errors for debugging but don't throw (only in development)\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`CSV parsing warnings for ${patientId}:`, parsed.errors);\n      }\n    }\n    return parsed.data;\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    }\n    throw error;\n  }\n};\n\n/*\n Service class for handling patient data operations\n Provides methods for fetching and processing patient health data from CSV files\n */\n/*\n| Retrieves and processes all data for a specific patient\n| \n| @param {string} patientId - The patient identifier\n| @returns {Promise<Object>} Processed patient data including all health metrics\n| @throws {Error} If patient data cannot be retrieved or processed\n| */\nexport async function getPatientData(patientId) {\n  if (!patientId) {\n    throw new Error('Patient ID is required');\n  }\n  try {\n    const patientRows = await fetchPatientCsvData(patientId);\n    if (!Array.isArray(patientRows) || patientRows.length === 0) {\n      throw new Error(`No data found for patient ${patientId}`);\n    }\n    return processPatientData(patientRows, patientId);\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching patient data for ${patientId}:`, error);\n    }\n    throw error;\n  }\n}\n\n/**\n * Processes raw CSV data into structured patient information and health metrics\n * \n * - @param {Array} rows - Raw CSV data rows\n * - @param {string} patientId - The patient identifier\n * - @returns {Object} Structured patient data object\n * - @throws {Error} If data structure is invalid or processing fails\n */\nexport function processPatientData(rows, patientId) {\n  if (!Array.isArray(rows) || rows.length === 0) {\n    throw new Error(`Invalid data structure for patient ${patientId}`);\n  }\n  const firstRowData = rows[0];\n  if (!firstRowData) {\n    throw new Error(`No valid data rows found for patient ${patientId}`);\n  }\n  const patientInfo = {\n    patientId,\n    patientNumber: patientId,\n    name: firstRowData['Name'] || 'Not specified',\n    age: firstRowData['Age'] || 'Not specified',\n    gender: firstRowData['Gender'] || 'Not specified',\n    dataAvailable: 'May 2025'\n  };\n\n  // Process medications from the first row\n  const detailedMedications = [];\n  const medicationNamesStr = firstRowData['Medication_Names'] || '';\n  const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\n  if (medicationNamesStr && medicationDosagesStr) {\n    const medicationNames = medicationNamesStr.split('; ').filter(Boolean);\n    const medicationDosages = medicationDosagesStr.split('; ').filter(Boolean);\n    for (let i = 0; i < medicationNames.length; i++) {\n      var _medicationNames$i, _medicationDosages$i;\n      const name = ((_medicationNames$i = medicationNames[i]) === null || _medicationNames$i === void 0 ? void 0 : _medicationNames$i.trim()) || '';\n      const dosage = ((_medicationDosages$i = medicationDosages[i]) === null || _medicationDosages$i === void 0 ? void 0 : _medicationDosages$i.trim()) || '';\n\n      // Only add valid medication names\n      if (name && name.length < 100 && !name.includes('Dose not specified') && !name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) {\n        detailedMedications.push({\n          name: name,\n          schedule: dosage,\n          category: '',\n          dosage: ''\n        });\n      }\n    }\n  }\n\n  // Process conditions from all rows\n  const conditionsSet = new Set();\n  for (let i = 0; i < rows.length; i++) {\n    const conditionString = rows[i]['Chronic_Conditions'] || rows[i]['Conditions'] || '';\n    if (conditionString) {\n      const conditionList = conditionString.split(';');\n      for (let j = 0; j < conditionList.length; j++) {\n        const condition = conditionList[j].trim();\n        if (condition) {\n          conditionsSet.add(condition);\n        }\n      }\n    }\n  }\n\n  // Process all data types\n  const glucoseData = processGlucoseData(rows);\n  const bloodPressureData = processBloodPressureData(rows);\n  const exerciseData = processExerciseData(rows);\n  const moodData = processMoodData(rows);\n  const painData = processPainData(rows);\n  const sleepData = processSleepData(rows);\n  const mealData = processMealData(rows);\n  return {\n    patientInfo: {\n      ...patientInfo,\n      detailedMedications,\n      conditions: Array.from(conditionsSet)\n    },\n    glucoseData,\n    bloodPressureData,\n    exerciseData,\n    moodData,\n    painData,\n    mealData,\n    sleepData,\n    rawData: rows\n  };\n}\n\n// Helper functions for glucose data processing\nfunction parseTimeString(timeStr) {\n  if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {\n    return {\n      hours: 0,\n      minutes: 0\n    };\n  }\n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) {\n    return {\n      hours: 0,\n      minutes: 0\n    };\n  }\n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  return {\n    hours: isNaN(hours) ? 0 : hours,\n    minutes: isNaN(minutes) ? 0 : minutes\n  };\n}\nfunction createGlucoseReading(baseDate, value, timeStr, range, measurementType) {\n  const {\n    hours,\n    minutes\n  } = parseTimeString(timeStr);\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  return {\n    date: date,\n    value: value,\n    range: range,\n    measurementType: measurementType\n  };\n}\nfunction processMultiColumnGlucose(row, baseDate) {\n  const readings = [];\n  for (let i = 1; i <= 4; i++) {\n    const value = parseFloat(row[`Glucose_${i}`]);\n    const timeStr = row[`Glucose_Time_${i}`];\n    if (!isNaN(value) && value > 0 && timeStr && timeStr.trim() !== '') {\n      const reading = createGlucoseReading(baseDate, value, timeStr, row[`Glucose_Range_${i}`], row[`Glucose_Measurement_Type_${i}`]);\n      readings.push(reading);\n    }\n  }\n  return readings;\n}\nfunction processSingleColumnGlucose(row, baseDate) {\n  const value = parseFloat(row['Glucose_Level']);\n  if (!isNaN(value) && value > 0) {\n    const randomHour = Math.floor(Math.random() * 24);\n    const randomMinute = Math.floor(Math.random() * 60);\n    const date = new Date(baseDate);\n    date.setHours(randomHour, randomMinute);\n    let range = 'in range';\n    if (value < 70) range = 'below range';else if (value > 180) range = 'above range';\n    return [{\n      date: date,\n      value: value,\n      range: range,\n      measurementType: 'Random'\n    }];\n  }\n  return [];\n}\n\n/**\n * Processes blood glucose data from CSV rows\n */\nexport function processGlucoseData(rows) {\n  const readings = [];\n  rows.forEach(row => {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Glucose_1'] !== undefined;\n    if (hasMultiColumn) {\n      readings.push(...processMultiColumnGlucose(row, baseDate));\n    } else {\n      readings.push(...processSingleColumnGlucose(row, baseDate));\n    }\n  });\n  return readings;\n}\n\n/**\n * Processes blood pressure data from CSV rows\n */\nexport function processBloodPressureData(rows) {\n  const readings = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Systolic_1'] !== undefined;\n    if (hasMultiColumn) {\n      // Process up to 4 readings per day\n      for (let j = 1; j <= 4; j++) {\n        const systolic = parseInt(row[`Systolic_${j}`]);\n        const diastolic = parseInt(row[`Diastolic_${j}`]);\n        const timeStr = row[`BP_Time_${j}`];\n        if (!isNaN(systolic) && !isNaN(diastolic) && systolic > 0 && diastolic > 0 && timeStr && timeStr.trim() !== '') {\n          const timeParts = timeStr.split(':');\n          if (timeParts.length >= 2) {\n            const hours = parseInt(timeParts[0], 10);\n            const minutes = parseInt(timeParts[1], 10);\n            if (!isNaN(hours) && !isNaN(minutes)) {\n              const date = new Date(baseDate);\n              date.setHours(hours, minutes);\n              readings.push({\n                date: date,\n                systolic: systolic,\n                diastolic: diastolic,\n                systolicType: row[`Systolic_Type_${j}`],\n                diastolicType: row[`Diastolic_Type_${j}`]\n              });\n            }\n          }\n        }\n      }\n    } else {\n      // Single reading format\n      const systolic = parseInt(row['Systolic_BP']);\n      const diastolic = parseInt(row['Diastolic_BP']);\n      if (!isNaN(systolic) && !isNaN(diastolic) && systolic > 0 && diastolic > 0) {\n        const randomHour = Math.floor(Math.random() * 24);\n        const randomMinute = Math.floor(Math.random() * 60);\n        const date = new Date(baseDate);\n        date.setHours(randomHour, randomMinute);\n        let systolicType = 'normal';\n        let diastolicType = 'normal';\n        if (systolic >= 180 || diastolic >= 120) {\n          systolicType = 'hypertensive crisis';\n          diastolicType = 'hypertensive crisis';\n        } else if (systolic >= 140 || diastolic >= 90) {\n          systolicType = 'high';\n          diastolicType = 'high';\n        } else if (systolic >= 130 || diastolic >= 80) {\n          systolicType = 'elevated';\n          diastolicType = 'elevated';\n        }\n        readings.push({\n          date: date,\n          systolic: systolic,\n          diastolic: diastolic,\n          systolicType: systolicType,\n          diastolicType: diastolicType\n        });\n      }\n    }\n  }\n  return readings;\n}\n\n/**\n * Processes exercise data from CSV rows\n * \n * - @param {Array} rows - CSV data rows\n * - @returns {Array} Processed exercise data with activity types and durations\n */\nexport function processExerciseData(rows) {\n  const exerciseByDate = {};\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    const date = new Date(row['Date']);\n    const dateKey = date.toDateString();\n    if (!exerciseByDate[dateKey]) {\n      exerciseByDate[dateKey] = {\n        date,\n        walking: 0,\n        swimming: 0,\n        running: 0,\n        biking: 0,\n        'muscle-strengthening': 0,\n        balance: 0,\n        other: 0,\n        totalMinutes: 0\n      };\n    }\n    const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\n    if (hasMultiColumn) {\n      for (let j = 1; j <= 5; j++) {\n        var _row;\n        const type = (_row = row[`Exercise_Type_${j}`]) === null || _row === void 0 ? void 0 : _row.toLowerCase();\n        const minutes = parseFloat(row[`Exercise_Minutes_${j}`]);\n        if (type && type.trim() !== '' && !isNaN(minutes) && minutes > 0) {\n          categorizeExercise(type, minutes, exerciseByDate[dateKey]);\n        }\n      }\n    } else {\n      var _row$Exercise_Type;\n      const type = (_row$Exercise_Type = row['Exercise_Type']) === null || _row$Exercise_Type === void 0 ? void 0 : _row$Exercise_Type.toLowerCase();\n      const minutes = parseFloat(row['Exercise_Minutes']);\n      if (type && type.trim() !== '' && !isNaN(minutes) && minutes > 0) {\n        categorizeExercise(type, minutes, exerciseByDate[dateKey]);\n      }\n    }\n  }\n  return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n}\n\n/**\n * Categorizes exercise activities into predefined types\n * \n * - @param {string} type - Exercise type from CSV\n * - @param {number} minutes - Duration in minutes\n * - @param {Object} dayData - Daily exercise data object\n */\nexport function categorizeExercise(type, minutes, dayData) {\n  if (type.includes('walking')) dayData.walking += minutes;else if (type.includes('swimming')) dayData.swimming += minutes;else if (type.includes('running')) dayData.running += minutes;else if (type.includes('biking')) dayData.biking += minutes;else if (type.includes('muscle-strengthening') || type.includes('muscle strengthening') || type.includes('strength')) dayData['muscle-strengthening'] += minutes;else if (type.includes('balance')) dayData.balance += minutes;else dayData.other += minutes;\n  dayData.totalMinutes += minutes;\n}\n\n/**\n * Processes mood data from CSV rows\n */\nexport function processMoodData(rows) {\n  const moodData = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    if (row['Mood'] && row['Mood'].trim() !== '') {\n      moodData.push({\n        date: new Date(row['Date']),\n        mood: row['Mood'],\n        category: row['Mood'] || 'neutral'\n      });\n    }\n  }\n  return moodData;\n}\n\n/**\n * Processes pain data from CSV rows\n */\nexport function processPainData(rows) {\n  const painData = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    if (row['Pain_Location'] && row['Pain_Location'].trim() !== '' && row['Pain_Level'] !== undefined) {\n      const painLevel = parseInt(row['Pain_Level']);\n      if (!isNaN(painLevel)) {\n        painData.push({\n          date: new Date(row['Date']),\n          location: row['Pain_Location'].toLowerCase(),\n          level: painLevel\n        });\n      }\n    }\n  }\n  return painData;\n}\n\n/**\n * Processes sleep data from CSV rows\n */\nexport function processSleepData(rows) {\n  const sleepData = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    if (row['Sleep_Hours'] && row['Sleep_Quality']) {\n      const hours = parseFloat(row['Sleep_Hours']);\n      const qualityCode = parseInt(row['Sleep_Quality_Code']);\n      if (!isNaN(hours) && !isNaN(qualityCode)) {\n        sleepData.push({\n          date: new Date(row['Date']),\n          hours: hours,\n          quality: row['Sleep_Quality'],\n          qualityCode: qualityCode\n        });\n      }\n    }\n  }\n  return sleepData;\n}\n\n/**\n * Processes meal data from CSV rows - returns rows that have meal data\n */\nexport function processMealData(rows) {\n  const filteredRows = [];\n  const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    let hasMealData = false;\n\n    // Check each meal type to see if there's any meal data\n    for (let j = 0; j < mealTypes.length; j++) {\n      const mealType = mealTypes[j];\n      const time = row[`${mealType}_Time`];\n      const protein = row[`${mealType}_Protein`];\n      const carbs = row[`${mealType}_Carbohydrates`];\n      const vegetables = row[`${mealType}_Vegetables`];\n      const fruit = row[`${mealType}_Fruit`];\n      const alcohol = row[`${mealType}_Alcohol`];\n      const sugar = row[`${mealType}_Added_Sugar`];\n\n      // Check if time exists and at least one food component is present\n      const hasFood = protein === 1 || protein === '1' || carbs === 1 || carbs === '1' || vegetables === 1 || vegetables === '1' || fruit === 1 || fruit === '1' || alcohol === 1 || alcohol === '1' || sugar && sugar !== '' && sugar !== 'NaN';\n      if (time && hasFood) {\n        hasMealData = true;\n        break;\n      }\n    }\n    if (hasMealData) {\n      filteredRows.push(row);\n    }\n  }\n  return filteredRows;\n}","map":{"version":3,"names":["Papa","CSV_CONFIG","header","skipEmptyLines","transformHeader","trim","transform","value","dynamicTyping","delimiter","quoteChar","escapeChar","fetchPatientCsvData","patientId","url","process","env","PUBLIC_URL","Date","now","response","fetch","ok","Error","status","statusText","csvText","text","length","parsed","parse","errors","NODE_ENV","console","warn","data","error","getPatientData","patientRows","Array","isArray","processPatientData","rows","firstRowData","patientInfo","patientNumber","name","age","gender","dataAvailable","detailedMedications","medicationNamesStr","medicationDosagesStr","medicationNames","split","filter","Boolean","medicationDosages","i","_medicationNames$i","_medicationDosages$i","dosage","includes","push","schedule","category","conditionsSet","Set","conditionString","conditionList","j","condition","add","glucoseData","processGlucoseData","bloodPressureData","processBloodPressureData","exerciseData","processExerciseData","moodData","processMoodData","painData","processPainData","sleepData","processSleepData","mealData","processMealData","conditions","from","rawData","parseTimeString","timeStr","hours","minutes","timeParts","parseInt","isNaN","createGlucoseReading","baseDate","range","measurementType","date","setHours","processMultiColumnGlucose","row","readings","parseFloat","reading","processSingleColumnGlucose","randomHour","Math","floor","random","randomMinute","forEach","hasMultiColumn","undefined","systolic","diastolic","systolicType","diastolicType","exerciseByDate","dateKey","toDateString","walking","swimming","running","biking","balance","other","totalMinutes","_row","type","toLowerCase","categorizeExercise","_row$Exercise_Type","Object","values","d","dayData","mood","painLevel","location","level","qualityCode","quality","filteredRows","mealTypes","hasMealData","mealType","time","protein","carbs","vegetables","fruit","alcohol","sugar","hasFood"],"sources":["C:/Users/Matteo/Working_Folder/a. MCC Thesis Local Experimental/PGHD_Visualization_Dashboard/src/services/dataService.js"],"sourcesContent":["/*\n dataService.js - Patient Data Service\n \n This service handles all data operations for the health dashboard:\n - Fetches patient CSV data from the server\n - Parses and processes CSV data using PapaParse\n - Transforms raw data into structured health metrics\n - Provides data validation and error handling\n - Manages patient information, medications, and health tracking data\n - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\n \n Architecture:\n - Uses PapaParse library for CSV parsing\n - Implements service class pattern for data operations\n - Provides comprehensive error handling and validation\n - Supports multiple data formats and structures\n \n Data Processing:\n - CSV parsing with header validation\n - Data transformation and normalization\n - Type conversion and validation\n - Error recovery and fallback mechanisms\n \n Health Metrics Supported:\n - Blood glucose monitoring with meal context\n - Blood pressure tracking with risk categorization\n - Exercise activity tracking and categorization\n - Mood assessment and tracking\n - Pain reporting with anatomical mapping\n - Sleep quality and duration analysis\n - Nutritional intake and meal composition\n \n Error Handling:\n - Network error recovery\n - CSV parsing error handling\n - Data validation and sanitization\n - Graceful degradation for missing data\n \n Core service for data management and processing throughout the application.\n */\n\nimport Papa from 'papaparse';\n\n// Configuration for CSV parsing\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: (header) => header?.trim() || '',\n  transform: (value) => value?.trim() || '',\n  dynamicTyping: false, // Keep everything as strings to avoid parsing issues\n  delimiter: ',',\n  quoteChar: '\"',\n  escapeChar: '\"'\n};\n\n/*\n Fetches and parses CSV data for a specific patient\n \n - @param {string} patientId - The patient identifier\n - @returns {Promise<Array>} Parsed CSV data as array of objects\n - @throws {Error} If CSV fetch or parsing fails\n */\nconst fetchPatientCsvData = async (patientId) => {\n  try {\n    // Use relative path for both dev and production (works with PUBLIC_URL)\n    const url = `${process.env.PUBLIC_URL}/synthetic_patients/${patientId}.csv?v=${Date.now()}`;\n    const response = await fetch(url);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\n    }\n    \n    const csvText = await response.text();\n    \n    if (!csvText || csvText.trim().length === 0) {\n      throw new Error(`Empty CSV file for patient ${patientId}`);\n    }\n    \n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    \n    if (parsed.errors.length > 0) {\n      // Log parsing errors for debugging but don't throw (only in development)\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`CSV parsing warnings for ${patientId}:`, parsed.errors);\n      }\n    }\n    \n    return parsed.data;\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    }\n    throw error;\n  }\n};\n\n/*\n Service class for handling patient data operations\n Provides methods for fetching and processing patient health data from CSV files\n */\n/*\n| Retrieves and processes all data for a specific patient\n| \n| @param {string} patientId - The patient identifier\n| @returns {Promise<Object>} Processed patient data including all health metrics\n| @throws {Error} If patient data cannot be retrieved or processed\n| */\nexport async function getPatientData(patientId) {\n  if (!patientId) {\n    throw new Error('Patient ID is required');\n  }\n\n  try {\n    const patientRows = await fetchPatientCsvData(patientId);\n\n    if (!Array.isArray(patientRows) || patientRows.length === 0) {\n      throw new Error(`No data found for patient ${patientId}`);\n    }\n\n    return processPatientData(patientRows, patientId);\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching patient data for ${patientId}:`, error);\n    }\n    throw error;\n  }\n}\n\n/**\n * Processes raw CSV data into structured patient information and health metrics\n * \n * - @param {Array} rows - Raw CSV data rows\n * - @param {string} patientId - The patient identifier\n * - @returns {Object} Structured patient data object\n * - @throws {Error} If data structure is invalid or processing fails\n */\nexport function processPatientData(rows, patientId) {\n  if (!Array.isArray(rows) || rows.length === 0) {\n    throw new Error(`Invalid data structure for patient ${patientId}`);\n  }\n\n  const firstRowData = rows[0];\n  if (!firstRowData) {\n    throw new Error(`No valid data rows found for patient ${patientId}`);\n  }\n\n  const patientInfo = {\n    patientId,\n    patientNumber: patientId,\n    name: firstRowData['Name'] || 'Not specified',\n    age: firstRowData['Age'] || 'Not specified',\n    gender: firstRowData['Gender'] || 'Not specified',\n    dataAvailable: 'May 2025'\n  };\n\n  // Process medications from the first row\n  const detailedMedications = [];\n  const medicationNamesStr = firstRowData['Medication_Names'] || '';\n  const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\n  \n  if (medicationNamesStr && medicationDosagesStr) {\n    const medicationNames = medicationNamesStr.split('; ').filter(Boolean);\n    const medicationDosages = medicationDosagesStr.split('; ').filter(Boolean);\n    \n    for (let i = 0; i < medicationNames.length; i++) {\n      const name = medicationNames[i]?.trim() || '';\n      const dosage = medicationDosages[i]?.trim() || '';\n      \n      // Only add valid medication names\n      if (name && name.length < 100 && \n          !name.includes('Dose not specified') && \n          !name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) {\n        detailedMedications.push({\n          name: name,\n          schedule: dosage,\n          category: '',\n          dosage: ''\n        });\n      }\n    }\n  }\n\n  // Process conditions from all rows\n  const conditionsSet = new Set();\n  for (let i = 0; i < rows.length; i++) {\n    const conditionString = rows[i]['Chronic_Conditions'] || rows[i]['Conditions'] || '';\n    if (conditionString) {\n      const conditionList = conditionString.split(';');\n      for (let j = 0; j < conditionList.length; j++) {\n        const condition = conditionList[j].trim();\n        if (condition) {\n          conditionsSet.add(condition);\n        }\n      }\n    }\n  }\n\n  // Process all data types\n  const glucoseData = processGlucoseData(rows);\n  const bloodPressureData = processBloodPressureData(rows);\n  const exerciseData = processExerciseData(rows);\n  const moodData = processMoodData(rows);\n  const painData = processPainData(rows);\n  const sleepData = processSleepData(rows);\n  const mealData = processMealData(rows);\n\n  return {\n    patientInfo: { \n      ...patientInfo, \n      detailedMedications, \n      conditions: Array.from(conditionsSet)\n    },\n    glucoseData,\n    bloodPressureData,\n    exerciseData,\n    moodData,\n    painData,\n    mealData,\n    sleepData,\n    rawData: rows\n  };\n}\n\n// Helper functions for glucose data processing\nfunction parseTimeString(timeStr) {\n  if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {\n    return { hours: 0, minutes: 0 };\n  }\n  \n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) {\n    return { hours: 0, minutes: 0 };\n  }\n  \n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  \n  return {\n    hours: isNaN(hours) ? 0 : hours,\n    minutes: isNaN(minutes) ? 0 : minutes\n  };\n}\n\nfunction createGlucoseReading(baseDate, value, timeStr, range, measurementType) {\n  const { hours, minutes } = parseTimeString(timeStr);\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  \n  return {\n    date: date,\n    value: value,\n    range: range,\n    measurementType: measurementType\n  };\n}\n\nfunction processMultiColumnGlucose(row, baseDate) {\n  const readings = [];\n  \n  for (let i = 1; i <= 4; i++) {\n    const value = parseFloat(row[`Glucose_${i}`]);\n    const timeStr = row[`Glucose_Time_${i}`];\n    \n    if (!isNaN(value) && value > 0 && timeStr && timeStr.trim() !== '') {\n      const reading = createGlucoseReading(\n        baseDate,\n        value,\n        timeStr,\n        row[`Glucose_Range_${i}`],\n        row[`Glucose_Measurement_Type_${i}`]\n      );\n      readings.push(reading);\n    }\n  }\n  \n  return readings;\n}\n\nfunction processSingleColumnGlucose(row, baseDate) {\n  const value = parseFloat(row['Glucose_Level']);\n  if (!isNaN(value) && value > 0) {\n    const randomHour = Math.floor(Math.random() * 24);\n    const randomMinute = Math.floor(Math.random() * 60);\n    const date = new Date(baseDate);\n    date.setHours(randomHour, randomMinute);\n    \n    let range = 'in range';\n    if (value < 70) range = 'below range';\n    else if (value > 180) range = 'above range';\n    \n    return [{\n      date: date,\n      value: value,\n      range: range,\n      measurementType: 'Random'\n    }];\n  }\n  return [];\n}\n\n/**\n * Processes blood glucose data from CSV rows\n */\nexport function processGlucoseData(rows) {\n  const readings = [];\n  \n  rows.forEach(row => {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Glucose_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      readings.push(...processMultiColumnGlucose(row, baseDate));\n    } else {\n      readings.push(...processSingleColumnGlucose(row, baseDate));\n    }\n  });\n  \n  return readings;\n}\n\n/**\n * Processes blood pressure data from CSV rows\n */\nexport function processBloodPressureData(rows) {\n  const readings = [];\n  \n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Systolic_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      // Process up to 4 readings per day\n      for (let j = 1; j <= 4; j++) {\n        const systolic = parseInt(row[`Systolic_${j}`]);\n        const diastolic = parseInt(row[`Diastolic_${j}`]);\n        const timeStr = row[`BP_Time_${j}`];\n        \n        if (!isNaN(systolic) && !isNaN(diastolic) && systolic > 0 && diastolic > 0 && timeStr && timeStr.trim() !== '') {\n          const timeParts = timeStr.split(':');\n          if (timeParts.length >= 2) {\n            const hours = parseInt(timeParts[0], 10);\n            const minutes = parseInt(timeParts[1], 10);\n            \n            if (!isNaN(hours) && !isNaN(minutes)) {\n              const date = new Date(baseDate);\n              date.setHours(hours, minutes);\n              \n              readings.push({ \n                date: date, \n                systolic: systolic, \n                diastolic: diastolic, \n                systolicType: row[`Systolic_Type_${j}`],\n                diastolicType: row[`Diastolic_Type_${j}`]\n              });\n            }\n          }\n        }\n      }\n    } else {\n      // Single reading format\n      const systolic = parseInt(row['Systolic_BP']);\n      const diastolic = parseInt(row['Diastolic_BP']);\n      \n      if (!isNaN(systolic) && !isNaN(diastolic) && systolic > 0 && diastolic > 0) {\n        const randomHour = Math.floor(Math.random() * 24);\n        const randomMinute = Math.floor(Math.random() * 60);\n        const date = new Date(baseDate);\n        date.setHours(randomHour, randomMinute);\n        \n        let systolicType = 'normal';\n        let diastolicType = 'normal';\n        \n        if (systolic >= 180 || diastolic >= 120) {\n          systolicType = 'hypertensive crisis';\n          diastolicType = 'hypertensive crisis';\n        } else if (systolic >= 140 || diastolic >= 90) {\n          systolicType = 'high';\n          diastolicType = 'high';\n        } else if (systolic >= 130 || diastolic >= 80) {\n          systolicType = 'elevated';\n          diastolicType = 'elevated';\n        }\n        \n        readings.push({ \n          date: date, \n          systolic: systolic, \n          diastolic: diastolic, \n          systolicType: systolicType,\n          diastolicType: diastolicType\n        });\n      }\n    }\n  }\n  \n  return readings;\n}\n\n/**\n * Processes exercise data from CSV rows\n * \n * - @param {Array} rows - CSV data rows\n * - @returns {Array} Processed exercise data with activity types and durations\n */\nexport function processExerciseData(rows) {\n  const exerciseByDate = {};\n  \n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    const date = new Date(row['Date']);\n    const dateKey = date.toDateString();\n    \n    if (!exerciseByDate[dateKey]) {\n      exerciseByDate[dateKey] = { \n        date, \n        walking: 0, \n        swimming: 0, \n        running: 0, \n        biking: 0, \n        'muscle-strengthening': 0, \n        balance: 0, \n        other: 0, \n        totalMinutes: 0 \n      };\n    }\n    \n    const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      for (let j = 1; j <= 5; j++) {\n        const type = row[`Exercise_Type_${j}`]?.toLowerCase();\n        const minutes = parseFloat(row[`Exercise_Minutes_${j}`]);\n        if (type && type.trim() !== '' && !isNaN(minutes) && minutes > 0) {\n          categorizeExercise(type, minutes, exerciseByDate[dateKey]);\n        }\n      }\n    } else {\n      const type = row['Exercise_Type']?.toLowerCase();\n      const minutes = parseFloat(row['Exercise_Minutes']);\n      if (type && type.trim() !== '' && !isNaN(minutes) && minutes > 0) {\n        categorizeExercise(type, minutes, exerciseByDate[dateKey]);\n      }\n    }\n  }\n  \n  return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n}\n\n/**\n * Categorizes exercise activities into predefined types\n * \n * - @param {string} type - Exercise type from CSV\n * - @param {number} minutes - Duration in minutes\n * - @param {Object} dayData - Daily exercise data object\n */\nexport function categorizeExercise(type, minutes, dayData) {\n  if (type.includes('walking')) dayData.walking += minutes;\n    else if (type.includes('swimming')) dayData.swimming += minutes;\n    else if (type.includes('running')) dayData.running += minutes;\n    else if (type.includes('biking')) dayData.biking += minutes;\n    else if (type.includes('muscle-strengthening') || type.includes('muscle strengthening') || type.includes('strength')) dayData['muscle-strengthening'] += minutes;\n    else if (type.includes('balance')) dayData.balance += minutes;\n  else dayData.other += minutes;\n  dayData.totalMinutes += minutes;\n}\n\n/**\n * Processes mood data from CSV rows\n */\nexport function processMoodData(rows) {\n  const moodData = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (row['Mood'] && row['Mood'].trim() !== '') {\n        moodData.push({\n          date: new Date(row['Date']),\n          mood: row['Mood'],\n          category: row['Mood'] || 'neutral'\n        });\n      }\n    }\n  \n  return moodData;\n}\n\n/**\n * Processes pain data from CSV rows\n */\nexport function processPainData(rows) {\n  const painData = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (row['Pain_Location'] && row['Pain_Location'].trim() !== '' && row['Pain_Level'] !== undefined) {\n        const painLevel = parseInt(row['Pain_Level']);\n        if (!isNaN(painLevel)) {\n          painData.push({\n            date: new Date(row['Date']),\n            location: row['Pain_Location'].toLowerCase(),\n            level: painLevel\n          });\n        }\n      }\n    }\n  \n  return painData;\n}\n\n/**\n * Processes sleep data from CSV rows\n */\nexport function processSleepData(rows) {\n  const sleepData = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (row['Sleep_Hours'] && row['Sleep_Quality']) {\n        const hours = parseFloat(row['Sleep_Hours']);\n        const qualityCode = parseInt(row['Sleep_Quality_Code']);\n        if (!isNaN(hours) && !isNaN(qualityCode)) {\n          sleepData.push({\n            date: new Date(row['Date']),\n            hours: hours,\n            quality: row['Sleep_Quality'],\n            qualityCode: qualityCode\n          });\n        }\n      }\n    }\n  \n  return sleepData;\n}\n\n/**\n * Processes meal data from CSV rows - returns rows that have meal data\n */\nexport function processMealData(rows) {\n  const filteredRows = [];\n  const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\n  \n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    let hasMealData = false;\n    \n    // Check each meal type to see if there's any meal data\n    for (let j = 0; j < mealTypes.length; j++) {\n      const mealType = mealTypes[j];\n      const time = row[`${mealType}_Time`];\n      const protein = row[`${mealType}_Protein`];\n      const carbs = row[`${mealType}_Carbohydrates`];\n      const vegetables = row[`${mealType}_Vegetables`];\n      const fruit = row[`${mealType}_Fruit`];\n      const alcohol = row[`${mealType}_Alcohol`];\n      const sugar = row[`${mealType}_Added_Sugar`];\n      \n      // Check if time exists and at least one food component is present\n      const hasFood = protein === 1 || protein === '1' || \n                     carbs === 1 || carbs === '1' || \n                     vegetables === 1 || vegetables === '1' || \n                     fruit === 1 || fruit === '1' || \n                     alcohol === 1 || alcohol === '1' || \n                     (sugar && sugar !== '' && sugar !== 'NaN');\n      \n      if (time && hasFood) {\n        hasMealData = true;\n        break;\n      }\n    }\n    \n    if (hasMealData) {\n      filteredRows.push(row);\n    }\n  }\n  \n  return filteredRows;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}