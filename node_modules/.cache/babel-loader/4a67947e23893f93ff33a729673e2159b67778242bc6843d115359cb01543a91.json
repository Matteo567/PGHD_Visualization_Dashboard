{"ast":null,"code":"/*\n dataService.js - Patient Data Service\n \n This service handles all data operations for the health dashboard:\n - Fetches patient CSV data from the server\n - Parses and processes CSV data using PapaParse\n - Transforms raw data into structured health metrics\n - Provides data validation and error handling\n - Manages patient information, medications, and health tracking data\n - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\n \n Architecture:\n - Uses PapaParse library for CSV parsing\n - Implements service class pattern for data operations\n - Provides comprehensive error handling and validation\n - Supports multiple data formats and structures\n \n Data Processing:\n - CSV parsing with header validation\n - Data transformation and normalization\n - Type conversion and validation\n - Error recovery and fallback mechanisms\n \n Health Metrics Supported:\n - Blood glucose monitoring with meal context\n - Blood pressure tracking with risk categorization\n - Exercise activity tracking and categorization\n - Mood assessment and tracking\n - Pain reporting with anatomical mapping\n - Sleep quality and duration analysis\n - Nutritional intake and meal composition\n \n Error Handling:\n - Network error recovery\n - CSV parsing error handling\n - Data validation and sanitization\n - Graceful degradation for missing data\n \n Core service for data management and processing throughout the application.\n */\n\nimport Papa from 'papaparse';\n\n// Configuration for CSV parsing\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: header => (header === null || header === void 0 ? void 0 : header.trim()) || '',\n  transform: value => (value === null || value === void 0 ? void 0 : value.trim()) || '',\n  dynamicTyping: false,\n  // Keep everything as strings to avoid parsing issues\n  delimiter: ',',\n  quoteChar: '\"',\n  escapeChar: '\"'\n};\n\n/*\n Fetches and parses CSV data for a specific patient\n \n - @param {string} patientId - The patient identifier\n - @returns {Promise<Array>} Parsed CSV data as array of objects\n - @throws {Error} If CSV fetch or parsing fails\n */\nconst fetchPatientCsvData = async patientId => {\n  try {\n    // Use relative path for both dev and production (works with PUBLIC_URL)\n    const url = `${process.env.PUBLIC_URL}/synthetic_patients/${patientId}.csv?v=${Date.now()}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\n    }\n    const csvText = await response.text();\n    if (!csvText || csvText.trim().length === 0) {\n      throw new Error(`Empty CSV file for patient ${patientId}`);\n    }\n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    if (parsed.errors.length > 0) {\n      // Log parsing errors for debugging but don't throw (only in development)\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`CSV parsing warnings for ${patientId}:`, parsed.errors);\n      }\n    }\n    return parsed.data;\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    }\n    throw error;\n  }\n};\n\n/*\n Service class for handling patient data operations\n Provides methods for fetching and processing patient health data from CSV files\n */\n/*\n| Retrieves and processes all data for a specific patient\n| \n| @param {string} patientId - The patient identifier\n| @returns {Promise<Object>} Processed patient data including all health metrics\n| @throws {Error} If patient data cannot be retrieved or processed\n| */\nexport async function getPatientData(patientId) {\n  if (!patientId) {\n    throw new Error('Patient ID is required');\n  }\n  try {\n    const patientRows = await fetchPatientCsvData(patientId);\n    if (!Array.isArray(patientRows) || patientRows.length === 0) {\n      throw new Error(`No data found for patient ${patientId}`);\n    }\n    return processPatientData(patientRows, patientId);\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching patient data for ${patientId}:`, error);\n    }\n    throw error;\n  }\n}\n\n/**\n * Processes raw CSV data into structured patient information and health metrics\n * \n * - @param {Array} rows - Raw CSV data rows\n * - @param {string} patientId - The patient identifier\n * - @returns {Object} Structured patient data object\n * - @throws {Error} If data structure is invalid or processing fails\n */\nexport function processPatientData(rows, patientId) {\n  if (!Array.isArray(rows) || rows.length === 0) {\n    throw new Error(`Invalid data structure for patient ${patientId}`);\n  }\n  const firstRowData = rows[0];\n  if (!firstRowData) {\n    throw new Error(`No valid data rows found for patient ${patientId}`);\n  }\n  const patientInfo = {\n    patientId,\n    patientNumber: patientId,\n    name: firstRowData['Name'] || 'Not specified',\n    age: firstRowData['Age'] || 'Not specified',\n    gender: firstRowData['Gender'] || 'Not specified',\n    dataAvailable: 'May 2025'\n  };\n\n  // Process medications from the first row\n  const detailedMedications = [];\n  const medicationNamesStr = firstRowData['Medication_Names'] || '';\n  const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\n  if (medicationNamesStr && medicationDosagesStr) {\n    const medicationNames = medicationNamesStr.split('; ').filter(Boolean);\n    const medicationDosages = medicationDosagesStr.split('; ').filter(Boolean);\n    for (let i = 0; i < medicationNames.length; i++) {\n      var _medicationNames$i, _medicationDosages$i;\n      const name = ((_medicationNames$i = medicationNames[i]) === null || _medicationNames$i === void 0 ? void 0 : _medicationNames$i.trim()) || '';\n      const dosage = ((_medicationDosages$i = medicationDosages[i]) === null || _medicationDosages$i === void 0 ? void 0 : _medicationDosages$i.trim()) || '';\n\n      // Only add valid medication names\n      if (name && name.length < 100 && !name.includes('Dose not specified') && !name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) {\n        detailedMedications.push({\n          name: name,\n          schedule: dosage,\n          category: '',\n          dosage: ''\n        });\n      }\n    }\n  }\n\n  // Process conditions from all rows\n  const conditionsSet = new Set();\n  for (let i = 0; i < rows.length; i++) {\n    const conditionString = rows[i]['Chronic_Conditions'] || rows[i]['Conditions'] || '';\n    if (conditionString) {\n      const conditionList = conditionString.split(';');\n      for (let j = 0; j < conditionList.length; j++) {\n        const condition = conditionList[j].trim();\n        if (condition) {\n          conditionsSet.add(condition);\n        }\n      }\n    }\n  }\n\n  // Process all data types\n  const glucoseData = processGlucoseData(rows);\n  const bloodPressureData = processBloodPressureData(rows);\n  const exerciseData = processExerciseData(rows);\n  const moodData = processMoodData(rows);\n  const painData = processPainData(rows);\n  const sleepData = processSleepData(rows);\n  const mealData = processMealData(rows);\n  return {\n    patientInfo: {\n      ...patientInfo,\n      detailedMedications,\n      conditions: Array.from(conditionsSet)\n    },\n    glucoseData,\n    bloodPressureData,\n    exerciseData,\n    moodData,\n    painData,\n    mealData,\n    sleepData,\n    rawData: rows\n  };\n}\n\n// Helper functions for glucose data processing\nfunction parseTimeString(timeStr) {\n  if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {\n    return {\n      hours: 0,\n      minutes: 0\n    };\n  }\n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) {\n    return {\n      hours: 0,\n      minutes: 0\n    };\n  }\n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  return {\n    hours: isNaN(hours) ? 0 : hours,\n    minutes: isNaN(minutes) ? 0 : minutes\n  };\n}\nfunction createGlucoseReading(baseDate, value, timeStr, range, measurementType) {\n  const {\n    hours,\n    minutes\n  } = parseTimeString(timeStr);\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  return {\n    date: date,\n    value: value,\n    range: range,\n    measurementType: measurementType\n  };\n}\nfunction processMultiColumnGlucose(row, baseDate) {\n  const readings = [];\n  for (let i = 1; i <= 4; i++) {\n    const value = parseFloat(row[`Glucose_${i}`]);\n    const timeStr = row[`Glucose_Time_${i}`];\n    if (!isNaN(value) && value > 0 && timeStr && timeStr.trim() !== '') {\n      const reading = createGlucoseReading(baseDate, value, timeStr, row[`Glucose_Range_${i}`], row[`Glucose_Measurement_Type_${i}`]);\n      readings.push(reading);\n    }\n  }\n  return readings;\n}\nfunction processSingleColumnGlucose(row, baseDate) {\n  const value = parseFloat(row['Glucose_Level']);\n  if (!isNaN(value) && value > 0) {\n    const randomHour = Math.floor(Math.random() * 24);\n    const randomMinute = Math.floor(Math.random() * 60);\n    const date = new Date(baseDate);\n    date.setHours(randomHour, randomMinute);\n    let range = 'in range';\n    if (value < 70) range = 'below range';else if (value > 180) range = 'above range';\n    return [{\n      date: date,\n      value: value,\n      range: range,\n      measurementType: 'Random'\n    }];\n  }\n  return [];\n}\n\n/**\n * Processes blood glucose data from CSV rows\n */\nfunction processGlucoseData(rows) {\n  const readings = [];\n  rows.forEach(row => {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Glucose_1'] !== undefined;\n    if (hasMultiColumn) {\n      readings.push(...processMultiColumnGlucose(row, baseDate));\n    } else {\n      readings.push(...processSingleColumnGlucose(row, baseDate));\n    }\n  });\n  return readings;\n}\n\n/**\n * Creates a date with time from a base date and time string\n */\nfunction createDateWithTime(baseDate, timeStr) {\n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) return null;\n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  if (isNaN(hours) || isNaN(minutes)) return null;\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  return date;\n}\n\n/**\n * Determines BP type based on systolic and diastolic values\n */\nfunction getBPType(systolic, diastolic) {\n  if (systolic >= 180 || diastolic >= 120) return 'hypertensive crisis';\n  if (systolic >= 140 || diastolic >= 90) return 'high';\n  if (systolic >= 130 || diastolic >= 80) return 'elevated';\n  return 'normal';\n}\n\n/**\n * Processes a single BP reading from multi-column format\n */\nfunction processMultiColumnBPReading(row, index, baseDate) {\n  const systolic = parseInt(row[`Systolic_${index}`]);\n  const diastolic = parseInt(row[`Diastolic_${index}`]);\n  const timeStr = row[`BP_Time_${index}`];\n  const isValid = !isNaN(systolic) && !isNaN(diastolic) && systolic > 0 && diastolic > 0 && timeStr && timeStr.trim() !== '';\n  if (!isValid) return null;\n  const date = createDateWithTime(baseDate, timeStr);\n  if (!date) return null;\n  return {\n    date,\n    systolic,\n    diastolic,\n    systolicType: row[`Systolic_Type_${index}`],\n    diastolicType: row[`Diastolic_Type_${index}`]\n  };\n}\n\n/**\n * Processes a single BP reading from single-column format\n */\nfunction processSingleColumnBPReading(row, baseDate) {\n  const systolic = parseInt(row['Systolic_BP']);\n  const diastolic = parseInt(row['Diastolic_BP']);\n  if (isNaN(systolic) || isNaN(diastolic) || systolic <= 0 || diastolic <= 0) {\n    return null;\n  }\n\n  // Generate random time for single reading format\n  const randomHour = Math.floor(Math.random() * 24);\n  const randomMinute = Math.floor(Math.random() * 60);\n  const date = new Date(baseDate);\n  date.setHours(randomHour, randomMinute);\n  const bpType = getBPType(systolic, diastolic);\n  return {\n    date,\n    systolic,\n    diastolic,\n    systolicType: bpType,\n    diastolicType: bpType\n  };\n}\n\n/**\n * Processes blood pressure data from CSV rows\n */\nfunction processBloodPressureData(rows) {\n  const readings = [];\n  for (const row of rows) {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Systolic_1'] !== undefined;\n    if (hasMultiColumn) {\n      // Process up to 4 readings per day\n      for (let j = 1; j <= 4; j++) {\n        const reading = processMultiColumnBPReading(row, j, baseDate);\n        if (reading) readings.push(reading);\n      }\n    } else {\n      // Single reading format\n      const reading = processSingleColumnBPReading(row, baseDate);\n      if (reading) readings.push(reading);\n    }\n  }\n  return readings;\n}\n\n/**\n * Creates initial exercise data structure for a date\n */\nfunction createExerciseDayData(date) {\n  return {\n    date,\n    walking: 0,\n    swimming: 0,\n    running: 0,\n    biking: 0,\n    'muscle-strengthening': 0,\n    balance: 0,\n    other: 0,\n    totalMinutes: 0\n  };\n}\n\n/**\n * Processes a single exercise entry\n */\nfunction processExerciseEntry(row, index, dayData) {\n  var _row$typeKey;\n  const typeKey = index ? `Exercise_Type_${index}` : 'Exercise_Type';\n  const minutesKey = index ? `Exercise_Minutes_${index}` : 'Exercise_Minutes';\n  const type = (_row$typeKey = row[typeKey]) === null || _row$typeKey === void 0 ? void 0 : _row$typeKey.toLowerCase();\n  const minutes = parseFloat(row[minutesKey]);\n  if (type && type.trim() !== '' && !isNaN(minutes) && minutes > 0) {\n    categorizeExercise(type, minutes, dayData);\n  }\n}\n\n/**\n * Processes exercise data from CSV rows\n * \n * - @param {Array} rows - CSV data rows\n * - @returns {Array} Processed exercise data with activity types and durations\n */\nfunction processExerciseData(rows) {\n  const exerciseByDate = {};\n  for (const row of rows) {\n    const date = new Date(row['Date']);\n    const dateKey = date.toDateString();\n    if (!exerciseByDate[dateKey]) {\n      exerciseByDate[dateKey] = createExerciseDayData(date);\n    }\n    const dayData = exerciseByDate[dateKey];\n    const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\n    if (hasMultiColumn) {\n      // Process up to 5 exercise entries per day\n      for (let j = 1; j <= 5; j++) {\n        processExerciseEntry(row, j, dayData);\n      }\n    } else {\n      // Single exercise entry\n      processExerciseEntry(row, null, dayData);\n    }\n  }\n  return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n}\n\n/**\n * Categorizes exercise activities into predefined types\n * \n * - @param {string} type - Exercise type from CSV\n * - @param {number} minutes - Duration in minutes\n * - @param {Object} dayData - Daily exercise data object\n */\nexport function categorizeExercise(type, minutes, dayData) {\n  if (type.includes('walking')) dayData.walking += minutes;else if (type.includes('swimming')) dayData.swimming += minutes;else if (type.includes('running')) dayData.running += minutes;else if (type.includes('biking')) dayData.biking += minutes;else if (type.includes('muscle-strengthening') || type.includes('muscle strengthening') || type.includes('strength')) dayData['muscle-strengthening'] += minutes;else if (type.includes('balance')) dayData.balance += minutes;else dayData.other += minutes;\n  dayData.totalMinutes += minutes;\n}\n\n/**\n * Processes mood data from CSV rows\n */\nexport function processMoodData(rows) {\n  const moodData = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    if (row['Mood'] && row['Mood'].trim() !== '') {\n      moodData.push({\n        date: new Date(row['Date']),\n        mood: row['Mood'],\n        category: row['Mood'] || 'neutral'\n      });\n    }\n  }\n  return moodData;\n}\n\n/**\n * Processes pain data from CSV rows\n */\nexport function processPainData(rows) {\n  const painData = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    if (row['Pain_Location'] && row['Pain_Location'].trim() !== '' && row['Pain_Level'] !== undefined) {\n      const painLevel = parseInt(row['Pain_Level']);\n      if (!isNaN(painLevel)) {\n        painData.push({\n          date: new Date(row['Date']),\n          location: row['Pain_Location'].toLowerCase(),\n          level: painLevel\n        });\n      }\n    }\n  }\n  return painData;\n}\n\n/**\n * Processes sleep data from CSV rows\n */\nexport function processSleepData(rows) {\n  const sleepData = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    if (row['Sleep_Hours'] && row['Sleep_Quality']) {\n      const hours = parseFloat(row['Sleep_Hours']);\n      const qualityCode = parseInt(row['Sleep_Quality_Code']);\n      if (!isNaN(hours) && !isNaN(qualityCode)) {\n        sleepData.push({\n          date: new Date(row['Date']),\n          hours: hours,\n          quality: row['Sleep_Quality'],\n          qualityCode: qualityCode\n        });\n      }\n    }\n  }\n  return sleepData;\n}\n\n/**\n * Checks if a meal has any food components\n */\nfunction hasMealComponents(row, mealType) {\n  const components = [row[`${mealType}_Protein`], row[`${mealType}_Carbohydrates`], row[`${mealType}_Vegetables`], row[`${mealType}_Fruit`], row[`${mealType}_Alcohol`], row[`${mealType}_Added_Sugar`]];\n  return components.some(comp => comp === 1 || comp === '1' || comp && comp !== '' && comp !== 'NaN');\n}\n\n/**\n * Checks if a row has any meal data\n */\nfunction hasAnyMealData(row) {\n  const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\n  return mealTypes.some(mealType => {\n    const time = row[`${mealType}_Time`];\n    return time && hasMealComponents(row, mealType);\n  });\n}\n\n/**\n * Processes meal data from CSV rows - returns rows that have meal data\n */\nexport function processMealData(rows) {\n  return rows.filter(row => hasAnyMealData(row));\n}","map":{"version":3,"names":["Papa","CSV_CONFIG","header","skipEmptyLines","transformHeader","trim","transform","value","dynamicTyping","delimiter","quoteChar","escapeChar","fetchPatientCsvData","patientId","url","process","env","PUBLIC_URL","Date","now","response","fetch","ok","Error","status","statusText","csvText","text","length","parsed","parse","errors","NODE_ENV","console","warn","data","error","getPatientData","patientRows","Array","isArray","processPatientData","rows","firstRowData","patientInfo","patientNumber","name","age","gender","dataAvailable","detailedMedications","medicationNamesStr","medicationDosagesStr","medicationNames","split","filter","Boolean","medicationDosages","i","_medicationNames$i","_medicationDosages$i","dosage","includes","push","schedule","category","conditionsSet","Set","conditionString","conditionList","j","condition","add","glucoseData","processGlucoseData","bloodPressureData","processBloodPressureData","exerciseData","processExerciseData","moodData","processMoodData","painData","processPainData","sleepData","processSleepData","mealData","processMealData","conditions","from","rawData","parseTimeString","timeStr","hours","minutes","timeParts","parseInt","isNaN","createGlucoseReading","baseDate","range","measurementType","date","setHours","processMultiColumnGlucose","row","readings","parseFloat","reading","processSingleColumnGlucose","randomHour","Math","floor","random","randomMinute","forEach","hasMultiColumn","undefined","createDateWithTime","getBPType","systolic","diastolic","processMultiColumnBPReading","index","isValid","systolicType","diastolicType","processSingleColumnBPReading","bpType","createExerciseDayData","walking","swimming","running","biking","balance","other","totalMinutes","processExerciseEntry","dayData","_row$typeKey","typeKey","minutesKey","type","toLowerCase","categorizeExercise","exerciseByDate","dateKey","toDateString","Object","values","d","mood","painLevel","location","level","qualityCode","quality","hasMealComponents","mealType","components","some","comp","hasAnyMealData","mealTypes","time"],"sources":["C:/Users/Matteo/Working_Folder/a. MCC Thesis Local Experimental/PGHD_Visualization_Dashboard/src/services/dataService.js"],"sourcesContent":["/*\n dataService.js - Patient Data Service\n \n This service handles all data operations for the health dashboard:\n - Fetches patient CSV data from the server\n - Parses and processes CSV data using PapaParse\n - Transforms raw data into structured health metrics\n - Provides data validation and error handling\n - Manages patient information, medications, and health tracking data\n - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\n \n Architecture:\n - Uses PapaParse library for CSV parsing\n - Implements service class pattern for data operations\n - Provides comprehensive error handling and validation\n - Supports multiple data formats and structures\n \n Data Processing:\n - CSV parsing with header validation\n - Data transformation and normalization\n - Type conversion and validation\n - Error recovery and fallback mechanisms\n \n Health Metrics Supported:\n - Blood glucose monitoring with meal context\n - Blood pressure tracking with risk categorization\n - Exercise activity tracking and categorization\n - Mood assessment and tracking\n - Pain reporting with anatomical mapping\n - Sleep quality and duration analysis\n - Nutritional intake and meal composition\n \n Error Handling:\n - Network error recovery\n - CSV parsing error handling\n - Data validation and sanitization\n - Graceful degradation for missing data\n \n Core service for data management and processing throughout the application.\n */\n\nimport Papa from 'papaparse';\n\n// Configuration for CSV parsing\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: (header) => header?.trim() || '',\n  transform: (value) => value?.trim() || '',\n  dynamicTyping: false, // Keep everything as strings to avoid parsing issues\n  delimiter: ',',\n  quoteChar: '\"',\n  escapeChar: '\"'\n};\n\n/*\n Fetches and parses CSV data for a specific patient\n \n - @param {string} patientId - The patient identifier\n - @returns {Promise<Array>} Parsed CSV data as array of objects\n - @throws {Error} If CSV fetch or parsing fails\n */\nconst fetchPatientCsvData = async (patientId) => {\n  try {\n    // Use relative path for both dev and production (works with PUBLIC_URL)\n    const url = `${process.env.PUBLIC_URL}/synthetic_patients/${patientId}.csv?v=${Date.now()}`;\n    const response = await fetch(url);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\n    }\n    \n    const csvText = await response.text();\n    \n    if (!csvText || csvText.trim().length === 0) {\n      throw new Error(`Empty CSV file for patient ${patientId}`);\n    }\n    \n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    \n    if (parsed.errors.length > 0) {\n      // Log parsing errors for debugging but don't throw (only in development)\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`CSV parsing warnings for ${patientId}:`, parsed.errors);\n      }\n    }\n    \n    return parsed.data;\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    }\n    throw error;\n  }\n};\n\n/*\n Service class for handling patient data operations\n Provides methods for fetching and processing patient health data from CSV files\n */\n/*\n| Retrieves and processes all data for a specific patient\n| \n| @param {string} patientId - The patient identifier\n| @returns {Promise<Object>} Processed patient data including all health metrics\n| @throws {Error} If patient data cannot be retrieved or processed\n| */\nexport async function getPatientData(patientId) {\n  if (!patientId) {\n    throw new Error('Patient ID is required');\n  }\n\n  try {\n    const patientRows = await fetchPatientCsvData(patientId);\n\n    if (!Array.isArray(patientRows) || patientRows.length === 0) {\n      throw new Error(`No data found for patient ${patientId}`);\n    }\n\n    return processPatientData(patientRows, patientId);\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching patient data for ${patientId}:`, error);\n    }\n    throw error;\n  }\n}\n\n/**\n * Processes raw CSV data into structured patient information and health metrics\n * \n * - @param {Array} rows - Raw CSV data rows\n * - @param {string} patientId - The patient identifier\n * - @returns {Object} Structured patient data object\n * - @throws {Error} If data structure is invalid or processing fails\n */\nexport function processPatientData(rows, patientId) {\n  if (!Array.isArray(rows) || rows.length === 0) {\n    throw new Error(`Invalid data structure for patient ${patientId}`);\n  }\n\n  const firstRowData = rows[0];\n  if (!firstRowData) {\n    throw new Error(`No valid data rows found for patient ${patientId}`);\n  }\n\n  const patientInfo = {\n    patientId,\n    patientNumber: patientId,\n    name: firstRowData['Name'] || 'Not specified',\n    age: firstRowData['Age'] || 'Not specified',\n    gender: firstRowData['Gender'] || 'Not specified',\n    dataAvailable: 'May 2025'\n  };\n\n  // Process medications from the first row\n  const detailedMedications = [];\n  const medicationNamesStr = firstRowData['Medication_Names'] || '';\n  const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\n  \n  if (medicationNamesStr && medicationDosagesStr) {\n    const medicationNames = medicationNamesStr.split('; ').filter(Boolean);\n    const medicationDosages = medicationDosagesStr.split('; ').filter(Boolean);\n    \n    for (let i = 0; i < medicationNames.length; i++) {\n      const name = medicationNames[i]?.trim() || '';\n      const dosage = medicationDosages[i]?.trim() || '';\n      \n      // Only add valid medication names\n      if (name && name.length < 100 && \n          !name.includes('Dose not specified') && \n          !name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) {\n        detailedMedications.push({\n          name: name,\n          schedule: dosage,\n          category: '',\n          dosage: ''\n        });\n      }\n    }\n  }\n\n  // Process conditions from all rows\n  const conditionsSet = new Set();\n  for (let i = 0; i < rows.length; i++) {\n    const conditionString = rows[i]['Chronic_Conditions'] || rows[i]['Conditions'] || '';\n    if (conditionString) {\n      const conditionList = conditionString.split(';');\n      for (let j = 0; j < conditionList.length; j++) {\n        const condition = conditionList[j].trim();\n        if (condition) {\n          conditionsSet.add(condition);\n        }\n      }\n    }\n  }\n\n  // Process all data types\n  const glucoseData = processGlucoseData(rows);\n  const bloodPressureData = processBloodPressureData(rows);\n  const exerciseData = processExerciseData(rows);\n  const moodData = processMoodData(rows);\n  const painData = processPainData(rows);\n  const sleepData = processSleepData(rows);\n  const mealData = processMealData(rows);\n\n  return {\n    patientInfo: { \n      ...patientInfo, \n      detailedMedications, \n      conditions: Array.from(conditionsSet)\n    },\n    glucoseData,\n    bloodPressureData,\n    exerciseData,\n    moodData,\n    painData,\n    mealData,\n    sleepData,\n    rawData: rows\n  };\n}\n\n// Helper functions for glucose data processing\nfunction parseTimeString(timeStr) {\n  if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {\n    return { hours: 0, minutes: 0 };\n  }\n  \n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) {\n    return { hours: 0, minutes: 0 };\n  }\n  \n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  \n  return {\n    hours: isNaN(hours) ? 0 : hours,\n    minutes: isNaN(minutes) ? 0 : minutes\n  };\n}\n\nfunction createGlucoseReading(baseDate, value, timeStr, range, measurementType) {\n  const { hours, minutes } = parseTimeString(timeStr);\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  \n  return {\n    date: date,\n    value: value,\n    range: range,\n    measurementType: measurementType\n  };\n}\n\nfunction processMultiColumnGlucose(row, baseDate) {\n  const readings = [];\n  \n  for (let i = 1; i <= 4; i++) {\n    const value = parseFloat(row[`Glucose_${i}`]);\n    const timeStr = row[`Glucose_Time_${i}`];\n    \n    if (!isNaN(value) && value > 0 && timeStr && timeStr.trim() !== '') {\n      const reading = createGlucoseReading(\n        baseDate,\n        value,\n        timeStr,\n        row[`Glucose_Range_${i}`],\n        row[`Glucose_Measurement_Type_${i}`]\n      );\n      readings.push(reading);\n    }\n  }\n  \n  return readings;\n}\n\nfunction processSingleColumnGlucose(row, baseDate) {\n  const value = parseFloat(row['Glucose_Level']);\n  if (!isNaN(value) && value > 0) {\n    const randomHour = Math.floor(Math.random() * 24);\n    const randomMinute = Math.floor(Math.random() * 60);\n    const date = new Date(baseDate);\n    date.setHours(randomHour, randomMinute);\n    \n    let range = 'in range';\n    if (value < 70) range = 'below range';\n    else if (value > 180) range = 'above range';\n    \n    return [{\n      date: date,\n      value: value,\n      range: range,\n      measurementType: 'Random'\n    }];\n  }\n  return [];\n}\n\n/**\n * Processes blood glucose data from CSV rows\n */\nfunction processGlucoseData(rows) {\n  const readings = [];\n  \n  rows.forEach(row => {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Glucose_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      readings.push(...processMultiColumnGlucose(row, baseDate));\n    } else {\n      readings.push(...processSingleColumnGlucose(row, baseDate));\n    }\n  });\n  \n  return readings;\n}\n\n/**\n * Creates a date with time from a base date and time string\n */\nfunction createDateWithTime(baseDate, timeStr) {\n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) return null;\n  \n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  \n  if (isNaN(hours) || isNaN(minutes)) return null;\n  \n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  return date;\n}\n\n/**\n * Determines BP type based on systolic and diastolic values\n */\nfunction getBPType(systolic, diastolic) {\n  if (systolic >= 180 || diastolic >= 120) return 'hypertensive crisis';\n  if (systolic >= 140 || diastolic >= 90) return 'high';\n  if (systolic >= 130 || diastolic >= 80) return 'elevated';\n  return 'normal';\n}\n\n/**\n * Processes a single BP reading from multi-column format\n */\nfunction processMultiColumnBPReading(row, index, baseDate) {\n  const systolic = parseInt(row[`Systolic_${index}`]);\n  const diastolic = parseInt(row[`Diastolic_${index}`]);\n  const timeStr = row[`BP_Time_${index}`];\n  \n  const isValid = !isNaN(systolic) && !isNaN(diastolic) && \n                  systolic > 0 && diastolic > 0 && \n                  timeStr && timeStr.trim() !== '';\n  \n  if (!isValid) return null;\n  \n  const date = createDateWithTime(baseDate, timeStr);\n  if (!date) return null;\n  \n  return {\n    date,\n    systolic,\n    diastolic,\n    systolicType: row[`Systolic_Type_${index}`],\n    diastolicType: row[`Diastolic_Type_${index}`]\n  };\n}\n\n/**\n * Processes a single BP reading from single-column format\n */\nfunction processSingleColumnBPReading(row, baseDate) {\n  const systolic = parseInt(row['Systolic_BP']);\n  const diastolic = parseInt(row['Diastolic_BP']);\n  \n  if (isNaN(systolic) || isNaN(diastolic) || systolic <= 0 || diastolic <= 0) {\n    return null;\n  }\n  \n  // Generate random time for single reading format\n  const randomHour = Math.floor(Math.random() * 24);\n  const randomMinute = Math.floor(Math.random() * 60);\n  const date = new Date(baseDate);\n  date.setHours(randomHour, randomMinute);\n  \n  const bpType = getBPType(systolic, diastolic);\n  \n  return {\n    date,\n    systolic,\n    diastolic,\n    systolicType: bpType,\n    diastolicType: bpType\n  };\n}\n\n/**\n * Processes blood pressure data from CSV rows\n */\nfunction processBloodPressureData(rows) {\n  const readings = [];\n  \n  for (const row of rows) {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Systolic_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      // Process up to 4 readings per day\n      for (let j = 1; j <= 4; j++) {\n        const reading = processMultiColumnBPReading(row, j, baseDate);\n        if (reading) readings.push(reading);\n      }\n    } else {\n      // Single reading format\n      const reading = processSingleColumnBPReading(row, baseDate);\n      if (reading) readings.push(reading);\n    }\n  }\n  \n  return readings;\n}\n\n/**\n * Creates initial exercise data structure for a date\n */\nfunction createExerciseDayData(date) {\n  return {\n    date,\n    walking: 0,\n    swimming: 0,\n    running: 0,\n    biking: 0,\n    'muscle-strengthening': 0,\n    balance: 0,\n    other: 0,\n    totalMinutes: 0\n  };\n}\n\n/**\n * Processes a single exercise entry\n */\nfunction processExerciseEntry(row, index, dayData) {\n  const typeKey = index ? `Exercise_Type_${index}` : 'Exercise_Type';\n  const minutesKey = index ? `Exercise_Minutes_${index}` : 'Exercise_Minutes';\n  \n  const type = row[typeKey]?.toLowerCase();\n  const minutes = parseFloat(row[minutesKey]);\n  \n  if (type && type.trim() !== '' && !isNaN(minutes) && minutes > 0) {\n    categorizeExercise(type, minutes, dayData);\n  }\n}\n\n/**\n * Processes exercise data from CSV rows\n * \n * - @param {Array} rows - CSV data rows\n * - @returns {Array} Processed exercise data with activity types and durations\n */\nfunction processExerciseData(rows) {\n  const exerciseByDate = {};\n  \n  for (const row of rows) {\n    const date = new Date(row['Date']);\n    const dateKey = date.toDateString();\n    \n    if (!exerciseByDate[dateKey]) {\n      exerciseByDate[dateKey] = createExerciseDayData(date);\n    }\n    \n    const dayData = exerciseByDate[dateKey];\n    const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      // Process up to 5 exercise entries per day\n      for (let j = 1; j <= 5; j++) {\n        processExerciseEntry(row, j, dayData);\n      }\n    } else {\n      // Single exercise entry\n      processExerciseEntry(row, null, dayData);\n    }\n  }\n  \n  return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n}\n\n/**\n * Categorizes exercise activities into predefined types\n * \n * - @param {string} type - Exercise type from CSV\n * - @param {number} minutes - Duration in minutes\n * - @param {Object} dayData - Daily exercise data object\n */\nexport function categorizeExercise(type, minutes, dayData) {\n  if (type.includes('walking')) dayData.walking += minutes;\n    else if (type.includes('swimming')) dayData.swimming += minutes;\n    else if (type.includes('running')) dayData.running += minutes;\n    else if (type.includes('biking')) dayData.biking += minutes;\n    else if (type.includes('muscle-strengthening') || type.includes('muscle strengthening') || type.includes('strength')) dayData['muscle-strengthening'] += minutes;\n    else if (type.includes('balance')) dayData.balance += minutes;\n  else dayData.other += minutes;\n  dayData.totalMinutes += minutes;\n}\n\n/**\n * Processes mood data from CSV rows\n */\nexport function processMoodData(rows) {\n  const moodData = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (row['Mood'] && row['Mood'].trim() !== '') {\n        moodData.push({\n          date: new Date(row['Date']),\n          mood: row['Mood'],\n          category: row['Mood'] || 'neutral'\n        });\n      }\n    }\n  \n  return moodData;\n}\n\n/**\n * Processes pain data from CSV rows\n */\nexport function processPainData(rows) {\n  const painData = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (row['Pain_Location'] && row['Pain_Location'].trim() !== '' && row['Pain_Level'] !== undefined) {\n        const painLevel = parseInt(row['Pain_Level']);\n        if (!isNaN(painLevel)) {\n          painData.push({\n            date: new Date(row['Date']),\n            location: row['Pain_Location'].toLowerCase(),\n            level: painLevel\n          });\n        }\n      }\n    }\n  \n  return painData;\n}\n\n/**\n * Processes sleep data from CSV rows\n */\nexport function processSleepData(rows) {\n  const sleepData = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (row['Sleep_Hours'] && row['Sleep_Quality']) {\n        const hours = parseFloat(row['Sleep_Hours']);\n        const qualityCode = parseInt(row['Sleep_Quality_Code']);\n        if (!isNaN(hours) && !isNaN(qualityCode)) {\n          sleepData.push({\n            date: new Date(row['Date']),\n            hours: hours,\n            quality: row['Sleep_Quality'],\n            qualityCode: qualityCode\n          });\n        }\n      }\n    }\n  \n  return sleepData;\n}\n\n/**\n * Checks if a meal has any food components\n */\nfunction hasMealComponents(row, mealType) {\n  const components = [\n    row[`${mealType}_Protein`],\n    row[`${mealType}_Carbohydrates`],\n    row[`${mealType}_Vegetables`],\n    row[`${mealType}_Fruit`],\n    row[`${mealType}_Alcohol`],\n    row[`${mealType}_Added_Sugar`]\n  ];\n  \n  return components.some(comp => \n    comp === 1 || comp === '1' || (comp && comp !== '' && comp !== 'NaN')\n  );\n}\n\n/**\n * Checks if a row has any meal data\n */\nfunction hasAnyMealData(row) {\n  const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\n  \n  return mealTypes.some(mealType => {\n    const time = row[`${mealType}_Time`];\n    return time && hasMealComponents(row, mealType);\n  });\n}\n\n/**\n * Processes meal data from CSV rows - returns rows that have meal data\n */\nexport function processMealData(rows) {\n  return rows.filter(row => hasAnyMealData(row));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}