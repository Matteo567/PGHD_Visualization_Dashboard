{"ast":null,"code":"/*\n dataService.js - Patient Data Service\n \n This service handles all data operations for the health dashboard:\n - Fetches patient CSV data from the server\n - Parses and processes CSV data using PapaParse\n - Transforms raw data into structured health metrics\n - Provides data validation and error handling\n - Manages patient information, medications, and health tracking data\n - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\n \n Architecture:\n - Uses PapaParse library for CSV parsing\n - Implements service class pattern for data operations\n - Provides comprehensive error handling and validation\n - Supports multiple data formats and structures\n \n Data Processing:\n - CSV parsing with header validation\n - Data transformation and normalization\n - Type conversion and validation\n - Error recovery and fallback mechanisms\n \n Health Metrics Supported:\n - Blood glucose monitoring with meal context\n - Blood pressure tracking with risk categorization\n - Exercise activity tracking and categorization\n - Mood assessment and tracking\n - Pain reporting with anatomical mapping\n - Sleep quality and duration analysis\n - Nutritional intake and meal composition\n \n Error Handling:\n - Network error recovery\n - CSV parsing error handling\n - Data validation and sanitization\n - Graceful degradation for missing data\n \n Core service for data management and processing throughout the application.\n */\n\nimport Papa from 'papaparse';\n\n// Configuration for CSV parsing\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: header => (header === null || header === void 0 ? void 0 : header.trim()) || '',\n  transform: value => (value === null || value === void 0 ? void 0 : value.trim()) || '',\n  dynamicTyping: false,\n  // Keep everything as strings to avoid parsing issues\n  delimiter: ',',\n  quoteChar: '\"',\n  escapeChar: '\"'\n};\n\n/*\n Fetches and parses CSV data for a specific patient\n \n - @param {string} patientId - The patient identifier\n - @returns {Promise<Array>} Parsed CSV data as array of objects\n - @throws {Error} If CSV fetch or parsing fails\n */\nconst fetchPatientCsvData = async patientId => {\n  try {\n    // Use relative path for both dev and production (works with PUBLIC_URL)\n    const url = `${process.env.PUBLIC_URL}/synthetic_patients/${patientId}.csv?v=${Date.now()}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\n    }\n    const csvText = await response.text();\n    if (!csvText || csvText.trim().length === 0) {\n      throw new Error(`Empty CSV file for patient ${patientId}`);\n    }\n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    if (parsed.errors.length > 0) {\n      // Log parsing errors for debugging but don't throw (only in development)\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`CSV parsing warnings for ${patientId}:`, parsed.errors);\n      }\n    }\n    return parsed.data;\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    }\n    throw error;\n  }\n};\n\n/*\n Service class for handling patient data operations\n Provides methods for fetching and processing patient health data from CSV files\n */\n/*\n| Retrieves and processes all data for a specific patient\n| \n| @param {string} patientId - The patient identifier\n| @returns {Promise<Object>} Processed patient data including all health metrics\n| @throws {Error} If patient data cannot be retrieved or processed\n| */\nexport async function getPatientData(patientId) {\n  if (!patientId) {\n    throw new Error('Patient ID is required');\n  }\n  try {\n    const patientRows = await fetchPatientCsvData(patientId);\n    if (!Array.isArray(patientRows) || patientRows.length === 0) {\n      throw new Error(`No data found for patient ${patientId}`);\n    }\n    return processPatientData(patientRows, patientId);\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching patient data for ${patientId}:`, error);\n    }\n    throw error;\n  }\n}\n\n/**\n * Processes raw CSV data into structured patient information and health metrics\n * \n * - @param {Array} rows - Raw CSV data rows\n * - @param {string} patientId - The patient identifier\n * - @returns {Object} Structured patient data object\n * - @throws {Error} If data structure is invalid or processing fails\n */\nexport function processPatientData(rows, patientId) {\n  if (!Array.isArray(rows) || rows.length === 0) {\n    throw new Error(`Invalid data structure for patient ${patientId}`);\n  }\n  const firstRowData = rows[0];\n  if (!firstRowData) {\n    throw new Error(`No valid data rows found for patient ${patientId}`);\n  }\n  const patientInfo = {\n    patientId,\n    patientNumber: patientId,\n    name: firstRowData['Name'] || 'Not specified',\n    age: firstRowData['Age'] || 'Not specified',\n    gender: firstRowData['Gender'] || 'Not specified',\n    dataAvailable: 'May 2025'\n  };\n\n  // Process medications from the first row\n  const detailedMedications = [];\n  const medicationNamesStr = firstRowData['Medication_Names'] || '';\n  const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\n  if (medicationNamesStr && medicationDosagesStr) {\n    const medicationNames = medicationNamesStr.split('; ').filter(Boolean);\n    const medicationDosages = medicationDosagesStr.split('; ').filter(Boolean);\n\n    /**\n     * Validates if a medication name is valid for processing\n     * @param {string} name - The medication name to validate\n     * @returns {boolean} - True if the medication name is valid\n     */\n    function isValidMedicationName(name) {\n      if (name.length === 0 || name.length >= 100) return false;\n      if (name.includes('Dose not specified')) return false;\n      if (name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) return false;\n      return true;\n    }\n    medicationNames.forEach((medicationName, index) => {\n      var _medicationDosages$in;\n      const name = medicationName.trim();\n      const dosage = ((_medicationDosages$in = medicationDosages[index]) === null || _medicationDosages$in === void 0 ? void 0 : _medicationDosages$in.trim()) || '';\n      if (isValidMedicationName(name)) {\n        detailedMedications.push({\n          name: name,\n          schedule: dosage,\n          category: '',\n          dosage: ''\n        });\n      }\n    });\n  }\n\n  // Process conditions from all rows\n  const conditionsSet = new Set();\n  for (let i = 0; i < rows.length; i++) {\n    const conditionString = rows[i]['Chronic_Conditions'] || rows[i]['Conditions'] || '';\n    if (conditionString) {\n      const conditionList = conditionString.split(';');\n      for (let j = 0; j < conditionList.length; j++) {\n        const condition = conditionList[j].trim();\n        if (condition) {\n          conditionsSet.add(condition);\n        }\n      }\n    }\n  }\n\n  // Process all data types\n  const glucoseData = processGlucoseData(rows);\n  const bloodPressureData = processBloodPressureData(rows);\n  const exerciseData = processExerciseData(rows);\n  const moodData = processMoodData(rows);\n  const painData = processPainData(rows);\n  const sleepData = processSleepData(rows);\n  const mealData = processMealData(rows);\n  return {\n    patientInfo: {\n      ...patientInfo,\n      detailedMedications,\n      conditions: Array.from(conditionsSet)\n    },\n    glucoseData,\n    bloodPressureData,\n    exerciseData,\n    moodData,\n    painData,\n    mealData,\n    sleepData\n  };\n}\n\n// Helper functions for glucose data processing\nfunction parseTimeString(timeStr) {\n  if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {\n    return {\n      hours: 0,\n      minutes: 0\n    };\n  }\n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) {\n    return {\n      hours: 0,\n      minutes: 0\n    };\n  }\n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  return {\n    hours: isNaN(hours) ? 0 : hours,\n    minutes: isNaN(minutes) ? 0 : minutes\n  };\n}\nfunction createGlucoseReading(baseDate, value, timeStr, range, measurementType) {\n  const {\n    hours,\n    minutes\n  } = parseTimeString(timeStr);\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  return {\n    date: date,\n    value: value,\n    range: range,\n    measurementType: measurementType\n  };\n}\nfunction processMultiColumnGlucose(row, baseDate) {\n  const readings = [];\n  for (let i = 1; i <= 4; i++) {\n    const value = parseFloat(row[`Glucose_${i}`]);\n    const timeStr = row[`Glucose_Time_${i}`];\n    if (!isNaN(value) && value > 0 && timeStr && timeStr.trim() !== '') {\n      const reading = createGlucoseReading(baseDate, value, timeStr, row[`Glucose_Range_${i}`], row[`Glucose_Measurement_Type_${i}`]);\n      readings.push(reading);\n    }\n  }\n  return readings;\n}\nfunction processSingleColumnGlucose(row, baseDate) {\n  const value = parseFloat(row['Glucose_Level']);\n  if (!isNaN(value) && value > 0) {\n    const randomHour = Math.floor(Math.random() * 24);\n    const randomMinute = Math.floor(Math.random() * 60);\n    const date = new Date(baseDate);\n    date.setHours(randomHour, randomMinute);\n    let range = 'in range';\n    if (value < 70) range = 'below range';else if (value > 180) range = 'above range';\n    return [{\n      date: date,\n      value: value,\n      range: range,\n      measurementType: 'Random'\n    }];\n  }\n  return [];\n}\n\n/**\n * Processes blood glucose data from CSV rows\n */\nfunction processGlucoseData(rows) {\n  const readings = [];\n  rows.forEach(row => {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Glucose_1'] !== undefined;\n    if (hasMultiColumn) {\n      readings.push(...processMultiColumnGlucose(row, baseDate));\n    } else {\n      readings.push(...processSingleColumnGlucose(row, baseDate));\n    }\n  });\n  return readings;\n}\n\n/**\n * Creates a date with time from a base date and time string\n */\nfunction createDateWithTime(baseDate, timeStr) {\n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) return null;\n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  if (isNaN(hours) || isNaN(minutes)) return null;\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  return date;\n}\n\n/**\n * Determines BP type based on systolic and diastolic values\n */\nfunction getBPType(systolic, diastolic) {\n  if (systolic >= 180 || diastolic >= 120) return 'hypertensive crisis';\n  if (systolic >= 140 || diastolic >= 90) return 'high';\n  if (systolic >= 130 || diastolic >= 80) return 'elevated';\n  return 'normal';\n}\n\n/**\n * Processes a single BP reading from multi-column format\n */\nfunction processMultiColumnBPReading(row, index, baseDate) {\n  const systolic = parseInt(row[`Systolic_${index}`]);\n  const diastolic = parseInt(row[`Diastolic_${index}`]);\n  const timeStr = row[`BP_Time_${index}`];\n  const isValid = !isNaN(systolic) && !isNaN(diastolic) && systolic > 0 && diastolic > 0 && timeStr && timeStr.trim() !== '';\n  if (!isValid) return null;\n  const date = createDateWithTime(baseDate, timeStr);\n  if (!date) return null;\n  return {\n    date,\n    systolic,\n    diastolic,\n    systolicType: row[`Systolic_Type_${index}`],\n    diastolicType: row[`Diastolic_Type_${index}`]\n  };\n}\n\n/**\n * Processes a single BP reading from single-column format\n */\nfunction processSingleColumnBPReading(row, baseDate) {\n  const systolic = parseInt(row['Systolic_BP']);\n  const diastolic = parseInt(row['Diastolic_BP']);\n  if (isNaN(systolic) || isNaN(diastolic) || systolic <= 0 || diastolic <= 0) {\n    return null;\n  }\n\n  // Generate random time for single reading format\n  const randomHour = Math.floor(Math.random() * 24);\n  const randomMinute = Math.floor(Math.random() * 60);\n  const date = new Date(baseDate);\n  date.setHours(randomHour, randomMinute);\n  const bpType = getBPType(systolic, diastolic);\n  return {\n    date,\n    systolic,\n    diastolic,\n    systolicType: bpType,\n    diastolicType: bpType\n  };\n}\n\n/**\n * Processes blood pressure data from CSV rows\n */\nfunction processBloodPressureData(rows) {\n  const readings = [];\n  for (const row of rows) {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Systolic_1'] !== undefined;\n    if (hasMultiColumn) {\n      // Process up to 4 readings per day\n      for (let j = 1; j <= 4; j++) {\n        const reading = processMultiColumnBPReading(row, j, baseDate);\n        if (reading) readings.push(reading);\n      }\n    } else {\n      // Single reading format\n      const reading = processSingleColumnBPReading(row, baseDate);\n      if (reading) readings.push(reading);\n    }\n  }\n  return readings;\n}\n\n/**\n * Creates initial exercise data structure for a date\n */\nfunction createExerciseDayData(date) {\n  return {\n    date,\n    walking: 0,\n    swimming: 0,\n    running: 0,\n    biking: 0,\n    'muscle-strengthening': 0,\n    balance: 0,\n    other: 0,\n    totalMinutes: 0\n  };\n}\n\n/**\n * Processes a single exercise entry\n */\nfunction processExerciseEntry(row, index, dayData) {\n  var _row$typeKey;\n  const typeKey = index ? `Exercise_Type_${index}` : 'Exercise_Type';\n  const minutesKey = index ? `Exercise_Minutes_${index}` : 'Exercise_Minutes';\n  const type = (_row$typeKey = row[typeKey]) === null || _row$typeKey === void 0 ? void 0 : _row$typeKey.toLowerCase();\n  const minutes = parseFloat(row[minutesKey]);\n  if (type && type.trim() !== '' && !isNaN(minutes) && minutes > 0) {\n    categorizeExercise(type, minutes, dayData);\n  }\n}\n\n/**\n * Processes exercise data from CSV rows\n * \n * - @param {Array} rows - CSV data rows\n * - @returns {Array} Processed exercise data with activity types and durations\n */\nfunction processExerciseData(rows) {\n  const exerciseByDate = {};\n  for (const row of rows) {\n    const date = new Date(row['Date']);\n    const dateKey = date.toDateString();\n    if (!exerciseByDate[dateKey]) {\n      exerciseByDate[dateKey] = createExerciseDayData(date);\n    }\n    const dayData = exerciseByDate[dateKey];\n    const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\n    if (hasMultiColumn) {\n      // Process up to 5 exercise entries per day\n      for (let j = 1; j <= 5; j++) {\n        processExerciseEntry(row, j, dayData);\n      }\n    } else {\n      // Single exercise entry\n      processExerciseEntry(row, null, dayData);\n    }\n  }\n  return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n}\n\n/**\n * Categorizes exercise activities into predefined types\n * \n * - @param {string} type - Exercise type from CSV\n * - @param {number} minutes - Duration in minutes\n * - @param {Object} dayData - Daily exercise data object\n */\nfunction categorizeExercise(type, minutes, dayData) {\n  if (type.includes('walking')) dayData.walking += minutes;else if (type.includes('swimming')) dayData.swimming += minutes;else if (type.includes('running')) dayData.running += minutes;else if (type.includes('biking')) dayData.biking += minutes;else if (type.includes('muscle-strengthening') || type.includes('muscle strengthening') || type.includes('strength')) dayData['muscle-strengthening'] += minutes;else if (type.includes('balance')) dayData.balance += minutes;else dayData.other += minutes;\n  dayData.totalMinutes += minutes;\n}\n\n/**\n * Processes mood data from CSV rows\n */\nfunction processMoodData(rows) {\n  const moodData = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    if (row['Mood'] && row['Mood'].trim() !== '') {\n      moodData.push({\n        date: new Date(row['Date']),\n        mood: row['Mood'],\n        category: row['Mood'] || 'neutral'\n      });\n    }\n  }\n  return moodData;\n}\n\n/**\n * Processes pain data from CSV rows\n */\nfunction processPainData(rows) {\n  const painData = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    if (row['Pain_Location'] && row['Pain_Location'].trim() !== '' && row['Pain_Level'] !== undefined) {\n      const painLevel = parseInt(row['Pain_Level']);\n      if (!isNaN(painLevel)) {\n        painData.push({\n          date: new Date(row['Date']),\n          location: row['Pain_Location'].toLowerCase(),\n          level: painLevel\n        });\n      }\n    }\n  }\n  return painData;\n}\n\n/**\n * Processes sleep data from CSV rows\n */\nfunction processSleepData(rows) {\n  const sleepData = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    if (row['Sleep_Hours'] && row['Sleep_Quality']) {\n      const hours = parseFloat(row['Sleep_Hours']);\n      const qualityCode = parseInt(row['Sleep_Quality_Code']);\n      if (!isNaN(hours) && !isNaN(qualityCode)) {\n        sleepData.push({\n          date: new Date(row['Date']),\n          hours: hours,\n          quality: row['Sleep_Quality'],\n          qualityCode: qualityCode\n        });\n      }\n    }\n  }\n  return sleepData;\n}\n\n/**\n * Checks if a meal has any food components\n */\nfunction hasMealComponents(row, mealType) {\n  const components = [row[`${mealType}_Protein`], row[`${mealType}_Carbohydrates`], row[`${mealType}_Vegetables`], row[`${mealType}_Fruit`], row[`${mealType}_Alcohol`], row[`${mealType}_Added_Sugar`]];\n  return components.some(comp => comp === 1 || comp === '1' || comp && comp !== '' && comp !== 'NaN');\n}\n\n/**\n * Checks if a row has any meal data\n */\nfunction hasAnyMealData(row) {\n  const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\n  return mealTypes.some(mealType => {\n    const time = row[`${mealType}_Time`];\n    return time && hasMealComponents(row, mealType);\n  });\n}\n\n/**\n * Processes meal data from CSV rows - returns rows that have meal data\n */\nfunction processMealData(rows) {\n  return rows.filter(row => hasAnyMealData(row));\n}","map":{"version":3,"names":["Papa","CSV_CONFIG","header","skipEmptyLines","transformHeader","trim","transform","value","dynamicTyping","delimiter","quoteChar","escapeChar","fetchPatientCsvData","patientId","url","process","env","PUBLIC_URL","Date","now","response","fetch","ok","Error","status","statusText","csvText","text","length","parsed","parse","errors","NODE_ENV","console","warn","data","error","getPatientData","patientRows","Array","isArray","processPatientData","rows","firstRowData","patientInfo","patientNumber","name","age","gender","dataAvailable","detailedMedications","medicationNamesStr","medicationDosagesStr","medicationNames","split","filter","Boolean","medicationDosages","isValidMedicationName","includes","forEach","medicationName","index","_medicationDosages$in","dosage","push","schedule","category","conditionsSet","Set","i","conditionString","conditionList","j","condition","add","glucoseData","processGlucoseData","bloodPressureData","processBloodPressureData","exerciseData","processExerciseData","moodData","processMoodData","painData","processPainData","sleepData","processSleepData","mealData","processMealData","conditions","from","parseTimeString","timeStr","hours","minutes","timeParts","parseInt","isNaN","createGlucoseReading","baseDate","range","measurementType","date","setHours","processMultiColumnGlucose","row","readings","parseFloat","reading","processSingleColumnGlucose","randomHour","Math","floor","random","randomMinute","hasMultiColumn","undefined","createDateWithTime","getBPType","systolic","diastolic","processMultiColumnBPReading","isValid","systolicType","diastolicType","processSingleColumnBPReading","bpType","createExerciseDayData","walking","swimming","running","biking","balance","other","totalMinutes","processExerciseEntry","dayData","_row$typeKey","typeKey","minutesKey","type","toLowerCase","categorizeExercise","exerciseByDate","dateKey","toDateString","Object","values","d","mood","painLevel","location","level","qualityCode","quality","hasMealComponents","mealType","components","some","comp","hasAnyMealData","mealTypes","time"],"sources":["C:/Users/Matteo/Working_Folder/a. MCC Thesis Local Experimental/PGHD_Visualization_Dashboard/src/services/dataService.js"],"sourcesContent":["/*\n dataService.js - Patient Data Service\n \n This service handles all data operations for the health dashboard:\n - Fetches patient CSV data from the server\n - Parses and processes CSV data using PapaParse\n - Transforms raw data into structured health metrics\n - Provides data validation and error handling\n - Manages patient information, medications, and health tracking data\n - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\n \n Architecture:\n - Uses PapaParse library for CSV parsing\n - Implements service class pattern for data operations\n - Provides comprehensive error handling and validation\n - Supports multiple data formats and structures\n \n Data Processing:\n - CSV parsing with header validation\n - Data transformation and normalization\n - Type conversion and validation\n - Error recovery and fallback mechanisms\n \n Health Metrics Supported:\n - Blood glucose monitoring with meal context\n - Blood pressure tracking with risk categorization\n - Exercise activity tracking and categorization\n - Mood assessment and tracking\n - Pain reporting with anatomical mapping\n - Sleep quality and duration analysis\n - Nutritional intake and meal composition\n \n Error Handling:\n - Network error recovery\n - CSV parsing error handling\n - Data validation and sanitization\n - Graceful degradation for missing data\n \n Core service for data management and processing throughout the application.\n */\n\nimport Papa from 'papaparse';\n\n// Configuration for CSV parsing\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: (header) => header?.trim() || '',\n  transform: (value) => value?.trim() || '',\n  dynamicTyping: false, // Keep everything as strings to avoid parsing issues\n  delimiter: ',',\n  quoteChar: '\"',\n  escapeChar: '\"'\n};\n\n/*\n Fetches and parses CSV data for a specific patient\n \n - @param {string} patientId - The patient identifier\n - @returns {Promise<Array>} Parsed CSV data as array of objects\n - @throws {Error} If CSV fetch or parsing fails\n */\nconst fetchPatientCsvData = async (patientId) => {\n  try {\n    // Use relative path for both dev and production (works with PUBLIC_URL)\n    const url = `${process.env.PUBLIC_URL}/synthetic_patients/${patientId}.csv?v=${Date.now()}`;\n    const response = await fetch(url);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\n    }\n    \n    const csvText = await response.text();\n    \n    if (!csvText || csvText.trim().length === 0) {\n      throw new Error(`Empty CSV file for patient ${patientId}`);\n    }\n    \n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    \n    if (parsed.errors.length > 0) {\n      // Log parsing errors for debugging but don't throw (only in development)\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`CSV parsing warnings for ${patientId}:`, parsed.errors);\n      }\n    }\n    \n    return parsed.data;\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    }\n    throw error;\n  }\n};\n\n/*\n Service class for handling patient data operations\n Provides methods for fetching and processing patient health data from CSV files\n */\n/*\n| Retrieves and processes all data for a specific patient\n| \n| @param {string} patientId - The patient identifier\n| @returns {Promise<Object>} Processed patient data including all health metrics\n| @throws {Error} If patient data cannot be retrieved or processed\n| */\nexport async function getPatientData(patientId) {\n  if (!patientId) {\n    throw new Error('Patient ID is required');\n  }\n\n  try {\n    const patientRows = await fetchPatientCsvData(patientId);\n\n    if (!Array.isArray(patientRows) || patientRows.length === 0) {\n      throw new Error(`No data found for patient ${patientId}`);\n    }\n\n    return processPatientData(patientRows, patientId);\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching patient data for ${patientId}:`, error);\n    }\n    throw error;\n  }\n}\n\n/**\n * Processes raw CSV data into structured patient information and health metrics\n * \n * - @param {Array} rows - Raw CSV data rows\n * - @param {string} patientId - The patient identifier\n * - @returns {Object} Structured patient data object\n * - @throws {Error} If data structure is invalid or processing fails\n */\nexport function processPatientData(rows, patientId) {\n  if (!Array.isArray(rows) || rows.length === 0) {\n    throw new Error(`Invalid data structure for patient ${patientId}`);\n  }\n\n  const firstRowData = rows[0];\n  if (!firstRowData) {\n    throw new Error(`No valid data rows found for patient ${patientId}`);\n  }\n\n  const patientInfo = {\n    patientId,\n    patientNumber: patientId,\n    name: firstRowData['Name'] || 'Not specified',\n    age: firstRowData['Age'] || 'Not specified',\n    gender: firstRowData['Gender'] || 'Not specified',\n    dataAvailable: 'May 2025'\n  };\n\n  // Process medications from the first row\n  const detailedMedications = [];\n  const medicationNamesStr = firstRowData['Medication_Names'] || '';\n  const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\n  \n  if (medicationNamesStr && medicationDosagesStr) {\n    const medicationNames = medicationNamesStr.split('; ').filter(Boolean);\n    const medicationDosages = medicationDosagesStr.split('; ').filter(Boolean);\n    \n    /**\n     * Validates if a medication name is valid for processing\n     * @param {string} name - The medication name to validate\n     * @returns {boolean} - True if the medication name is valid\n     */\n    function isValidMedicationName(name) {\n      if (name.length === 0 || name.length >= 100) return false;\n      if (name.includes('Dose not specified')) return false;\n      if (name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) return false;\n      return true;\n    }\n    \n    medicationNames.forEach((medicationName, index) => {\n      const name = medicationName.trim();\n      const dosage = medicationDosages[index]?.trim() || '';\n      \n      if (isValidMedicationName(name)) {\n        detailedMedications.push({\n          name: name,\n          schedule: dosage,\n          category: '',\n          dosage: ''\n        });\n      }\n    });\n  }\n\n  // Process conditions from all rows\n  const conditionsSet = new Set();\n  for (let i = 0; i < rows.length; i++) {\n    const conditionString = rows[i]['Chronic_Conditions'] || rows[i]['Conditions'] || '';\n    if (conditionString) {\n      const conditionList = conditionString.split(';');\n      for (let j = 0; j < conditionList.length; j++) {\n        const condition = conditionList[j].trim();\n        if (condition) {\n          conditionsSet.add(condition);\n        }\n      }\n    }\n  }\n\n  // Process all data types\n  const glucoseData = processGlucoseData(rows);\n  const bloodPressureData = processBloodPressureData(rows);\n  const exerciseData = processExerciseData(rows);\n  const moodData = processMoodData(rows);\n  const painData = processPainData(rows);\n  const sleepData = processSleepData(rows);\n  const mealData = processMealData(rows);\n\n  return {\n    patientInfo: { \n      ...patientInfo, \n      detailedMedications, \n      conditions: Array.from(conditionsSet)\n    },\n    glucoseData,\n    bloodPressureData,\n    exerciseData,\n    moodData,\n    painData,\n    mealData,\n    sleepData\n  };\n}\n\n// Helper functions for glucose data processing\nfunction parseTimeString(timeStr) {\n  if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {\n    return { hours: 0, minutes: 0 };\n  }\n  \n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) {\n    return { hours: 0, minutes: 0 };\n  }\n  \n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  \n  return {\n    hours: isNaN(hours) ? 0 : hours,\n    minutes: isNaN(minutes) ? 0 : minutes\n  };\n}\n\nfunction createGlucoseReading(baseDate, value, timeStr, range, measurementType) {\n  const { hours, minutes } = parseTimeString(timeStr);\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  \n  return {\n    date: date,\n    value: value,\n    range: range,\n    measurementType: measurementType\n  };\n}\n\nfunction processMultiColumnGlucose(row, baseDate) {\n  const readings = [];\n  \n  for (let i = 1; i <= 4; i++) {\n    const value = parseFloat(row[`Glucose_${i}`]);\n    const timeStr = row[`Glucose_Time_${i}`];\n    \n    if (!isNaN(value) && value > 0 && timeStr && timeStr.trim() !== '') {\n      const reading = createGlucoseReading(\n        baseDate,\n        value,\n        timeStr,\n        row[`Glucose_Range_${i}`],\n        row[`Glucose_Measurement_Type_${i}`]\n      );\n      readings.push(reading);\n    }\n  }\n  \n  return readings;\n}\n\nfunction processSingleColumnGlucose(row, baseDate) {\n  const value = parseFloat(row['Glucose_Level']);\n  if (!isNaN(value) && value > 0) {\n    const randomHour = Math.floor(Math.random() * 24);\n    const randomMinute = Math.floor(Math.random() * 60);\n    const date = new Date(baseDate);\n    date.setHours(randomHour, randomMinute);\n    \n    let range = 'in range';\n    if (value < 70) range = 'below range';\n    else if (value > 180) range = 'above range';\n    \n    return [{\n      date: date,\n      value: value,\n      range: range,\n      measurementType: 'Random'\n    }];\n  }\n  return [];\n}\n\n/**\n * Processes blood glucose data from CSV rows\n */\nfunction processGlucoseData(rows) {\n  const readings = [];\n  \n  rows.forEach(row => {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Glucose_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      readings.push(...processMultiColumnGlucose(row, baseDate));\n    } else {\n      readings.push(...processSingleColumnGlucose(row, baseDate));\n    }\n  });\n  \n  return readings;\n}\n\n/**\n * Creates a date with time from a base date and time string\n */\nfunction createDateWithTime(baseDate, timeStr) {\n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) return null;\n  \n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  \n  if (isNaN(hours) || isNaN(minutes)) return null;\n  \n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  return date;\n}\n\n/**\n * Determines BP type based on systolic and diastolic values\n */\nfunction getBPType(systolic, diastolic) {\n  if (systolic >= 180 || diastolic >= 120) return 'hypertensive crisis';\n  if (systolic >= 140 || diastolic >= 90) return 'high';\n  if (systolic >= 130 || diastolic >= 80) return 'elevated';\n  return 'normal';\n}\n\n/**\n * Processes a single BP reading from multi-column format\n */\nfunction processMultiColumnBPReading(row, index, baseDate) {\n  const systolic = parseInt(row[`Systolic_${index}`]);\n  const diastolic = parseInt(row[`Diastolic_${index}`]);\n  const timeStr = row[`BP_Time_${index}`];\n  \n  const isValid = !isNaN(systolic) && !isNaN(diastolic) && \n                  systolic > 0 && diastolic > 0 && \n                  timeStr && timeStr.trim() !== '';\n  \n  if (!isValid) return null;\n  \n  const date = createDateWithTime(baseDate, timeStr);\n  if (!date) return null;\n  \n  return {\n    date,\n    systolic,\n    diastolic,\n    systolicType: row[`Systolic_Type_${index}`],\n    diastolicType: row[`Diastolic_Type_${index}`]\n  };\n}\n\n/**\n * Processes a single BP reading from single-column format\n */\nfunction processSingleColumnBPReading(row, baseDate) {\n  const systolic = parseInt(row['Systolic_BP']);\n  const diastolic = parseInt(row['Diastolic_BP']);\n  \n  if (isNaN(systolic) || isNaN(diastolic) || systolic <= 0 || diastolic <= 0) {\n    return null;\n  }\n  \n  // Generate random time for single reading format\n  const randomHour = Math.floor(Math.random() * 24);\n  const randomMinute = Math.floor(Math.random() * 60);\n  const date = new Date(baseDate);\n  date.setHours(randomHour, randomMinute);\n  \n  const bpType = getBPType(systolic, diastolic);\n  \n  return {\n    date,\n    systolic,\n    diastolic,\n    systolicType: bpType,\n    diastolicType: bpType\n  };\n}\n\n/**\n * Processes blood pressure data from CSV rows\n */\nfunction processBloodPressureData(rows) {\n  const readings = [];\n  \n  for (const row of rows) {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Systolic_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      // Process up to 4 readings per day\n      for (let j = 1; j <= 4; j++) {\n        const reading = processMultiColumnBPReading(row, j, baseDate);\n        if (reading) readings.push(reading);\n      }\n    } else {\n      // Single reading format\n      const reading = processSingleColumnBPReading(row, baseDate);\n      if (reading) readings.push(reading);\n    }\n  }\n  \n  return readings;\n}\n\n/**\n * Creates initial exercise data structure for a date\n */\nfunction createExerciseDayData(date) {\n  return {\n    date,\n    walking: 0,\n    swimming: 0,\n    running: 0,\n    biking: 0,\n    'muscle-strengthening': 0,\n    balance: 0,\n    other: 0,\n    totalMinutes: 0\n  };\n}\n\n/**\n * Processes a single exercise entry\n */\nfunction processExerciseEntry(row, index, dayData) {\n  const typeKey = index ? `Exercise_Type_${index}` : 'Exercise_Type';\n  const minutesKey = index ? `Exercise_Minutes_${index}` : 'Exercise_Minutes';\n  \n  const type = row[typeKey]?.toLowerCase();\n  const minutes = parseFloat(row[minutesKey]);\n  \n  if (type && type.trim() !== '' && !isNaN(minutes) && minutes > 0) {\n    categorizeExercise(type, minutes, dayData);\n  }\n}\n\n/**\n * Processes exercise data from CSV rows\n * \n * - @param {Array} rows - CSV data rows\n * - @returns {Array} Processed exercise data with activity types and durations\n */\nfunction processExerciseData(rows) {\n  const exerciseByDate = {};\n  \n  for (const row of rows) {\n    const date = new Date(row['Date']);\n    const dateKey = date.toDateString();\n    \n    if (!exerciseByDate[dateKey]) {\n      exerciseByDate[dateKey] = createExerciseDayData(date);\n    }\n    \n    const dayData = exerciseByDate[dateKey];\n    const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      // Process up to 5 exercise entries per day\n      for (let j = 1; j <= 5; j++) {\n        processExerciseEntry(row, j, dayData);\n      }\n    } else {\n      // Single exercise entry\n      processExerciseEntry(row, null, dayData);\n    }\n  }\n  \n  return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n}\n\n/**\n * Categorizes exercise activities into predefined types\n * \n * - @param {string} type - Exercise type from CSV\n * - @param {number} minutes - Duration in minutes\n * - @param {Object} dayData - Daily exercise data object\n */\nfunction categorizeExercise(type, minutes, dayData) {\n  if (type.includes('walking')) dayData.walking += minutes;\n    else if (type.includes('swimming')) dayData.swimming += minutes;\n    else if (type.includes('running')) dayData.running += minutes;\n    else if (type.includes('biking')) dayData.biking += minutes;\n    else if (type.includes('muscle-strengthening') || type.includes('muscle strengthening') || type.includes('strength')) dayData['muscle-strengthening'] += minutes;\n    else if (type.includes('balance')) dayData.balance += minutes;\n  else dayData.other += minutes;\n  dayData.totalMinutes += minutes;\n}\n\n/**\n * Processes mood data from CSV rows\n */\nfunction processMoodData(rows) {\n  const moodData = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (row['Mood'] && row['Mood'].trim() !== '') {\n        moodData.push({\n          date: new Date(row['Date']),\n          mood: row['Mood'],\n          category: row['Mood'] || 'neutral'\n        });\n      }\n    }\n  \n  return moodData;\n}\n\n/**\n * Processes pain data from CSV rows\n */\nfunction processPainData(rows) {\n  const painData = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (row['Pain_Location'] && row['Pain_Location'].trim() !== '' && row['Pain_Level'] !== undefined) {\n        const painLevel = parseInt(row['Pain_Level']);\n        if (!isNaN(painLevel)) {\n          painData.push({\n            date: new Date(row['Date']),\n            location: row['Pain_Location'].toLowerCase(),\n            level: painLevel\n          });\n        }\n      }\n    }\n  \n  return painData;\n}\n\n/**\n * Processes sleep data from CSV rows\n */\nfunction processSleepData(rows) {\n  const sleepData = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (row['Sleep_Hours'] && row['Sleep_Quality']) {\n        const hours = parseFloat(row['Sleep_Hours']);\n        const qualityCode = parseInt(row['Sleep_Quality_Code']);\n        if (!isNaN(hours) && !isNaN(qualityCode)) {\n          sleepData.push({\n            date: new Date(row['Date']),\n            hours: hours,\n            quality: row['Sleep_Quality'],\n            qualityCode: qualityCode\n          });\n        }\n      }\n    }\n  \n  return sleepData;\n}\n\n/**\n * Checks if a meal has any food components\n */\nfunction hasMealComponents(row, mealType) {\n  const components = [\n    row[`${mealType}_Protein`],\n    row[`${mealType}_Carbohydrates`],\n    row[`${mealType}_Vegetables`],\n    row[`${mealType}_Fruit`],\n    row[`${mealType}_Alcohol`],\n    row[`${mealType}_Added_Sugar`]\n  ];\n  \n  return components.some(comp => \n    comp === 1 || comp === '1' || (comp && comp !== '' && comp !== 'NaN')\n  );\n}\n\n/**\n * Checks if a row has any meal data\n */\nfunction hasAnyMealData(row) {\n  const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\n  \n  return mealTypes.some(mealType => {\n    const time = row[`${mealType}_Time`];\n    return time && hasMealComponents(row, mealType);\n  });\n}\n\n/**\n * Processes meal data from CSV rows - returns rows that have meal data\n */\nfunction processMealData(rows) {\n  return rows.filter(row => hasAnyMealData(row));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}