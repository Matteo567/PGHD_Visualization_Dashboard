{"ast":null,"code":"import Papa from 'papaparse';\n\n// Constants\nconst CACHE_EXPIRY = 5 * 60 * 1000; // 5 minutes\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: header => header.trim(),\n  transform: value => value === null || value === void 0 ? void 0 : value.trim(),\n  duplicateHeaders: false\n};\nconst patientDataCache = new Map();\n\n// Function to fetch and parse the main CSV file.\nconst fetchAllCsvData = async () => {\n  try {\n    const response = await fetch(`/synthetic_patients_all.csv?v=${Date.now()}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV data: ${response.statusText}`);\n    }\n    const csvText = await response.text();\n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    if (parsed.errors.length > 0) {\n      console.warn('CSV parsing warnings:', parsed.errors);\n    }\n    return parsed.data;\n  } catch (error) {\n    console.error('Error fetching or parsing CSV data:', error);\n    throw error;\n  }\n};\nclass DataService {\n  static async getPatientData(patientId) {\n    const cacheKey = `${patientId}_v13`; // Increment to force cache refresh\n    const cached = patientDataCache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < CACHE_EXPIRY) {\n      return cached.data;\n    }\n    try {\n      const allData = await fetchAllCsvData();\n\n      // Extract numeric part from patientId (e.g., \"Patient_001\" -> \"001\")\n      const numericPatientId = patientId.replace('Patient_', '');\n\n      // Filter data for the specific patient\n      const patientRows = allData.filter(row => row['Patient_ID'] === numericPatientId);\n      if (patientRows.length === 0) {\n        throw new Error(`No data found for patient ${patientId}`);\n      }\n\n      // Process and structure the data\n      const processedData = this.processPatientData(patientRows, patientId);\n\n      // Cache the processed data\n      patientDataCache.set(cacheKey, {\n        data: processedData,\n        timestamp: Date.now()\n      });\n      return processedData;\n    } catch (error) {\n      console.error('Error fetching patient data:', error);\n      throw error;\n    }\n  }\n  static processPatientData(rows, patientId) {\n    const firstRow = rows[0];\n\n    // Extract basic patient info\n    // Since CSV parsing has issues with Gender column due to complex medication strings,\n    // we'll generate gender based on patient ID as a temporary solution\n    const generateGender = patientId => {\n      const numericId = parseInt(patientId.replace('Patient_', ''));\n      // Use patient ID to consistently assign gender (slight female bias as in original Python script)\n      return numericId % 3 === 0 ? 'Male' : 'Female';\n    };\n    const patientInfo = {\n      patientId,\n      patientNumber: patientId,\n      age: firstRow['Age'],\n      gender: generateGender(patientId),\n      dataAvailable: 'May 2025'\n    };\n\n    // Process medications with detailed information\n    const medicationsRaw = [...new Set(rows.map(row => row['Medications']).filter(med => med && med.trim()))];\n    const detailedMedications = [];\n    const conditionsSet = new Set();\n    medicationsRaw.forEach(medString => {\n      if (medString) {\n        const meds = medString.split('; ');\n        meds.forEach(med => {\n          const lastParenIndex = med.lastIndexOf('(');\n          if (lastParenIndex === -1) return;\n          const medName = med.substring(0, lastParenIndex).trim();\n          if (medName && !detailedMedications.some(m => m.name === medName)) {\n            const detailsStr = med.substring(lastParenIndex + 1, med.length - 1);\n            const details = detailsStr.split(',').map(d => d.trim());\n            const schedule = details[0] || 'Not specified';\n            const category = details[1] || '';\n            const dosage = details.slice(2).join(', ') || '';\n            detailedMedications.push({\n              name: medName,\n              schedule: schedule,\n              category: category,\n              dosage: dosage\n            });\n          }\n        });\n      }\n    });\n\n    // Also check for direct chronic conditions column\n    const chronicConditionsRaw = [...new Set(rows.map(row => row['Chronic_Conditions']).filter(condition => condition && condition.trim()))];\n    chronicConditionsRaw.forEach(conditionString => {\n      if (conditionString) {\n        const conditions = conditionString.split(',').map(c => c.trim());\n        conditions.forEach(condition => {\n          if (condition) {\n            conditionsSet.add(condition);\n          }\n        });\n      }\n    });\n    const conditions = Array.from(conditionsSet);\n\n    // Process glucose data - use CSV data if available, otherwise generate realistic data\n    const glucoseData = rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const readings = [];\n\n      // Check if we have glucose data in CSV\n      const hasGlucoseData = row['Glucose_1'] !== undefined;\n      if (hasGlucoseData) {\n        // Process CSV glucose data (Glucose_1-4)\n        for (let i = 1; i <= 4; i++) {\n          const glucoseValue = parseFloat(row[`Glucose_${i}`]);\n          const measurementType = row[`Glucose_Measurement_Type_${i}`];\n          const range = row[`Glucose_Range_${i}`];\n          const timeStr = row[`Glucose_Time_${i}`];\n          if (!isNaN(glucoseValue) && glucoseValue > 0) {\n            let readingDate = new Date(baseDate);\n\n            // Parse time if available\n            if (timeStr && timeStr.includes(':')) {\n              const [hours, minutes] = timeStr.split(':').map(Number);\n              readingDate.setHours(hours, minutes, 0, 0);\n            } else {\n              // Fallback to simulated times\n              const hour = 7 + Math.floor(Math.random() * 13); // 7am to 8pm\n              const minute = Math.floor(Math.random() * 60);\n              readingDate.setHours(hour, minute, 0, 0);\n            }\n            readings.push({\n              date: readingDate,\n              value: glucoseValue,\n              range: range || 'Normal',\n              measurementType: measurementType || 'Pre meal'\n            });\n          }\n        }\n      } else {\n        // Generate realistic data for patients without CSV glucose data\n        const patientNum = parseInt(patientId.replace('Patient_', '')) || parseInt(patientId);\n        const isDiabetic = patientNum % 3 === 2; // Every 3rd patient starting with 2 has diabetes\n\n        let baseGlucose;\n        if (isDiabetic) {\n          // Diabetic patient: higher, more variable glucose (6-15 mmol/L)\n          baseGlucose = 7.0 + Math.random() * 8.0;\n        } else {\n          // Non-diabetic patient: normal glucose (4-7 mmol/L)\n          baseGlucose = 4.5 + Math.random() * 2.5;\n        }\n\n        // Create 2-4 readings per day with simulated timestamps\n        const numReadings = Math.floor(Math.random() * 3) + 2; // 2-4 readings\n\n        for (let i = 0; i < numReadings; i++) {\n          // Generate realistic glucose measurement times\n          let hour, measurementType;\n          if (i === 0) {\n            // Fasting/morning reading (6-8am)\n            hour = 6 + Math.floor(Math.random() * 2);\n            measurementType = 'Pre meal';\n          } else if (i === 1) {\n            // Pre-lunch reading (11am-12pm)\n            hour = 11 + Math.floor(Math.random() * 1);\n            measurementType = 'Pre meal';\n          } else if (i === 2) {\n            // Post-meal reading (1-3pm)\n            hour = 13 + Math.floor(Math.random() * 2);\n            measurementType = '2-hour post meal';\n          } else {\n            // Evening reading (6-8pm)\n            hour = 18 + Math.floor(Math.random() * 2);\n            measurementType = Math.random() > 0.5 ? 'Pre meal' : '2-hour post meal';\n          }\n          const minute = Math.floor(Math.random() * 60);\n          const readingDate = new Date(baseDate);\n          readingDate.setHours(hour, minute, 0, 0);\n\n          // Add realistic variation based on measurement type\n          let glucoseValue;\n          if (measurementType === 'Pre meal') {\n            // Pre-meal: slight variation around base value\n            const variation = (Math.random() - 0.5) * 2;\n            glucoseValue = Math.max(3.0, Math.min(15.0, baseGlucose + variation));\n          } else {\n            // Post-meal: typically higher\n            const variation = (Math.random() - 0.5) * 3 + 2;\n            glucoseValue = Math.max(4.0, Math.min(20.0, baseGlucose + variation));\n          }\n\n          // Determine range based on value and type\n          let range;\n          if (measurementType === 'Pre meal') {\n            if (glucoseValue < 4.0) range = 'Low';else if (glucoseValue <= 7.0) range = 'Normal';else range = 'High';\n          } else {\n            if (glucoseValue < 4.0) range = 'Low';else if (glucoseValue <= 10.0) range = 'Normal';else range = 'High';\n          }\n          readings.push({\n            date: readingDate,\n            value: Math.round(glucoseValue * 10) / 10,\n            // Round to 1 decimal\n            range: range,\n            measurementType: measurementType\n          });\n        }\n      }\n      return readings;\n    });\n\n    // Process blood pressure data - robust handling of both new and old CSV structures\n\n    const bloodPressureData = rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const readings = [];\n\n      // Check if we have new multi-column structure\n      const hasNewStructure = row['Systolic_1'] !== undefined;\n      if (hasNewStructure) {\n        // Process new multi-column structure (Systolic_1-4, Diastolic_1-4)\n        for (let i = 1; i <= 4; i++) {\n          const systolic = parseInt(row[`Systolic_${i}`]);\n          const diastolic = parseInt(row[`Diastolic_${i}`]);\n          const bpTime = row[`BP_Time_${i}`];\n          const systolicType = row[`Systolic_Type_${i}`];\n          const diastolicType = row[`Diastolic_Type_${i}`];\n          if (!isNaN(systolic) && !isNaN(diastolic) && systolic > 0 && diastolic > 0) {\n            let readingDate = new Date(baseDate);\n\n            // Parse time if available, otherwise use simulated time\n            if (bpTime && bpTime.includes(':')) {\n              const [hours, minutes] = bpTime.split(':').map(Number);\n              readingDate.setHours(hours, minutes, 0, 0);\n            } else {\n              // Fallback to simulated times\n              const hour = 7 + Math.floor(Math.random() * 13); // 7am to 8pm\n              const minute = Math.floor(Math.random() * 60);\n              readingDate.setHours(hour, minute, 0, 0);\n            }\n            readings.push({\n              date: readingDate,\n              systolic: systolic,\n              diastolic: diastolic,\n              systolicType: systolicType || 'Normal',\n              diastolicType: diastolicType || 'Normal'\n            });\n          }\n        }\n      } else if (row['Systolic'] && row['Diastolic']) {\n        // Process old single column structure\n        const systolic = parseInt(row['Systolic']);\n        const diastolic = parseInt(row['Diastolic']);\n        if (!isNaN(systolic) && !isNaN(diastolic)) {\n          // Create 2-3 readings per day with simulated timestamps\n          const numReadings = Math.floor(Math.random() * 2) + 2; // 2-3 readings\n\n          for (let i = 0; i < numReadings; i++) {\n            // Generate realistic times: morning (7-10), afternoon (12-15), evening (17-20)\n            let hour;\n            if (i === 0) hour = 7 + Math.floor(Math.random() * 3); // Morning\n            else if (i === 1) hour = 12 + Math.floor(Math.random() * 3); // Afternoon  \n            else hour = 17 + Math.floor(Math.random() * 3); // Evening\n\n            const minute = Math.floor(Math.random() * 60);\n            const readingDate = new Date(baseDate);\n            readingDate.setHours(hour, minute, 0, 0);\n\n            // Add some variation to readings\n            const variation = (Math.random() - 0.5) * 10;\n            readings.push({\n              date: readingDate,\n              systolic: Math.max(80, Math.min(200, systolic + Math.floor(variation))),\n              diastolic: Math.max(50, Math.min(120, diastolic + Math.floor(variation / 2))),\n              systolicType: row['Systolic_Type'] || 'Normal',\n              diastolicType: row['Diastolic_Type'] || 'Normal'\n            });\n          }\n        }\n      }\n      return readings;\n    });\n\n    // Process exercise data - robust handling of both new and old CSV structures\n    const exerciseByDate = {};\n\n    // Check if we have new multi-column structure\n    const hasNewExerciseStructure = rows[0] && rows[0]['Exercise_Type_1'] !== undefined;\n    rows.forEach(row => {\n      const date = new Date(row['Date']);\n      const dateKey = date.toDateString();\n      if (!exerciseByDate[dateKey]) {\n        exerciseByDate[dateKey] = {\n          date: date,\n          walking: 0,\n          aerobic: 0,\n          strength: 0,\n          balance: 0,\n          other: 0,\n          totalMinutes: 0\n        };\n      }\n      if (hasNewExerciseStructure) {\n        // Process new multi-column structure (Exercise_Type_1-3, Exercise_Minutes_1-3)\n        for (let i = 1; i <= 3; i++) {\n          const exerciseType = row[`Exercise_Type_${i}`];\n          const exerciseMinutesRaw = row[`Exercise_Minutes_${i}`];\n          const exerciseMinutes = parseFloat(exerciseMinutesRaw);\n          if (exerciseType && exerciseType.trim() && !isNaN(exerciseMinutes) && exerciseMinutes > 0) {\n            const normalizedType = exerciseType.toLowerCase();\n\n            // Map exercise types to chart categories\n            if (normalizedType.includes('walking')) {\n              exerciseByDate[dateKey].walking += exerciseMinutes;\n            } else if (normalizedType.includes('aerobic')) {\n              exerciseByDate[dateKey].aerobic += exerciseMinutes;\n            } else if (normalizedType.includes('strength')) {\n              exerciseByDate[dateKey].strength += exerciseMinutes;\n            } else if (normalizedType.includes('balance')) {\n              exerciseByDate[dateKey].balance += exerciseMinutes;\n            } else {\n              exerciseByDate[dateKey].other += exerciseMinutes;\n            }\n            exerciseByDate[dateKey].totalMinutes += exerciseMinutes;\n          }\n        }\n      } else if (row['Exercise_Type'] && row['Exercise_Minutes']) {\n        // Process old single column structure\n        const exerciseType = row['Exercise_Type'];\n        const exerciseMinutesRaw = row['Exercise_Minutes'];\n        const exerciseMinutes = parseFloat(exerciseMinutesRaw);\n        if (exerciseType && exerciseType.trim() && !isNaN(exerciseMinutes) && exerciseMinutes > 0) {\n          const normalizedType = exerciseType.toLowerCase();\n\n          // Map exercise types to chart categories\n          if (normalizedType.includes('walking')) {\n            exerciseByDate[dateKey].walking += exerciseMinutes;\n          } else if (normalizedType.includes('aerobic')) {\n            exerciseByDate[dateKey].aerobic += exerciseMinutes;\n          } else if (normalizedType.includes('strength')) {\n            exerciseByDate[dateKey].strength += exerciseMinutes;\n          } else if (normalizedType.includes('balance')) {\n            exerciseByDate[dateKey].balance += exerciseMinutes;\n          } else {\n            exerciseByDate[dateKey].other += exerciseMinutes;\n          }\n          exerciseByDate[dateKey].totalMinutes += exerciseMinutes;\n        }\n      }\n    });\n    const exerciseData = Object.values(exerciseByDate).filter(day => day.totalMinutes > 0);\n\n    // Process mood data\n    const moodData = rows.filter(row => row['Mood']).map(row => ({\n      date: new Date(row['Date']),\n      mood: row['Mood'],\n      category: row['Mood'] || 'neutral'\n    }));\n\n    // Process pain data\n    const painData = rows.filter(row => row['Pain_Location'] && row['Pain_Level'] !== undefined).map(row => ({\n      date: new Date(row['Date']),\n      location: row['Pain_Location'].toLowerCase(),\n      level: parseInt(row['Pain_Level']) || 0\n    }));\n\n    // Process sleep data\n    const sleepData = rows.filter(row => row['Sleep_Hours'] && row['Sleep_Quality']).map(row => ({\n      date: new Date(row['Date']),\n      hours: parseFloat(row['Sleep_Hours']),\n      quality: row['Sleep_Quality'],\n      qualityCode: parseInt(row['Sleep_Quality_Code'])\n    }));\n\n    // Process meal data\n    const mealData = rows.map(row => ({\n      Date: row['Date'],\n      Breakfast_Protein: row['Breakfast_Protein'],\n      Breakfast_Vegetables: row['Breakfast_Vegetables'],\n      Breakfast_Fruit: row['Breakfast_Fruit'],\n      Breakfast_Alcohol: row['Breakfast_Alcohol'],\n      Breakfast_Carbohydrates: row['Breakfast_Carbohydrates'],\n      Breakfast_Added_Sugar: row['Breakfast_Added_Sugar'],\n      Lunch_Protein: row['Lunch_Protein'],\n      Lunch_Vegetables: row['Lunch_Vegetables'],\n      Lunch_Fruit: row['Lunch_Fruit'],\n      Lunch_Alcohol: row['Lunch_Alcohol'],\n      Lunch_Carbohydrates: row['Lunch_Carbohydrates'],\n      Lunch_Added_Sugar: row['Lunch_Added_Sugar'],\n      Dinner_Protein: row['Dinner_Protein'],\n      Dinner_Vegetables: row['Dinner_Vegetables'],\n      Dinner_Fruit: row['Dinner_Fruit'],\n      Dinner_Alcohol: row['Dinner_Alcohol'],\n      Dinner_Carbohydrates: row['Dinner_Carbohydrates'],\n      Dinner_Added_Sugar: row['Dinner_Added_Sugar'],\n      Breakfast_Time: row['Breakfast_Time'],\n      Lunch_Time: row['Lunch_Time'],\n      Dinner_Time: row['Dinner_Time']\n    }));\n    return {\n      patientInfo: {\n        ...patientInfo,\n        detailedMedications,\n        conditions\n      },\n      glucoseData,\n      bloodPressureData,\n      exerciseData,\n      moodData,\n      painData,\n      mealData,\n      sleepData,\n      rawData: rows\n    };\n  }\n  static clearCache() {\n    patientDataCache.clear();\n  }\n  static getCacheSize() {\n    return patientDataCache.size;\n  }\n}\nexport default DataService;","map":{"version":3,"names":["Papa","CACHE_EXPIRY","CSV_CONFIG","header","skipEmptyLines","transformHeader","trim","transform","value","duplicateHeaders","patientDataCache","Map","fetchAllCsvData","response","fetch","Date","now","ok","Error","statusText","csvText","text","parsed","parse","errors","length","console","warn","data","error","DataService","getPatientData","patientId","cacheKey","cached","get","timestamp","allData","numericPatientId","replace","patientRows","filter","row","processedData","processPatientData","set","rows","firstRow","generateGender","numericId","parseInt","patientInfo","patientNumber","age","gender","dataAvailable","medicationsRaw","Set","map","med","detailedMedications","conditionsSet","forEach","medString","meds","split","lastParenIndex","lastIndexOf","medName","substring","some","m","name","detailsStr","details","d","schedule","category","dosage","slice","join","push","chronicConditionsRaw","condition","conditionString","conditions","c","add","Array","from","glucoseData","flatMap","baseDate","readings","hasGlucoseData","undefined","i","glucoseValue","parseFloat","measurementType","range","timeStr","isNaN","readingDate","includes","hours","minutes","Number","setHours","hour","Math","floor","random","minute","date","patientNum","isDiabetic","baseGlucose","numReadings","variation","max","min","round","bloodPressureData","hasNewStructure","systolic","diastolic","bpTime","systolicType","diastolicType","exerciseByDate","hasNewExerciseStructure","dateKey","toDateString","walking","aerobic","strength","balance","other","totalMinutes","exerciseType","exerciseMinutesRaw","exerciseMinutes","normalizedType","toLowerCase","exerciseData","Object","values","day","moodData","mood","painData","location","level","sleepData","quality","qualityCode","mealData","Breakfast_Protein","Breakfast_Vegetables","Breakfast_Fruit","Breakfast_Alcohol","Breakfast_Carbohydrates","Breakfast_Added_Sugar","Lunch_Protein","Lunch_Vegetables","Lunch_Fruit","Lunch_Alcohol","Lunch_Carbohydrates","Lunch_Added_Sugar","Dinner_Protein","Dinner_Vegetables","Dinner_Fruit","Dinner_Alcohol","Dinner_Carbohydrates","Dinner_Added_Sugar","Breakfast_Time","Lunch_Time","Dinner_Time","rawData","clearCache","clear","getCacheSize","size"],"sources":["C:/Users/Matteo/Working_Folder/a. MCC Thesis Local/MCC_digital_health_data_visualizations/src/services/dataService.js"],"sourcesContent":["import Papa from 'papaparse';\n\n// Constants\nconst CACHE_EXPIRY = 5 * 60 * 1000; // 5 minutes\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: (header) => header.trim(),\n  transform: (value) => value?.trim(),\n  duplicateHeaders: false\n};\n\nconst patientDataCache = new Map();\n\n// Function to fetch and parse the main CSV file.\nconst fetchAllCsvData = async () => {\n  try {\n    const response = await fetch(`/synthetic_patients_all.csv?v=${Date.now()}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV data: ${response.statusText}`);\n    }\n    const csvText = await response.text();\n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    if (parsed.errors.length > 0) {\n      console.warn('CSV parsing warnings:', parsed.errors);\n    }\n    return parsed.data;\n  } catch (error) {\n    console.error('Error fetching or parsing CSV data:', error);\n    throw error;\n  }\n};\n\nclass DataService {\n  static async getPatientData(patientId) {\n    const cacheKey = `${patientId}_v13`; // Increment to force cache refresh\n    const cached = patientDataCache.get(cacheKey);\n\n    if (cached && Date.now() - cached.timestamp < CACHE_EXPIRY) {\n      return cached.data;\n    }\n\n    try {\n      const allData = await fetchAllCsvData();\n      \n\n      // Extract numeric part from patientId (e.g., \"Patient_001\" -> \"001\")\n      const numericPatientId = patientId.replace('Patient_', '');\n      \n      // Filter data for the specific patient\n      const patientRows = allData.filter(row => \n        row['Patient_ID'] === numericPatientId\n      );\n\n      if (patientRows.length === 0) {\n        throw new Error(`No data found for patient ${patientId}`);\n      }\n\n      // Process and structure the data\n      const processedData = this.processPatientData(patientRows, patientId);\n      \n      // Cache the processed data\n      patientDataCache.set(cacheKey, {\n        data: processedData,\n        timestamp: Date.now()\n      });\n\n      return processedData;\n    } catch (error) {\n      console.error('Error fetching patient data:', error);\n      throw error;\n    }\n  }\n\n  static processPatientData(rows, patientId) {\n    const firstRow = rows[0];\n    \n    // Extract basic patient info\n    // Since CSV parsing has issues with Gender column due to complex medication strings,\n    // we'll generate gender based on patient ID as a temporary solution\n    const generateGender = (patientId) => {\n      const numericId = parseInt(patientId.replace('Patient_', ''));\n      // Use patient ID to consistently assign gender (slight female bias as in original Python script)\n      return (numericId % 3 === 0) ? 'Male' : 'Female';\n    };\n    \n    const patientInfo = {\n      patientId,\n      patientNumber: patientId,\n      age: firstRow['Age'],\n      gender: generateGender(patientId),\n      dataAvailable: 'May 2025'\n    };\n\n    // Process medications with detailed information\n    const medicationsRaw = [...new Set(\n      rows.map(row => row['Medications'])\n        .filter(med => med && med.trim())\n    )];\n  \n    const detailedMedications = [];\n    const conditionsSet = new Set();\n  \n    medicationsRaw.forEach(medString => {\n      if (medString) {\n        const meds = medString.split('; ');\n        meds.forEach(med => {\n          const lastParenIndex = med.lastIndexOf('(');\n          if (lastParenIndex === -1) return;\n\n          const medName = med.substring(0, lastParenIndex).trim();\n          \n          if (medName && !detailedMedications.some(m => m.name === medName)) {\n            const detailsStr = med.substring(lastParenIndex + 1, med.length - 1);\n            const details = detailsStr.split(',').map(d => d.trim());\n\n            const schedule = details[0] || 'Not specified';\n            const category = details[1] || '';\n            const dosage = details.slice(2).join(', ') || '';\n\n            detailedMedications.push({\n              name: medName,\n              schedule: schedule,\n              category: category,\n              dosage: dosage\n            });\n          }\n        });\n      }\n    });\n\n    // Also check for direct chronic conditions column\n    const chronicConditionsRaw = [...new Set(\n      rows.map(row => row['Chronic_Conditions'])\n        .filter(condition => condition && condition.trim())\n    )];\n    \n    chronicConditionsRaw.forEach(conditionString => {\n      if (conditionString) {\n        const conditions = conditionString.split(',').map(c => c.trim());\n        conditions.forEach(condition => {\n          if (condition) {\n            conditionsSet.add(condition);\n          }\n        });\n      }\n    });\n  \n    const conditions = Array.from(conditionsSet);\n\n    // Process glucose data - use CSV data if available, otherwise generate realistic data\n    const glucoseData = rows\n      .flatMap(row => {\n        const baseDate = new Date(row['Date']);\n        const readings = [];\n        \n        // Check if we have glucose data in CSV\n        const hasGlucoseData = row['Glucose_1'] !== undefined;\n        \n        if (hasGlucoseData) {\n          // Process CSV glucose data (Glucose_1-4)\n          for (let i = 1; i <= 4; i++) {\n            const glucoseValue = parseFloat(row[`Glucose_${i}`]);\n            const measurementType = row[`Glucose_Measurement_Type_${i}`];\n            const range = row[`Glucose_Range_${i}`];\n            const timeStr = row[`Glucose_Time_${i}`];\n            \n            if (!isNaN(glucoseValue) && glucoseValue > 0) {\n              let readingDate = new Date(baseDate);\n              \n              // Parse time if available\n              if (timeStr && timeStr.includes(':')) {\n                const [hours, minutes] = timeStr.split(':').map(Number);\n                readingDate.setHours(hours, minutes, 0, 0);\n              } else {\n                // Fallback to simulated times\n                const hour = 7 + Math.floor(Math.random() * 13); // 7am to 8pm\n                const minute = Math.floor(Math.random() * 60);\n                readingDate.setHours(hour, minute, 0, 0);\n              }\n              \n              readings.push({\n                date: readingDate,\n                value: glucoseValue,\n                range: range || 'Normal',\n                measurementType: measurementType || 'Pre meal'\n              });\n            }\n          }\n        } else {\n          // Generate realistic data for patients without CSV glucose data\n          const patientNum = parseInt(patientId.replace('Patient_', '')) || parseInt(patientId);\n          const isDiabetic = patientNum % 3 === 2; // Every 3rd patient starting with 2 has diabetes\n          \n          let baseGlucose;\n          if (isDiabetic) {\n            // Diabetic patient: higher, more variable glucose (6-15 mmol/L)\n            baseGlucose = 7.0 + Math.random() * 8.0;\n          } else {\n            // Non-diabetic patient: normal glucose (4-7 mmol/L)\n            baseGlucose = 4.5 + Math.random() * 2.5;\n          }\n          \n          // Create 2-4 readings per day with simulated timestamps\n          const numReadings = Math.floor(Math.random() * 3) + 2; // 2-4 readings\n          \n          for (let i = 0; i < numReadings; i++) {\n            // Generate realistic glucose measurement times\n            let hour, measurementType;\n            if (i === 0) {\n              // Fasting/morning reading (6-8am)\n              hour = 6 + Math.floor(Math.random() * 2);\n              measurementType = 'Pre meal';\n            } else if (i === 1) {\n              // Pre-lunch reading (11am-12pm)\n              hour = 11 + Math.floor(Math.random() * 1);\n              measurementType = 'Pre meal';\n            } else if (i === 2) {\n              // Post-meal reading (1-3pm)\n              hour = 13 + Math.floor(Math.random() * 2);\n              measurementType = '2-hour post meal';\n            } else {\n              // Evening reading (6-8pm)\n              hour = 18 + Math.floor(Math.random() * 2);\n              measurementType = Math.random() > 0.5 ? 'Pre meal' : '2-hour post meal';\n            }\n            \n            const minute = Math.floor(Math.random() * 60);\n            const readingDate = new Date(baseDate);\n            readingDate.setHours(hour, minute, 0, 0);\n            \n            // Add realistic variation based on measurement type\n            let glucoseValue;\n            if (measurementType === 'Pre meal') {\n              // Pre-meal: slight variation around base value\n              const variation = (Math.random() - 0.5) * 2;\n              glucoseValue = Math.max(3.0, Math.min(15.0, baseGlucose + variation));\n            } else {\n              // Post-meal: typically higher\n              const variation = (Math.random() - 0.5) * 3 + 2;\n              glucoseValue = Math.max(4.0, Math.min(20.0, baseGlucose + variation));\n            }\n            \n            // Determine range based on value and type\n            let range;\n            if (measurementType === 'Pre meal') {\n              if (glucoseValue < 4.0) range = 'Low';\n              else if (glucoseValue <= 7.0) range = 'Normal';\n              else range = 'High';\n            } else {\n              if (glucoseValue < 4.0) range = 'Low';\n              else if (glucoseValue <= 10.0) range = 'Normal';\n              else range = 'High';\n            }\n            \n            readings.push({\n              date: readingDate,\n              value: Math.round(glucoseValue * 10) / 10, // Round to 1 decimal\n              range: range,\n              measurementType: measurementType\n            });\n          }\n        }\n        \n        return readings;\n      });\n\n    // Process blood pressure data - robust handling of both new and old CSV structures\n    \n    const bloodPressureData = rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const readings = [];\n      \n      // Check if we have new multi-column structure\n      const hasNewStructure = row['Systolic_1'] !== undefined;\n      \n      if (hasNewStructure) {\n        // Process new multi-column structure (Systolic_1-4, Diastolic_1-4)\n        for (let i = 1; i <= 4; i++) {\n          const systolic = parseInt(row[`Systolic_${i}`]);\n          const diastolic = parseInt(row[`Diastolic_${i}`]);\n          const bpTime = row[`BP_Time_${i}`];\n          const systolicType = row[`Systolic_Type_${i}`];\n          const diastolicType = row[`Diastolic_Type_${i}`];\n          \n          if (!isNaN(systolic) && !isNaN(diastolic) && systolic > 0 && diastolic > 0) {\n            let readingDate = new Date(baseDate);\n            \n            // Parse time if available, otherwise use simulated time\n            if (bpTime && bpTime.includes(':')) {\n              const [hours, minutes] = bpTime.split(':').map(Number);\n              readingDate.setHours(hours, minutes, 0, 0);\n            } else {\n              // Fallback to simulated times\n              const hour = 7 + Math.floor(Math.random() * 13); // 7am to 8pm\n              const minute = Math.floor(Math.random() * 60);\n              readingDate.setHours(hour, minute, 0, 0);\n            }\n            \n            readings.push({\n              date: readingDate,\n              systolic: systolic,\n              diastolic: diastolic,\n              systolicType: systolicType || 'Normal',\n              diastolicType: diastolicType || 'Normal'\n            });\n          }\n        }\n      } else if (row['Systolic'] && row['Diastolic']) {\n        // Process old single column structure\n        const systolic = parseInt(row['Systolic']);\n        const diastolic = parseInt(row['Diastolic']);\n        \n        if (!isNaN(systolic) && !isNaN(diastolic)) {\n          // Create 2-3 readings per day with simulated timestamps\n          const numReadings = Math.floor(Math.random() * 2) + 2; // 2-3 readings\n          \n          for (let i = 0; i < numReadings; i++) {\n            // Generate realistic times: morning (7-10), afternoon (12-15), evening (17-20)\n            let hour;\n            if (i === 0) hour = 7 + Math.floor(Math.random() * 3); // Morning\n            else if (i === 1) hour = 12 + Math.floor(Math.random() * 3); // Afternoon  \n            else hour = 17 + Math.floor(Math.random() * 3); // Evening\n            \n            const minute = Math.floor(Math.random() * 60);\n            const readingDate = new Date(baseDate);\n            readingDate.setHours(hour, minute, 0, 0);\n            \n            // Add some variation to readings\n            const variation = (Math.random() - 0.5) * 10;\n            \n            readings.push({\n              date: readingDate,\n              systolic: Math.max(80, Math.min(200, systolic + Math.floor(variation))),\n              diastolic: Math.max(50, Math.min(120, diastolic + Math.floor(variation/2))),\n              systolicType: row['Systolic_Type'] || 'Normal',\n              diastolicType: row['Diastolic_Type'] || 'Normal'\n            });\n          }\n        }\n      }\n      \n      return readings;\n    });\n    \n\n    // Process exercise data - robust handling of both new and old CSV structures\n    const exerciseByDate = {};\n    \n    // Check if we have new multi-column structure\n    const hasNewExerciseStructure = rows[0] && rows[0]['Exercise_Type_1'] !== undefined;\n    \n    rows.forEach(row => {\n      const date = new Date(row['Date']);\n      const dateKey = date.toDateString();\n      \n      if (!exerciseByDate[dateKey]) {\n        exerciseByDate[dateKey] = {\n          date: date,\n          walking: 0,\n          aerobic: 0,\n          strength: 0,\n          balance: 0,\n          other: 0,\n          totalMinutes: 0\n        };\n      }\n      \n      if (hasNewExerciseStructure) {\n        // Process new multi-column structure (Exercise_Type_1-3, Exercise_Minutes_1-3)\n        for (let i = 1; i <= 3; i++) {\n          const exerciseType = row[`Exercise_Type_${i}`];\n          const exerciseMinutesRaw = row[`Exercise_Minutes_${i}`];\n          const exerciseMinutes = parseFloat(exerciseMinutesRaw);\n          \n          if (exerciseType && exerciseType.trim() && !isNaN(exerciseMinutes) && exerciseMinutes > 0) {\n            const normalizedType = exerciseType.toLowerCase();\n            \n            // Map exercise types to chart categories\n            if (normalizedType.includes('walking')) {\n              exerciseByDate[dateKey].walking += exerciseMinutes;\n            } else if (normalizedType.includes('aerobic')) {\n              exerciseByDate[dateKey].aerobic += exerciseMinutes;\n            } else if (normalizedType.includes('strength')) {\n              exerciseByDate[dateKey].strength += exerciseMinutes;\n            } else if (normalizedType.includes('balance')) {\n              exerciseByDate[dateKey].balance += exerciseMinutes;\n            } else {\n              exerciseByDate[dateKey].other += exerciseMinutes;\n            }\n            \n            exerciseByDate[dateKey].totalMinutes += exerciseMinutes;\n          }\n        }\n      } else if (row['Exercise_Type'] && row['Exercise_Minutes']) {\n        // Process old single column structure\n        const exerciseType = row['Exercise_Type'];\n        const exerciseMinutesRaw = row['Exercise_Minutes'];\n        const exerciseMinutes = parseFloat(exerciseMinutesRaw);\n        \n        if (exerciseType && exerciseType.trim() && !isNaN(exerciseMinutes) && exerciseMinutes > 0) {\n          const normalizedType = exerciseType.toLowerCase();\n          \n          // Map exercise types to chart categories\n          if (normalizedType.includes('walking')) {\n            exerciseByDate[dateKey].walking += exerciseMinutes;\n          } else if (normalizedType.includes('aerobic')) {\n            exerciseByDate[dateKey].aerobic += exerciseMinutes;\n          } else if (normalizedType.includes('strength')) {\n            exerciseByDate[dateKey].strength += exerciseMinutes;\n          } else if (normalizedType.includes('balance')) {\n            exerciseByDate[dateKey].balance += exerciseMinutes;\n          } else {\n            exerciseByDate[dateKey].other += exerciseMinutes;\n          }\n          \n          exerciseByDate[dateKey].totalMinutes += exerciseMinutes;\n        }\n      }\n    });\n    \n    const exerciseData = Object.values(exerciseByDate).filter(day => day.totalMinutes > 0);\n\n    // Process mood data\n    const moodData = rows\n      .filter(row => row['Mood'])\n      .map(row => ({\n        date: new Date(row['Date']),\n        mood: row['Mood'],\n        category: row['Mood'] || 'neutral'\n      }));\n\n    // Process pain data\n    const painData = rows\n      .filter(row => row['Pain_Location'] && row['Pain_Level'] !== undefined)\n      .map(row => ({\n        date: new Date(row['Date']),\n        location: row['Pain_Location'].toLowerCase(),\n        level: parseInt(row['Pain_Level']) || 0\n      }));\n    \n    // Process sleep data\n    const sleepData = rows\n      .filter(row => row['Sleep_Hours'] && row['Sleep_Quality'])\n      .map(row => ({\n        date: new Date(row['Date']),\n        hours: parseFloat(row['Sleep_Hours']),\n        quality: row['Sleep_Quality'],\n        qualityCode: parseInt(row['Sleep_Quality_Code'])\n      }));\n\n    // Process meal data\n    const mealData = rows.map(row => ({\n      Date: row['Date'],\n      Breakfast_Protein: row['Breakfast_Protein'],\n      Breakfast_Vegetables: row['Breakfast_Vegetables'],\n      Breakfast_Fruit: row['Breakfast_Fruit'],\n      Breakfast_Alcohol: row['Breakfast_Alcohol'],\n      Breakfast_Carbohydrates: row['Breakfast_Carbohydrates'],\n      Breakfast_Added_Sugar: row['Breakfast_Added_Sugar'],\n      Lunch_Protein: row['Lunch_Protein'],\n      Lunch_Vegetables: row['Lunch_Vegetables'],\n      Lunch_Fruit: row['Lunch_Fruit'],\n      Lunch_Alcohol: row['Lunch_Alcohol'],\n      Lunch_Carbohydrates: row['Lunch_Carbohydrates'],\n      Lunch_Added_Sugar: row['Lunch_Added_Sugar'],\n      Dinner_Protein: row['Dinner_Protein'],\n      Dinner_Vegetables: row['Dinner_Vegetables'],\n      Dinner_Fruit: row['Dinner_Fruit'],\n      Dinner_Alcohol: row['Dinner_Alcohol'],\n      Dinner_Carbohydrates: row['Dinner_Carbohydrates'],\n      Dinner_Added_Sugar: row['Dinner_Added_Sugar'],\n      Breakfast_Time: row['Breakfast_Time'],\n      Lunch_Time: row['Lunch_Time'],\n      Dinner_Time: row['Dinner_Time']\n    }));\n\n    return {\n      patientInfo: { \n        ...patientInfo, \n        detailedMedications, \n        conditions\n      },\n      glucoseData,\n      bloodPressureData,\n      exerciseData,\n      moodData,\n      painData,\n      mealData,\n      sleepData,\n      rawData: rows\n    };\n  }\n\n  static clearCache() {\n    patientDataCache.clear();\n  }\n\n  static getCacheSize() {\n    return patientDataCache.size;\n  }\n}\n\nexport default DataService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}