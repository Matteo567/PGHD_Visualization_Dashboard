{"ast":null,"code":"/*\n dataService.js - Patient Data Service\n \n This service handles all data operations for the health dashboard:\n - Fetches patient CSV data from the server\n - Parses and processes CSV data using PapaParse\n - Transforms raw data into structured health metrics\n - Provides data validation and error handling\n - Manages patient information, medications, and health tracking data\n - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\n \n Architecture:\n - Uses PapaParse library for CSV parsing\n - Implements service class pattern for data operations\n - Provides comprehensive error handling and validation\n - Supports multiple data formats and structures\n \n Data Processing:\n - CSV parsing with header validation\n - Data transformation and normalization\n - Type conversion and validation\n - Error recovery and fallback mechanisms\n \n Health Metrics Supported:\n - Blood glucose monitoring with meal context\n - Blood pressure tracking with risk categorization\n - Exercise activity tracking and categorization\n - Mood assessment and tracking\n - Pain reporting with anatomical mapping\n - Sleep quality and duration analysis\n - Nutritional intake and meal composition\n \n Error Handling:\n - Network error recovery\n - CSV parsing error handling\n - Data validation and sanitization\n - Graceful degradation for missing data\n \n Core service for data management and processing throughout the application.\n */\n\nimport Papa from 'papaparse';\n\n// Configuration for CSV parsing\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: header => (header === null || header === void 0 ? void 0 : header.trim()) || '',\n  transform: value => (value === null || value === void 0 ? void 0 : value.trim()) || '',\n  dynamicTyping: false,\n  // Keep everything as strings to avoid parsing issues\n  delimiter: ',',\n  quoteChar: '\"',\n  escapeChar: '\"'\n};\n\n/*\n Fetches and parses CSV data for a specific patient\n \n - @param {string} patientId - The patient identifier\n - @returns {Promise<Array>} Parsed CSV data as array of objects\n - @throws {Error} If CSV fetch or parsing fails\n */\nconst fetchPatientCsvData = async patientId => {\n  try {\n    // Add cache busting to ensure fresh data\n    const baseUrl = process.env.NODE_ENV === 'production' ? 'https://matteo567.github.io/PGHD_Visualization_Dashboard' : '';\n    const url = `${baseUrl}/synthetic_patients/${patientId}.csv?v=${Date.now()}`;\n\n    // Debug logging for development\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`Fetching CSV data from: ${url}`);\n      console.log(`Base URL: ${baseUrl}`);\n      console.log(`PUBLIC_URL: ${process.env.PUBLIC_URL}`);\n    }\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\n    }\n    const csvText = await response.text();\n    if (!csvText || csvText.trim().length === 0) {\n      throw new Error(`Empty CSV file for patient ${patientId}`);\n    }\n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    if (parsed.errors.length > 0) {\n      // Log parsing errors for debugging but don't throw (only in development)\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`CSV parsing warnings for ${patientId}:`, parsed.errors);\n      }\n    }\n    return parsed.data;\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    }\n    throw error;\n  }\n};\n\n/*\n Service class for handling patient data operations\n Provides methods for fetching and processing patient health data from CSV files\n */\n/*\n| Retrieves and processes all data for a specific patient\n| \n| @param {string} patientId - The patient identifier\n| @returns {Promise<Object>} Processed patient data including all health metrics\n| @throws {Error} If patient data cannot be retrieved or processed\n| */\nexport async function getPatientData(patientId) {\n  if (!patientId) {\n    throw new Error('Patient ID is required');\n  }\n  try {\n    const patientRows = await fetchPatientCsvData(patientId);\n    if (!Array.isArray(patientRows) || patientRows.length === 0) {\n      throw new Error(`No data found for patient ${patientId}`);\n    }\n    return processPatientData(patientRows, patientId);\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching patient data for ${patientId}:`, error);\n    }\n    throw error;\n  }\n}\n\n/**\n * Processes raw CSV data into structured patient information and health metrics\n * \n * - @param {Array} rows - Raw CSV data rows\n * - @param {string} patientId - The patient identifier\n * - @returns {Object} Structured patient data object\n * - @throws {Error} If data structure is invalid or processing fails\n */\nexport function processPatientData(rows, patientId) {\n  if (!Array.isArray(rows) || rows.length === 0) {\n    throw new Error(`Invalid data structure for patient ${patientId}`);\n  }\n  const firstRowData = rows[0];\n  if (!firstRowData) {\n    throw new Error(`No valid data rows found for patient ${patientId}`);\n  }\n  const patientInfo = {\n    patientId,\n    patientNumber: patientId,\n    name: firstRowData['Name'] || 'Not specified',\n    age: firstRowData['Age'] || 'Not specified',\n    gender: firstRowData['Gender'] || 'Not specified',\n    dataAvailable: 'May 2025'\n  };\n\n  // Process medications using the cleaner individual medication fields\n  const detailedMedications = [];\n\n  // Get medication data from the first row (should be consistent across all rows for a patient)\n  const medicationNamesStr = firstRowData['Medication_Names'] || '';\n  const medicationTypesStr = firstRowData['Medication_Types'] || '';\n  const medicationCategoriesStr = firstRowData['Medication_Categories'] || '';\n  const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\n\n  // Split the semicolon-separated strings into arrays\n  const medicationNames = medicationNamesStr ? medicationNamesStr.split('; ').filter(Boolean) : [];\n  const medicationTypes = medicationTypesStr ? medicationTypesStr.split('; ').filter(Boolean) : [];\n  const medicationCategories = medicationCategoriesStr ? medicationCategoriesStr.split('; ').filter(Boolean) : [];\n  const medicationDosages = medicationDosagesStr ? medicationDosagesStr.split('; ').filter(Boolean) : [];\n\n  // Process each medication\n  for (let i = 0; i < Math.max(medicationNames.length, medicationTypes.length, medicationCategories.length, medicationDosages.length); i++) {\n    const name = medicationNames[i] || '';\n    const type = medicationTypes[i] || '';\n    const category = medicationCategories[i] || '';\n    const dosage = medicationDosages[i] || '';\n    if (name && name.trim() && !name.includes('Dose not specified') && name.length < 100 &&\n    // Filter out extremely long medication names\n    !name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) {\n      detailedMedications.push({\n        name: name.trim(),\n        schedule: dosage.trim(),\n        // Use dosage as schedule\n        category: '',\n        // Don't include category in visualization\n        dosage: ''\n      });\n    }\n  }\n\n  // Process conditions\n  const conditionsSet = new Set();\n  const conditionsRaw = [...new Set(rows.map(row => row['Chronic_Conditions'] || row['Conditions']).filter(Boolean))];\n  conditionsRaw.forEach(conditionString => {\n    conditionString.split(';').forEach(c => conditionsSet.add(c.trim()));\n  });\n\n  // Process all data types\n  const glucoseData = processGlucoseData(rows);\n  const bloodPressureData = processBloodPressureData(rows);\n  const exerciseData = processExerciseData(rows);\n  const moodData = processMoodData(rows);\n  const painData = processPainData(rows);\n  const sleepData = processSleepData(rows);\n  const mealData = processMealData(rows);\n  return {\n    patientInfo: {\n      ...patientInfo,\n      detailedMedications,\n      conditions: Array.from(conditionsSet)\n    },\n    glucoseData,\n    bloodPressureData,\n    exerciseData,\n    moodData,\n    painData,\n    mealData,\n    sleepData,\n    rawData: rows\n  };\n}\n\n// Helper functions for glucose data processing\nfunction parseTimeString(timeStr) {\n  if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {\n    return {\n      hours: 0,\n      minutes: 0\n    };\n  }\n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) {\n    return {\n      hours: 0,\n      minutes: 0\n    };\n  }\n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  return {\n    hours: isNaN(hours) ? 0 : hours,\n    minutes: isNaN(minutes) ? 0 : minutes\n  };\n}\nfunction createGlucoseReading(baseDate, value, timeStr, range, measurementType) {\n  const {\n    hours,\n    minutes\n  } = parseTimeString(timeStr);\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  return {\n    date: date,\n    value: value,\n    range: range,\n    measurementType: measurementType\n  };\n}\nfunction processMultiColumnGlucose(row, baseDate) {\n  const readings = [];\n  for (let i = 1; i <= 4; i++) {\n    const value = parseFloat(row[`Glucose_${i}`]);\n    const timeStr = row[`Glucose_Time_${i}`];\n    if (!isNaN(value) && value > 0 && timeStr && timeStr.trim() !== '') {\n      const reading = createGlucoseReading(baseDate, value, timeStr, row[`Glucose_Range_${i}`], row[`Glucose_Measurement_Type_${i}`]);\n      readings.push(reading);\n    }\n  }\n  return readings;\n}\nfunction processSingleColumnGlucose(row, baseDate) {\n  const value = parseFloat(row['Glucose_Level']);\n  if (!isNaN(value) && value > 0) {\n    const randomHour = Math.floor(Math.random() * 24);\n    const randomMinute = Math.floor(Math.random() * 60);\n    const date = new Date(baseDate);\n    date.setHours(randomHour, randomMinute);\n    let range = 'in range';\n    if (value < 70) range = 'below range';else if (value > 180) range = 'above range';\n    return [{\n      date: date,\n      value: value,\n      range: range,\n      measurementType: 'Random'\n    }];\n  }\n  return [];\n}\n\n/**\n * Processes blood glucose data from CSV rows\n */\nexport function processGlucoseData(rows) {\n  const readings = [];\n  rows.forEach(row => {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Glucose_1'] !== undefined;\n    if (hasMultiColumn) {\n      readings.push(...processMultiColumnGlucose(row, baseDate));\n    } else {\n      readings.push(...processSingleColumnGlucose(row, baseDate));\n    }\n  });\n  return readings;\n}\n\n/**\n * Processes blood pressure data from CSV rows\n */\nexport function processBloodPressureData(rows) {\n  const readings = [];\n  for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n    const row = rows[rowIndex];\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Systolic_1'] !== undefined;\n    if (hasMultiColumn) {\n      // Process up to 4 readings per day\n      for (let i = 1; i <= 4; i++) {\n        const systolic = parseInt(row[`Systolic_${i}`]);\n        const diastolic = parseInt(row[`Diastolic_${i}`]);\n        const timeStr = row[`BP_Time_${i}`];\n        if (systolic > 0 && diastolic > 0 && timeStr) {\n          const timeParts = timeStr.split(':');\n          if (timeParts.length >= 2) {\n            const hours = parseInt(timeParts[0], 10);\n            const minutes = parseInt(timeParts[1], 10);\n            if (!isNaN(hours) && !isNaN(minutes)) {\n              const date = new Date(baseDate);\n              date.setHours(hours, minutes);\n              readings.push({\n                date: date,\n                systolic: systolic,\n                diastolic: diastolic,\n                systolicType: row[`Systolic_Type_${i}`],\n                diastolicType: row[`Diastolic_Type_${i}`]\n              });\n            }\n          }\n        }\n      }\n    } else {\n      // Single reading format\n      const systolic = parseInt(row['Systolic_BP']);\n      const diastolic = parseInt(row['Diastolic_BP']);\n      if (systolic > 0 && diastolic > 0) {\n        const randomHour = Math.floor(Math.random() * 24);\n        const randomMinute = Math.floor(Math.random() * 60);\n        const date = new Date(baseDate);\n        date.setHours(randomHour, randomMinute);\n        let systolicType = 'normal';\n        let diastolicType = 'normal';\n        if (systolic >= 180 || diastolic >= 120) {\n          systolicType = 'hypertensive crisis';\n          diastolicType = 'hypertensive crisis';\n        } else if (systolic >= 140 || diastolic >= 90) {\n          systolicType = 'high';\n          diastolicType = 'high';\n        } else if (systolic >= 130 || diastolic >= 80) {\n          systolicType = 'elevated';\n          diastolicType = 'elevated';\n        }\n        readings.push({\n          date: date,\n          systolic: systolic,\n          diastolic: diastolic,\n          systolicType: systolicType,\n          diastolicType: diastolicType\n        });\n      }\n    }\n  }\n  return readings;\n}\n\n/**\n * Processes exercise data from CSV rows\n * \n * - @param {Array} rows - CSV data rows\n * - @returns {Array} Processed exercise data with activity types and durations\n */\nexport function processExerciseData(rows) {\n  const exerciseByDate = {};\n  rows.forEach(row => {\n    const date = new Date(row['Date']);\n    const dateKey = date.toDateString();\n    if (!exerciseByDate[dateKey]) {\n      exerciseByDate[dateKey] = {\n        date,\n        walking: 0,\n        swimming: 0,\n        running: 0,\n        biking: 0,\n        'muscle-strengthening': 0,\n        balance: 0,\n        other: 0,\n        totalMinutes: 0\n      };\n    }\n    const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\n    if (hasMultiColumn) {\n      for (let i = 1; i <= 5; i++) {\n        var _row;\n        const type = (_row = row[`Exercise_Type_${i}`]) === null || _row === void 0 ? void 0 : _row.toLowerCase();\n        const minutes = parseFloat(row[`Exercise_Minutes_${i}`]);\n        if (type && minutes > 0) {\n          categorizeExercise(type, minutes, exerciseByDate[dateKey]);\n        }\n      }\n    } else {\n      var _row$Exercise_Type;\n      const type = (_row$Exercise_Type = row['Exercise_Type']) === null || _row$Exercise_Type === void 0 ? void 0 : _row$Exercise_Type.toLowerCase();\n      const minutes = parseFloat(row['Exercise_Minutes']);\n      if (type && minutes > 0) {\n        categorizeExercise(type, minutes, exerciseByDate[dateKey]);\n      }\n    }\n  });\n  return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n}\n\n/**\n * Categorizes exercise activities into predefined types\n * \n * - @param {string} type - Exercise type from CSV\n * - @param {number} minutes - Duration in minutes\n * - @param {Object} dayData - Daily exercise data object\n */\nexport function categorizeExercise(type, minutes, dayData) {\n  if (type.includes('walking')) dayData.walking += minutes;else if (type.includes('swimming')) dayData.swimming += minutes;else if (type.includes('running')) dayData.running += minutes;else if (type.includes('biking')) dayData.biking += minutes;else if (type.includes('muscle-strengthening') || type.includes('muscle strengthening') || type.includes('strength')) dayData['muscle-strengthening'] += minutes;else if (type.includes('balance')) dayData.balance += minutes;else dayData.other += minutes;\n  dayData.totalMinutes += minutes;\n}\n\n/**\n * Processes mood data from CSV rows\n */\nexport function processMoodData(rows) {\n  const moodData = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    if (row['Mood']) {\n      moodData.push({\n        date: new Date(row['Date']),\n        mood: row['Mood'],\n        category: row['Mood'] || 'neutral'\n      });\n    }\n  }\n  return moodData;\n}\n\n/**\n * Processes pain data from CSV rows\n */\nexport function processPainData(rows) {\n  const painData = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    if (row['Pain_Location'] && row['Pain_Level']) {\n      painData.push({\n        date: new Date(row['Date']),\n        location: row['Pain_Location'].toLowerCase(),\n        level: parseInt(row['Pain_Level'])\n      });\n    }\n  }\n  return painData;\n}\n\n/**\n * Processes sleep data from CSV rows\n */\nexport function processSleepData(rows) {\n  const sleepData = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    if (row['Sleep_Hours'] && row['Sleep_Quality']) {\n      sleepData.push({\n        date: new Date(row['Date']),\n        hours: parseFloat(row['Sleep_Hours']),\n        quality: row['Sleep_Quality'],\n        qualityCode: parseInt(row['Sleep_Quality_Code'])\n      });\n    }\n  }\n  return sleepData;\n}\n\n/**\n * Processes meal data from CSV rows\n */\nexport function processMealData(rows) {\n  const filteredRows = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\n    let hasMealData = false;\n\n    // Check each meal type\n    for (let j = 0; j < mealTypes.length; j++) {\n      const mealType = mealTypes[j];\n      const time = row[`${mealType}_Time`];\n      const protein = row[`${mealType}_Protein`];\n      const carbs = row[`${mealType}_Carbohydrates`];\n      const vegetables = row[`${mealType}_Vegetables`];\n      const fruit = row[`${mealType}_Fruit`];\n      const alcohol = row[`${mealType}_Alcohol`];\n      const sugar = row[`${mealType}_Added_Sugar`];\n\n      // Check if time exists and at least one food component is present\n      const hasFood = protein === 1 || protein === '1' || carbs === 1 || carbs === '1' || vegetables === 1 || vegetables === '1' || fruit === 1 || fruit === '1' || alcohol === 1 || alcohol === '1' || sugar && sugar !== '' && sugar !== 'NaN';\n      if (time && hasFood) {\n        hasMealData = true;\n        break;\n      }\n    }\n    if (hasMealData) {\n      filteredRows.push(row);\n    }\n  }\n  return filteredRows;\n}","map":{"version":3,"names":["Papa","CSV_CONFIG","header","skipEmptyLines","transformHeader","trim","transform","value","dynamicTyping","delimiter","quoteChar","escapeChar","fetchPatientCsvData","patientId","baseUrl","process","env","NODE_ENV","url","Date","now","console","log","PUBLIC_URL","response","fetch","ok","Error","status","statusText","csvText","text","length","parsed","parse","errors","warn","data","error","getPatientData","patientRows","Array","isArray","processPatientData","rows","firstRowData","patientInfo","patientNumber","name","age","gender","dataAvailable","detailedMedications","medicationNamesStr","medicationTypesStr","medicationCategoriesStr","medicationDosagesStr","medicationNames","split","filter","Boolean","medicationTypes","medicationCategories","medicationDosages","i","Math","max","type","category","dosage","includes","push","schedule","conditionsSet","Set","conditionsRaw","map","row","forEach","conditionString","c","add","glucoseData","processGlucoseData","bloodPressureData","processBloodPressureData","exerciseData","processExerciseData","moodData","processMoodData","painData","processPainData","sleepData","processSleepData","mealData","processMealData","conditions","from","rawData","parseTimeString","timeStr","hours","minutes","timeParts","parseInt","isNaN","createGlucoseReading","baseDate","range","measurementType","date","setHours","processMultiColumnGlucose","readings","parseFloat","reading","processSingleColumnGlucose","randomHour","floor","random","randomMinute","hasMultiColumn","undefined","rowIndex","systolic","diastolic","systolicType","diastolicType","exerciseByDate","dateKey","toDateString","walking","swimming","running","biking","balance","other","totalMinutes","_row","toLowerCase","categorizeExercise","_row$Exercise_Type","Object","values","d","dayData","mood","location","level","quality","qualityCode","filteredRows","mealTypes","hasMealData","j","mealType","time","protein","carbs","vegetables","fruit","alcohol","sugar","hasFood"],"sources":["C:/Users/Matteo/Working_Folder/a. MCC Thesis Local Experimental/PGHD_Visualization_Dashboard/src/services/dataService.js"],"sourcesContent":["/*\n dataService.js - Patient Data Service\n \n This service handles all data operations for the health dashboard:\n - Fetches patient CSV data from the server\n - Parses and processes CSV data using PapaParse\n - Transforms raw data into structured health metrics\n - Provides data validation and error handling\n - Manages patient information, medications, and health tracking data\n - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\n \n Architecture:\n - Uses PapaParse library for CSV parsing\n - Implements service class pattern for data operations\n - Provides comprehensive error handling and validation\n - Supports multiple data formats and structures\n \n Data Processing:\n - CSV parsing with header validation\n - Data transformation and normalization\n - Type conversion and validation\n - Error recovery and fallback mechanisms\n \n Health Metrics Supported:\n - Blood glucose monitoring with meal context\n - Blood pressure tracking with risk categorization\n - Exercise activity tracking and categorization\n - Mood assessment and tracking\n - Pain reporting with anatomical mapping\n - Sleep quality and duration analysis\n - Nutritional intake and meal composition\n \n Error Handling:\n - Network error recovery\n - CSV parsing error handling\n - Data validation and sanitization\n - Graceful degradation for missing data\n \n Core service for data management and processing throughout the application.\n */\n\nimport Papa from 'papaparse';\n\n// Configuration for CSV parsing\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: (header) => header?.trim() || '',\n  transform: (value) => value?.trim() || '',\n  dynamicTyping: false, // Keep everything as strings to avoid parsing issues\n  delimiter: ',',\n  quoteChar: '\"',\n  escapeChar: '\"'\n};\n\n/*\n Fetches and parses CSV data for a specific patient\n \n - @param {string} patientId - The patient identifier\n - @returns {Promise<Array>} Parsed CSV data as array of objects\n - @throws {Error} If CSV fetch or parsing fails\n */\nconst fetchPatientCsvData = async (patientId) => {\n  try {\n    // Add cache busting to ensure fresh data\n    const baseUrl = process.env.NODE_ENV === 'production' \n      ? 'https://matteo567.github.io/PGHD_Visualization_Dashboard' \n      : '';\n    const url = `${baseUrl}/synthetic_patients/${patientId}.csv?v=${Date.now()}`;\n    \n    // Debug logging for development\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`Fetching CSV data from: ${url}`);\n      console.log(`Base URL: ${baseUrl}`);\n      console.log(`PUBLIC_URL: ${process.env.PUBLIC_URL}`);\n    }\n    \n    const response = await fetch(url);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.status} ${response.statusText}`);\n    }\n    \n    const csvText = await response.text();\n    \n    if (!csvText || csvText.trim().length === 0) {\n      throw new Error(`Empty CSV file for patient ${patientId}`);\n    }\n    \n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    \n    if (parsed.errors.length > 0) {\n      // Log parsing errors for debugging but don't throw (only in development)\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`CSV parsing warnings for ${patientId}:`, parsed.errors);\n      }\n    }\n    \n    return parsed.data;\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    }\n    throw error;\n  }\n};\n\n/*\n Service class for handling patient data operations\n Provides methods for fetching and processing patient health data from CSV files\n */\n/*\n| Retrieves and processes all data for a specific patient\n| \n| @param {string} patientId - The patient identifier\n| @returns {Promise<Object>} Processed patient data including all health metrics\n| @throws {Error} If patient data cannot be retrieved or processed\n| */\nexport async function getPatientData(patientId) {\n  if (!patientId) {\n    throw new Error('Patient ID is required');\n  }\n\n  try {\n    const patientRows = await fetchPatientCsvData(patientId);\n\n    if (!Array.isArray(patientRows) || patientRows.length === 0) {\n      throw new Error(`No data found for patient ${patientId}`);\n    }\n\n    return processPatientData(patientRows, patientId);\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`Error fetching patient data for ${patientId}:`, error);\n    }\n    throw error;\n  }\n}\n\n/**\n * Processes raw CSV data into structured patient information and health metrics\n * \n * - @param {Array} rows - Raw CSV data rows\n * - @param {string} patientId - The patient identifier\n * - @returns {Object} Structured patient data object\n * - @throws {Error} If data structure is invalid or processing fails\n */\nexport function processPatientData(rows, patientId) {\n  if (!Array.isArray(rows) || rows.length === 0) {\n    throw new Error(`Invalid data structure for patient ${patientId}`);\n  }\n\n  const firstRowData = rows[0];\n  if (!firstRowData) {\n    throw new Error(`No valid data rows found for patient ${patientId}`);\n  }\n\n  const patientInfo = {\n    patientId,\n    patientNumber: patientId,\n    name: firstRowData['Name'] || 'Not specified',\n    age: firstRowData['Age'] || 'Not specified',\n    gender: firstRowData['Gender'] || 'Not specified',\n    dataAvailable: 'May 2025'\n  };\n\n  // Process medications using the cleaner individual medication fields\n  const detailedMedications = [];\n  \n  // Get medication data from the first row (should be consistent across all rows for a patient)\n  const medicationNamesStr = firstRowData['Medication_Names'] || '';\n  const medicationTypesStr = firstRowData['Medication_Types'] || '';\n  const medicationCategoriesStr = firstRowData['Medication_Categories'] || '';\n  const medicationDosagesStr = firstRowData['Medication_Dosages'] || '';\n  \n  // Split the semicolon-separated strings into arrays\n  const medicationNames = medicationNamesStr ? medicationNamesStr.split('; ').filter(Boolean) : [];\n  const medicationTypes = medicationTypesStr ? medicationTypesStr.split('; ').filter(Boolean) : [];\n  const medicationCategories = medicationCategoriesStr ? medicationCategoriesStr.split('; ').filter(Boolean) : [];\n  const medicationDosages = medicationDosagesStr ? medicationDosagesStr.split('; ').filter(Boolean) : [];\n  \n  // Process each medication\n  for (let i = 0; i < Math.max(medicationNames.length, medicationTypes.length, medicationCategories.length, medicationDosages.length); i++) {\n    const name = medicationNames[i] || '';\n    const type = medicationTypes[i] || '';\n    const category = medicationCategories[i] || '';\n    const dosage = medicationDosages[i] || '';\n    \n    if (name && name.trim() && \n        !name.includes('Dose not specified') && \n        name.length < 100 && // Filter out extremely long medication names\n        !name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')) {\n      detailedMedications.push({\n        name: name.trim(),\n        schedule: dosage.trim(), // Use dosage as schedule\n        category: '', // Don't include category in visualization\n        dosage: ''\n      });\n    }\n  }\n\n  // Process conditions\n  const conditionsSet = new Set();\n  const conditionsRaw = [...new Set(rows.map(row => row['Chronic_Conditions'] || row['Conditions']).filter(Boolean))];\n  conditionsRaw.forEach(conditionString => {\n    conditionString.split(';').forEach(c => conditionsSet.add(c.trim()));\n  });\n\n  // Process all data types\n  const glucoseData = processGlucoseData(rows);\n  const bloodPressureData = processBloodPressureData(rows);\n  const exerciseData = processExerciseData(rows);\n  const moodData = processMoodData(rows);\n  const painData = processPainData(rows);\n  const sleepData = processSleepData(rows);\n  const mealData = processMealData(rows);\n\n  return {\n    patientInfo: { \n      ...patientInfo, \n      detailedMedications, \n      conditions: Array.from(conditionsSet)\n    },\n    glucoseData,\n    bloodPressureData,\n    exerciseData,\n    moodData,\n    painData,\n    mealData,\n    sleepData,\n    rawData: rows\n  };\n}\n\n// Helper functions for glucose data processing\nfunction parseTimeString(timeStr) {\n  if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {\n    return { hours: 0, minutes: 0 };\n  }\n  \n  const timeParts = timeStr.split(':');\n  if (timeParts.length < 2) {\n    return { hours: 0, minutes: 0 };\n  }\n  \n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n  \n  return {\n    hours: isNaN(hours) ? 0 : hours,\n    minutes: isNaN(minutes) ? 0 : minutes\n  };\n}\n\nfunction createGlucoseReading(baseDate, value, timeStr, range, measurementType) {\n  const { hours, minutes } = parseTimeString(timeStr);\n  const date = new Date(baseDate);\n  date.setHours(hours, minutes);\n  \n  return {\n    date: date,\n    value: value,\n    range: range,\n    measurementType: measurementType\n  };\n}\n\nfunction processMultiColumnGlucose(row, baseDate) {\n  const readings = [];\n  \n  for (let i = 1; i <= 4; i++) {\n    const value = parseFloat(row[`Glucose_${i}`]);\n    const timeStr = row[`Glucose_Time_${i}`];\n    \n    if (!isNaN(value) && value > 0 && timeStr && timeStr.trim() !== '') {\n      const reading = createGlucoseReading(\n        baseDate,\n        value,\n        timeStr,\n        row[`Glucose_Range_${i}`],\n        row[`Glucose_Measurement_Type_${i}`]\n      );\n      readings.push(reading);\n    }\n  }\n  \n  return readings;\n}\n\nfunction processSingleColumnGlucose(row, baseDate) {\n  const value = parseFloat(row['Glucose_Level']);\n  if (!isNaN(value) && value > 0) {\n    const randomHour = Math.floor(Math.random() * 24);\n    const randomMinute = Math.floor(Math.random() * 60);\n    const date = new Date(baseDate);\n    date.setHours(randomHour, randomMinute);\n    \n    let range = 'in range';\n    if (value < 70) range = 'below range';\n    else if (value > 180) range = 'above range';\n    \n    return [{\n      date: date,\n      value: value,\n      range: range,\n      measurementType: 'Random'\n    }];\n  }\n  return [];\n}\n\n/**\n * Processes blood glucose data from CSV rows\n */\nexport function processGlucoseData(rows) {\n  const readings = [];\n  \n  rows.forEach(row => {\n    const baseDate = new Date(row['Date']);\n    const hasMultiColumn = row['Glucose_1'] !== undefined;\n    \n    if (hasMultiColumn) {\n      readings.push(...processMultiColumnGlucose(row, baseDate));\n    } else {\n      readings.push(...processSingleColumnGlucose(row, baseDate));\n    }\n  });\n  \n  return readings;\n}\n\n/**\n * Processes blood pressure data from CSV rows\n */\nexport function processBloodPressureData(rows) {\n  const readings = [];\n    \n    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n      const row = rows[rowIndex];\n      const baseDate = new Date(row['Date']);\n      \n      const hasMultiColumn = row['Systolic_1'] !== undefined;\n      \n      if (hasMultiColumn) {\n        // Process up to 4 readings per day\n        for (let i = 1; i <= 4; i++) {\n          const systolic = parseInt(row[`Systolic_${i}`]);\n          const diastolic = parseInt(row[`Diastolic_${i}`]);\n          const timeStr = row[`BP_Time_${i}`];\n          \n          if (systolic > 0 && diastolic > 0 && timeStr) {\n            const timeParts = timeStr.split(':');\n            if (timeParts.length >= 2) {\n              const hours = parseInt(timeParts[0], 10);\n              const minutes = parseInt(timeParts[1], 10);\n              \n              if (!isNaN(hours) && !isNaN(minutes)) {\n                const date = new Date(baseDate);\n                date.setHours(hours, minutes);\n                \n                readings.push({ \n                  date: date, \n                  systolic: systolic, \n                  diastolic: diastolic, \n                  systolicType: row[`Systolic_Type_${i}`],\n                  diastolicType: row[`Diastolic_Type_${i}`]\n                });\n              }\n            }\n          }\n        }\n      } else {\n        // Single reading format\n        const systolic = parseInt(row['Systolic_BP']);\n        const diastolic = parseInt(row['Diastolic_BP']);\n        \n        if (systolic > 0 && diastolic > 0) {\n          const randomHour = Math.floor(Math.random() * 24);\n          const randomMinute = Math.floor(Math.random() * 60);\n          const date = new Date(baseDate);\n          date.setHours(randomHour, randomMinute);\n          \n          let systolicType = 'normal';\n          let diastolicType = 'normal';\n          \n          if (systolic >= 180 || diastolic >= 120) {\n            systolicType = 'hypertensive crisis';\n            diastolicType = 'hypertensive crisis';\n          } else if (systolic >= 140 || diastolic >= 90) {\n            systolicType = 'high';\n            diastolicType = 'high';\n          } else if (systolic >= 130 || diastolic >= 80) {\n            systolicType = 'elevated';\n            diastolicType = 'elevated';\n          }\n          \n          readings.push({ \n            date: date, \n            systolic: systolic, \n            diastolic: diastolic, \n            systolicType: systolicType,\n            diastolicType: diastolicType\n          });\n        }\n      }\n    }\n  \n  return readings;\n}\n\n/**\n * Processes exercise data from CSV rows\n * \n * - @param {Array} rows - CSV data rows\n * - @returns {Array} Processed exercise data with activity types and durations\n */\nexport function processExerciseData(rows) {\n  const exerciseByDate = {};\n    \n    rows.forEach(row => {\n        const date = new Date(row['Date']);\n        const dateKey = date.toDateString();\n        if (!exerciseByDate[dateKey]) {\n            exerciseByDate[dateKey] = { date, walking: 0, swimming: 0, running: 0, biking: 0, 'muscle-strengthening': 0, balance: 0, other: 0, totalMinutes: 0 };\n        }\n        \n        const hasMultiColumn = row['Exercise_Type_1'] !== undefined;\n        \n        if (hasMultiColumn) {\n            for (let i = 1; i <= 5; i++) {\n                const type = row[`Exercise_Type_${i}`]?.toLowerCase();\n                const minutes = parseFloat(row[`Exercise_Minutes_${i}`]);\n                if (type && minutes > 0) {\n                    categorizeExercise(type, minutes, exerciseByDate[dateKey]);\n                }\n            }\n        } else {\n            const type = row['Exercise_Type']?.toLowerCase();\n            const minutes = parseFloat(row['Exercise_Minutes']);\n            if (type && minutes > 0) {\n                categorizeExercise(type, minutes, exerciseByDate[dateKey]);\n            }\n        }\n    });\n  \n  return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n}\n\n/**\n * Categorizes exercise activities into predefined types\n * \n * - @param {string} type - Exercise type from CSV\n * - @param {number} minutes - Duration in minutes\n * - @param {Object} dayData - Daily exercise data object\n */\nexport function categorizeExercise(type, minutes, dayData) {\n  if (type.includes('walking')) dayData.walking += minutes;\n    else if (type.includes('swimming')) dayData.swimming += minutes;\n    else if (type.includes('running')) dayData.running += minutes;\n    else if (type.includes('biking')) dayData.biking += minutes;\n    else if (type.includes('muscle-strengthening') || type.includes('muscle strengthening') || type.includes('strength')) dayData['muscle-strengthening'] += minutes;\n    else if (type.includes('balance')) dayData.balance += minutes;\n  else dayData.other += minutes;\n  dayData.totalMinutes += minutes;\n}\n\n/**\n * Processes mood data from CSV rows\n */\nexport function processMoodData(rows) {\n  const moodData = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (row['Mood']) {\n        moodData.push({\n          date: new Date(row['Date']),\n          mood: row['Mood'],\n          category: row['Mood'] || 'neutral'\n        });\n      }\n    }\n  \n  return moodData;\n}\n\n/**\n * Processes pain data from CSV rows\n */\nexport function processPainData(rows) {\n  const painData = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (row['Pain_Location'] && row['Pain_Level']) {\n        painData.push({\n          date: new Date(row['Date']),\n          location: row['Pain_Location'].toLowerCase(),\n          level: parseInt(row['Pain_Level'])\n        });\n      }\n    }\n  \n  return painData;\n}\n\n/**\n * Processes sleep data from CSV rows\n */\nexport function processSleepData(rows) {\n  const sleepData = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (row['Sleep_Hours'] && row['Sleep_Quality']) {\n        sleepData.push({\n          date: new Date(row['Date']),\n          hours: parseFloat(row['Sleep_Hours']),\n          quality: row['Sleep_Quality'],\n          qualityCode: parseInt(row['Sleep_Quality_Code'])\n        });\n      }\n    }\n  \n  return sleepData;\n}\n\n/**\n * Processes meal data from CSV rows\n */\nexport function processMealData(rows) {\n  const filteredRows = [];\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      const mealTypes = ['Breakfast', 'Lunch', 'Dinner', 'Late Night Snack'];\n      let hasMealData = false;\n      \n      // Check each meal type\n      for (let j = 0; j < mealTypes.length; j++) {\n        const mealType = mealTypes[j];\n        const time = row[`${mealType}_Time`];\n        const protein = row[`${mealType}_Protein`];\n        const carbs = row[`${mealType}_Carbohydrates`];\n        const vegetables = row[`${mealType}_Vegetables`];\n        const fruit = row[`${mealType}_Fruit`];\n        const alcohol = row[`${mealType}_Alcohol`];\n        const sugar = row[`${mealType}_Added_Sugar`];\n        \n        // Check if time exists and at least one food component is present\n        const hasFood = protein === 1 || protein === '1' || \n                       carbs === 1 || carbs === '1' || \n                       vegetables === 1 || vegetables === '1' || \n                       fruit === 1 || fruit === '1' || \n                       alcohol === 1 || alcohol === '1' || \n                       (sugar && sugar !== '' && sugar !== 'NaN');\n        \n        if (time && hasFood) {\n          hasMealData = true;\n          break;\n        }\n      }\n      \n      if (hasMealData) {\n        filteredRows.push(row);\n      }\n    }\n  \n  return filteredRows;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}