{"ast":null,"code":"import Papa from 'papaparse';\n\n// Simplified CSV configuration\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: header => header.trim(),\n  transform: value => value === null || value === void 0 ? void 0 : value.trim()\n};\n\n// Simplified function to fetch a specific patient's CSV file.\nconst fetchPatientCsvData = async patientId => {\n  try {\n    // Fetch individual patient CSV from the public folder\n    const response = await fetch(`/public/synthetic_patients/${patientId}.csv?v=${new Date().getTime()}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.statusText}`);\n    }\n    const csvText = await response.text();\n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    if (parsed.errors.length > 0) {\n      console.warn(`CSV parsing warnings for ${patientId}:`, parsed.errors);\n    }\n    return parsed.data;\n  } catch (error) {\n    console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    throw error;\n  }\n};\nclass DataService {\n  /**\n   * Fetches and processes data for a single patient.\n   * This simplified version removes caching and fetches individual patient files.\n   */\n  static async getPatientData(patientId) {\n    try {\n      const patientRows = await fetchPatientCsvData(patientId);\n      if (patientRows.length === 0) {\n        throw new Error(`No data found for patient ${patientId}`);\n      }\n\n      // Process and structure the data\n      const processedData = this.processPatientData(patientRows, patientId);\n      return processedData;\n    } catch (error) {\n      console.error('Error fetching patient data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Processes the raw CSV rows for a patient.\n   * This simplified version assumes the new multi-column data format is always present.\n   */\n  static processPatientData(rows, patientId) {\n    const firstRow = rows[0];\n    const patientInfo = {\n      patientId,\n      patientNumber: patientId,\n      age: firstRow['Age'],\n      gender: firstRow['Gender'],\n      dataAvailable: 'May 2025'\n    };\n\n    // Process medications\n    const detailedMedications = [];\n    const conditionsSet = new Set();\n    const medicationsRaw = [...new Set(rows.map(row => row['Medications']).filter(Boolean))];\n    medicationsRaw.forEach(medString => {\n      medString.split('; ').forEach(med => {\n        const match = med.match(/(.*) \\((.*)\\)/);\n        if (match) {\n          const [, name, detailsStr] = match;\n          const details = detailsStr.split(',').map(d => d.trim());\n          detailedMedications.push({\n            name,\n            schedule: details[0] || '',\n            category: details[1] || '',\n            dosage: details.slice(2).join(', ') || ''\n          });\n        }\n      });\n    });\n\n    // Process conditions\n    const conditionsRaw = [...new Set(rows.map(row => row['Chronic_Conditions']).filter(Boolean))];\n    conditionsRaw.forEach(conditionString => {\n      conditionString.split(',').forEach(c => conditionsSet.add(c.trim()));\n    });\n\n    // Process all data types\n    const glucoseData = this.processGlucoseData(rows);\n    const bloodPressureData = this.processBloodPressureData(rows);\n    const exerciseData = this.processExerciseData(rows);\n    const moodData = this.processMoodData(rows);\n    const painData = this.processPainData(rows);\n    const sleepData = this.processSleepData(rows);\n    const mealData = this.processMealData(rows);\n    return {\n      patientInfo: {\n        ...patientInfo,\n        detailedMedications,\n        conditions: Array.from(conditionsSet)\n      },\n      glucoseData,\n      bloodPressureData,\n      exerciseData,\n      moodData,\n      painData,\n      mealData,\n      sleepData,\n      rawData: rows\n    };\n  }\n  static processGlucoseData(rows) {\n    return rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const readings = [];\n      for (let i = 1; i <= 4; i++) {\n        const value = parseFloat(row[`Glucose_${i}`]);\n        const timeStr = row[`Glucose_Time_${i}`];\n        if (value > 0 && timeStr) {\n          const [hours, minutes] = timeStr.split(':').map(Number);\n          const date = new Date(baseDate);\n          date.setHours(hours, minutes);\n          readings.push({\n            date,\n            value,\n            range: row[`Glucose_Range_${i}`],\n            measurementType: row[`Glucose_Measurement_Type_${i}`]\n          });\n        }\n      }\n      return readings;\n    });\n  }\n  static processBloodPressureData(rows) {\n    return rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const readings = [];\n      for (let i = 1; i <= 4; i++) {\n        const systolic = parseInt(row[`Systolic_${i}`]);\n        const diastolic = parseInt(row[`Diastolic_${i}`]);\n        const timeStr = row[`BP_Time_${i}`];\n        if (systolic > 0 && diastolic > 0 && timeStr) {\n          const [hours, minutes] = timeStr.split(':').map(Number);\n          const date = new Date(baseDate);\n          date.setHours(hours, minutes);\n          readings.push({\n            date,\n            systolic,\n            diastolic,\n            systolicType: row[`Systolic_Type_${i}`],\n            diastolicType: row[`Diastolic_Type_${i}`]\n          });\n        }\n      }\n      return readings;\n    });\n  }\n  static processExerciseData(rows) {\n    const exerciseByDate = {};\n    rows.forEach(row => {\n      const date = new Date(row['Date']);\n      const dateKey = date.toDateString();\n      if (!exerciseByDate[dateKey]) {\n        exerciseByDate[dateKey] = {\n          date,\n          walking: 0,\n          aerobic: 0,\n          strength: 0,\n          balance: 0,\n          other: 0,\n          totalMinutes: 0\n        };\n      }\n      for (let i = 1; i <= 3; i++) {\n        var _row;\n        const type = (_row = row[`Exercise_Type_${i}`]) === null || _row === void 0 ? void 0 : _row.toLowerCase();\n        const minutes = parseFloat(row[`Exercise_Minutes_${i}`]);\n        if (type && minutes > 0) {\n          if (type.includes('walking')) exerciseByDate[dateKey].walking += minutes;else if (type.includes('aerobic')) exerciseByDate[dateKey].aerobic += minutes;else if (type.includes('strength')) exerciseByDate[dateKey].strength += minutes;else if (type.includes('balance')) exerciseByDate[dateKey].balance += minutes;else exerciseByDate[dateKey].other += minutes;\n          exerciseByDate[dateKey].totalMinutes += minutes;\n        }\n      }\n    });\n    return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n  }\n  static processMoodData(rows) {\n    return rows.filter(row => row['Mood']).map(row => ({\n      date: new Date(row['Date']),\n      mood: row['Mood'],\n      category: row['Mood'] || 'neutral'\n    }));\n  }\n  static processPainData(rows) {\n    return rows.filter(row => row['Pain_Location'] && row['Pain_Level']).map(row => ({\n      date: new Date(row['Date']),\n      location: row['Pain_Location'].toLowerCase(),\n      level: parseInt(row['Pain_Level'])\n    }));\n  }\n  static processSleepData(rows) {\n    return rows.filter(row => row['Sleep_Hours'] && row['Sleep_Quality']).map(row => ({\n      date: new Date(row['Date']),\n      hours: parseFloat(row['Sleep_Hours']),\n      quality: row['Sleep_Quality'],\n      qualityCode: parseInt(row['Sleep_Quality_Code'])\n    }));\n  }\n  static processMealData(rows) {\n    return rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const meals = [];\n      const mealTypes = ['Breakfast', 'Lunch', 'Dinner'];\n      mealTypes.forEach(mealType => {\n        const timeStr = row[`${mealType}_Time`];\n        const contentsStr = row[`${mealType}_Contents`];\n        if (timeStr && contentsStr) {\n          const [hours, minutes] = timeStr.split(':').map(Number);\n          const date = new Date(baseDate);\n          date.setHours(hours, minutes);\n          const contents = contentsStr.split('-').map(s => s.trim());\n          meals.push({\n            date,\n            mealType,\n            contents\n          });\n        }\n      });\n      return meals;\n    });\n  }\n}\nexport default DataService;","map":{"version":3,"names":["Papa","CSV_CONFIG","header","skipEmptyLines","transformHeader","trim","transform","value","fetchPatientCsvData","patientId","response","fetch","Date","getTime","ok","Error","statusText","csvText","text","parsed","parse","errors","length","console","warn","data","error","DataService","getPatientData","patientRows","processedData","processPatientData","rows","firstRow","patientInfo","patientNumber","age","gender","dataAvailable","detailedMedications","conditionsSet","Set","medicationsRaw","map","row","filter","Boolean","forEach","medString","split","med","match","name","detailsStr","details","d","push","schedule","category","dosage","slice","join","conditionsRaw","conditionString","c","add","glucoseData","processGlucoseData","bloodPressureData","processBloodPressureData","exerciseData","processExerciseData","moodData","processMoodData","painData","processPainData","sleepData","processSleepData","mealData","processMealData","conditions","Array","from","rawData","flatMap","baseDate","readings","i","parseFloat","timeStr","hours","minutes","Number","date","setHours","range","measurementType","systolic","parseInt","diastolic","systolicType","diastolicType","exerciseByDate","dateKey","toDateString","walking","aerobic","strength","balance","other","totalMinutes","_row","type","toLowerCase","includes","Object","values","mood","location","level","quality","qualityCode","meals","mealTypes","mealType","contentsStr","contents","s"],"sources":["C:/Users/Matteo/Working_Folder/a. MCC Thesis Local/MCC_digital_health_data_visualizations/src/services/dataService.js"],"sourcesContent":["import Papa from 'papaparse';\n\n// Simplified CSV configuration\nconst CSV_CONFIG = {\n  header: true,\n  skipEmptyLines: true,\n  transformHeader: (header) => header.trim(),\n  transform: (value) => value?.trim(),\n};\n\n// Simplified function to fetch a specific patient's CSV file.\nconst fetchPatientCsvData = async (patientId) => {\n  try {\n    // Fetch individual patient CSV from the public folder\n    const response = await fetch(`/public/synthetic_patients/${patientId}.csv?v=${new Date().getTime()}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV for ${patientId}: ${response.statusText}`);\n    }\n    const csvText = await response.text();\n    const parsed = Papa.parse(csvText, CSV_CONFIG);\n    if (parsed.errors.length > 0) {\n      console.warn(`CSV parsing warnings for ${patientId}:`, parsed.errors);\n    }\n    return parsed.data;\n  } catch (error) {\n    console.error(`Error fetching or parsing CSV for ${patientId}:`, error);\n    throw error;\n  }\n};\n\nclass DataService {\n  /**\n   * Fetches and processes data for a single patient.\n   * This simplified version removes caching and fetches individual patient files.\n   */\n  static async getPatientData(patientId) {\n    try {\n      const patientRows = await fetchPatientCsvData(patientId);\n\n      if (patientRows.length === 0) {\n        throw new Error(`No data found for patient ${patientId}`);\n      }\n\n      // Process and structure the data\n      const processedData = this.processPatientData(patientRows, patientId);\n      return processedData;\n    } catch (error) {\n      console.error('Error fetching patient data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Processes the raw CSV rows for a patient.\n   * This simplified version assumes the new multi-column data format is always present.\n   */\n  static processPatientData(rows, patientId) {\n    const firstRow = rows[0];\n\n    const patientInfo = {\n      patientId,\n      patientNumber: patientId,\n      age: firstRow['Age'],\n      gender: firstRow['Gender'],\n      dataAvailable: 'May 2025'\n    };\n\n    // Process medications\n    const detailedMedications = [];\n    const conditionsSet = new Set();\n    const medicationsRaw = [...new Set(rows.map(row => row['Medications']).filter(Boolean))];\n\n    medicationsRaw.forEach(medString => {\n        medString.split('; ').forEach(med => {\n            const match = med.match(/(.*) \\((.*)\\)/);\n            if (match) {\n                const [, name, detailsStr] = match;\n                const details = detailsStr.split(',').map(d => d.trim());\n                detailedMedications.push({\n                    name,\n                    schedule: details[0] || '',\n                    category: details[1] || '',\n                    dosage: details.slice(2).join(', ') || ''\n                });\n            }\n        });\n    });\n\n    // Process conditions\n    const conditionsRaw = [...new Set(rows.map(row => row['Chronic_Conditions']).filter(Boolean))];\n    conditionsRaw.forEach(conditionString => {\n        conditionString.split(',').forEach(c => conditionsSet.add(c.trim()));\n    });\n\n    // Process all data types\n    const glucoseData = this.processGlucoseData(rows);\n    const bloodPressureData = this.processBloodPressureData(rows);\n    const exerciseData = this.processExerciseData(rows);\n    const moodData = this.processMoodData(rows);\n    const painData = this.processPainData(rows);\n    const sleepData = this.processSleepData(rows);\n    const mealData = this.processMealData(rows);\n\n    return {\n      patientInfo: { \n        ...patientInfo, \n        detailedMedications, \n        conditions: Array.from(conditionsSet)\n      },\n      glucoseData,\n      bloodPressureData,\n      exerciseData,\n      moodData,\n      painData,\n      mealData,\n      sleepData,\n      rawData: rows\n    };\n  }\n\n  static processGlucoseData(rows) {\n    return rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const readings = [];\n      for (let i = 1; i <= 4; i++) {\n        const value = parseFloat(row[`Glucose_${i}`]);\n        const timeStr = row[`Glucose_Time_${i}`];\n        if (value > 0 && timeStr) {\n          const [hours, minutes] = timeStr.split(':').map(Number);\n          const date = new Date(baseDate);\n          date.setHours(hours, minutes);\n          readings.push({\n            date,\n            value,\n            range: row[`Glucose_Range_${i}`],\n            measurementType: row[`Glucose_Measurement_Type_${i}`]\n          });\n        }\n      }\n      return readings;\n    });\n  }\n\n  static processBloodPressureData(rows) {\n    return rows.flatMap(row => {\n        const baseDate = new Date(row['Date']);\n        const readings = [];\n        for (let i = 1; i <= 4; i++) {\n            const systolic = parseInt(row[`Systolic_${i}`]);\n            const diastolic = parseInt(row[`Diastolic_${i}`]);\n            const timeStr = row[`BP_Time_${i}`];\n            if (systolic > 0 && diastolic > 0 && timeStr) {\n                const [hours, minutes] = timeStr.split(':').map(Number);\n                const date = new Date(baseDate);\n                date.setHours(hours, minutes);\n                readings.push({ \n                    date, \n                    systolic, \n                    diastolic, \n                    systolicType: row[`Systolic_Type_${i}`],\n                    diastolicType: row[`Diastolic_Type_${i}`]\n                });\n            }\n        }\n        return readings;\n    });\n  }\n\n  static processExerciseData(rows) {\n    const exerciseByDate = {};\n    rows.forEach(row => {\n        const date = new Date(row['Date']);\n        const dateKey = date.toDateString();\n        if (!exerciseByDate[dateKey]) {\n            exerciseByDate[dateKey] = { date, walking: 0, aerobic: 0, strength: 0, balance: 0, other: 0, totalMinutes: 0 };\n        }\n        for (let i = 1; i <= 3; i++) {\n            const type = row[`Exercise_Type_${i}`]?.toLowerCase();\n            const minutes = parseFloat(row[`Exercise_Minutes_${i}`]);\n            if (type && minutes > 0) {\n                if (type.includes('walking')) exerciseByDate[dateKey].walking += minutes;\n                else if (type.includes('aerobic')) exerciseByDate[dateKey].aerobic += minutes;\n                else if (type.includes('strength')) exerciseByDate[dateKey].strength += minutes;\n                else if (type.includes('balance')) exerciseByDate[dateKey].balance += minutes;\n                else exerciseByDate[dateKey].other += minutes;\n                exerciseByDate[dateKey].totalMinutes += minutes;\n            }\n        }\n    });\n    return Object.values(exerciseByDate).filter(d => d.totalMinutes > 0);\n  }\n\n  static processMoodData(rows) {\n    return rows.filter(row => row['Mood']).map(row => ({\n        date: new Date(row['Date']),\n        mood: row['Mood'],\n        category: row['Mood'] || 'neutral'\n    }));\n  }\n\n  static processPainData(rows) {\n    return rows.filter(row => row['Pain_Location'] && row['Pain_Level']).map(row => ({\n        date: new Date(row['Date']),\n        location: row['Pain_Location'].toLowerCase(),\n        level: parseInt(row['Pain_Level'])\n    }));\n  }\n\n  static processSleepData(rows) {\n    return rows.filter(row => row['Sleep_Hours'] && row['Sleep_Quality']).map(row => ({\n        date: new Date(row['Date']),\n        hours: parseFloat(row['Sleep_Hours']),\n        quality: row['Sleep_Quality'],\n        qualityCode: parseInt(row['Sleep_Quality_Code'])\n    }));\n  }\n\n  static processMealData(rows) {\n    return rows.flatMap(row => {\n      const baseDate = new Date(row['Date']);\n      const meals = [];\n      const mealTypes = ['Breakfast', 'Lunch', 'Dinner'];\n\n      mealTypes.forEach(mealType => {\n        const timeStr = row[`${mealType}_Time`];\n        const contentsStr = row[`${mealType}_Contents`];\n\n        if (timeStr && contentsStr) {\n          const [hours, minutes] = timeStr.split(':').map(Number);\n          const date = new Date(baseDate);\n          date.setHours(hours, minutes);\n\n          const contents = contentsStr.split('-').map(s => s.trim());\n\n          meals.push({\n            date,\n            mealType,\n            contents,\n          });\n        }\n      });\n\n      return meals;\n    });\n  }\n}\n\nexport default DataService;\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,WAAW;;AAE5B;AACA,MAAMC,UAAU,GAAG;EACjBC,MAAM,EAAE,IAAI;EACZC,cAAc,EAAE,IAAI;EACpBC,eAAe,EAAGF,MAAM,IAAKA,MAAM,CAACG,IAAI,CAAC,CAAC;EAC1CC,SAAS,EAAGC,KAAK,IAAKA,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEF,IAAI,CAAC;AACpC,CAAC;;AAED;AACA,MAAMG,mBAAmB,GAAG,MAAOC,SAAS,IAAK;EAC/C,IAAI;IACF;IACA,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,8BAA8BF,SAAS,UAAU,IAAIG,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,EAAE,CAAC;IACrG,IAAI,CAACH,QAAQ,CAACI,EAAE,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAC,2BAA2BN,SAAS,KAAKC,QAAQ,CAACM,UAAU,EAAE,CAAC;IACjF;IACA,MAAMC,OAAO,GAAG,MAAMP,QAAQ,CAACQ,IAAI,CAAC,CAAC;IACrC,MAAMC,MAAM,GAAGnB,IAAI,CAACoB,KAAK,CAACH,OAAO,EAAEhB,UAAU,CAAC;IAC9C,IAAIkB,MAAM,CAACE,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;MAC5BC,OAAO,CAACC,IAAI,CAAC,4BAA4Bf,SAAS,GAAG,EAAEU,MAAM,CAACE,MAAM,CAAC;IACvE;IACA,OAAOF,MAAM,CAACM,IAAI;EACpB,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdH,OAAO,CAACG,KAAK,CAAC,qCAAqCjB,SAAS,GAAG,EAAEiB,KAAK,CAAC;IACvE,MAAMA,KAAK;EACb;AACF,CAAC;AAED,MAAMC,WAAW,CAAC;EAChB;AACF;AACA;AACA;EACE,aAAaC,cAAcA,CAACnB,SAAS,EAAE;IACrC,IAAI;MACF,MAAMoB,WAAW,GAAG,MAAMrB,mBAAmB,CAACC,SAAS,CAAC;MAExD,IAAIoB,WAAW,CAACP,MAAM,KAAK,CAAC,EAAE;QAC5B,MAAM,IAAIP,KAAK,CAAC,6BAA6BN,SAAS,EAAE,CAAC;MAC3D;;MAEA;MACA,MAAMqB,aAAa,GAAG,IAAI,CAACC,kBAAkB,CAACF,WAAW,EAAEpB,SAAS,CAAC;MACrE,OAAOqB,aAAa;IACtB,CAAC,CAAC,OAAOJ,KAAK,EAAE;MACdH,OAAO,CAACG,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,MAAMA,KAAK;IACb;EACF;;EAEA;AACF;AACA;AACA;EACE,OAAOK,kBAAkBA,CAACC,IAAI,EAAEvB,SAAS,EAAE;IACzC,MAAMwB,QAAQ,GAAGD,IAAI,CAAC,CAAC,CAAC;IAExB,MAAME,WAAW,GAAG;MAClBzB,SAAS;MACT0B,aAAa,EAAE1B,SAAS;MACxB2B,GAAG,EAAEH,QAAQ,CAAC,KAAK,CAAC;MACpBI,MAAM,EAAEJ,QAAQ,CAAC,QAAQ,CAAC;MAC1BK,aAAa,EAAE;IACjB,CAAC;;IAED;IACA,MAAMC,mBAAmB,GAAG,EAAE;IAC9B,MAAMC,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC/B,MAAMC,cAAc,GAAG,CAAC,GAAG,IAAID,GAAG,CAACT,IAAI,CAACW,GAAG,CAACC,GAAG,IAAIA,GAAG,CAAC,aAAa,CAAC,CAAC,CAACC,MAAM,CAACC,OAAO,CAAC,CAAC,CAAC;IAExFJ,cAAc,CAACK,OAAO,CAACC,SAAS,IAAI;MAChCA,SAAS,CAACC,KAAK,CAAC,IAAI,CAAC,CAACF,OAAO,CAACG,GAAG,IAAI;QACjC,MAAMC,KAAK,GAAGD,GAAG,CAACC,KAAK,CAAC,eAAe,CAAC;QACxC,IAAIA,KAAK,EAAE;UACP,MAAM,GAAGC,IAAI,EAAEC,UAAU,CAAC,GAAGF,KAAK;UAClC,MAAMG,OAAO,GAAGD,UAAU,CAACJ,KAAK,CAAC,GAAG,CAAC,CAACN,GAAG,CAACY,CAAC,IAAIA,CAAC,CAAClD,IAAI,CAAC,CAAC,CAAC;UACxDkC,mBAAmB,CAACiB,IAAI,CAAC;YACrBJ,IAAI;YACJK,QAAQ,EAAEH,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE;YAC1BI,QAAQ,EAAEJ,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE;YAC1BK,MAAM,EAAEL,OAAO,CAACM,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,IAAI;UAC3C,CAAC,CAAC;QACN;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;;IAEF;IACA,MAAMC,aAAa,GAAG,CAAC,GAAG,IAAIrB,GAAG,CAACT,IAAI,CAACW,GAAG,CAACC,GAAG,IAAIA,GAAG,CAAC,oBAAoB,CAAC,CAAC,CAACC,MAAM,CAACC,OAAO,CAAC,CAAC,CAAC;IAC9FgB,aAAa,CAACf,OAAO,CAACgB,eAAe,IAAI;MACrCA,eAAe,CAACd,KAAK,CAAC,GAAG,CAAC,CAACF,OAAO,CAACiB,CAAC,IAAIxB,aAAa,CAACyB,GAAG,CAACD,CAAC,CAAC3D,IAAI,CAAC,CAAC,CAAC,CAAC;IACxE,CAAC,CAAC;;IAEF;IACA,MAAM6D,WAAW,GAAG,IAAI,CAACC,kBAAkB,CAACnC,IAAI,CAAC;IACjD,MAAMoC,iBAAiB,GAAG,IAAI,CAACC,wBAAwB,CAACrC,IAAI,CAAC;IAC7D,MAAMsC,YAAY,GAAG,IAAI,CAACC,mBAAmB,CAACvC,IAAI,CAAC;IACnD,MAAMwC,QAAQ,GAAG,IAAI,CAACC,eAAe,CAACzC,IAAI,CAAC;IAC3C,MAAM0C,QAAQ,GAAG,IAAI,CAACC,eAAe,CAAC3C,IAAI,CAAC;IAC3C,MAAM4C,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAAC7C,IAAI,CAAC;IAC7C,MAAM8C,QAAQ,GAAG,IAAI,CAACC,eAAe,CAAC/C,IAAI,CAAC;IAE3C,OAAO;MACLE,WAAW,EAAE;QACX,GAAGA,WAAW;QACdK,mBAAmB;QACnByC,UAAU,EAAEC,KAAK,CAACC,IAAI,CAAC1C,aAAa;MACtC,CAAC;MACD0B,WAAW;MACXE,iBAAiB;MACjBE,YAAY;MACZE,QAAQ;MACRE,QAAQ;MACRI,QAAQ;MACRF,SAAS;MACTO,OAAO,EAAEnD;IACX,CAAC;EACH;EAEA,OAAOmC,kBAAkBA,CAACnC,IAAI,EAAE;IAC9B,OAAOA,IAAI,CAACoD,OAAO,CAACxC,GAAG,IAAI;MACzB,MAAMyC,QAAQ,GAAG,IAAIzE,IAAI,CAACgC,GAAG,CAAC,MAAM,CAAC,CAAC;MACtC,MAAM0C,QAAQ,GAAG,EAAE;MACnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC3B,MAAMhF,KAAK,GAAGiF,UAAU,CAAC5C,GAAG,CAAC,WAAW2C,CAAC,EAAE,CAAC,CAAC;QAC7C,MAAME,OAAO,GAAG7C,GAAG,CAAC,gBAAgB2C,CAAC,EAAE,CAAC;QACxC,IAAIhF,KAAK,GAAG,CAAC,IAAIkF,OAAO,EAAE;UACxB,MAAM,CAACC,KAAK,EAAEC,OAAO,CAAC,GAAGF,OAAO,CAACxC,KAAK,CAAC,GAAG,CAAC,CAACN,GAAG,CAACiD,MAAM,CAAC;UACvD,MAAMC,IAAI,GAAG,IAAIjF,IAAI,CAACyE,QAAQ,CAAC;UAC/BQ,IAAI,CAACC,QAAQ,CAACJ,KAAK,EAAEC,OAAO,CAAC;UAC7BL,QAAQ,CAAC9B,IAAI,CAAC;YACZqC,IAAI;YACJtF,KAAK;YACLwF,KAAK,EAAEnD,GAAG,CAAC,iBAAiB2C,CAAC,EAAE,CAAC;YAChCS,eAAe,EAAEpD,GAAG,CAAC,4BAA4B2C,CAAC,EAAE;UACtD,CAAC,CAAC;QACJ;MACF;MACA,OAAOD,QAAQ;IACjB,CAAC,CAAC;EACJ;EAEA,OAAOjB,wBAAwBA,CAACrC,IAAI,EAAE;IACpC,OAAOA,IAAI,CAACoD,OAAO,CAACxC,GAAG,IAAI;MACvB,MAAMyC,QAAQ,GAAG,IAAIzE,IAAI,CAACgC,GAAG,CAAC,MAAM,CAAC,CAAC;MACtC,MAAM0C,QAAQ,GAAG,EAAE;MACnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QACzB,MAAMU,QAAQ,GAAGC,QAAQ,CAACtD,GAAG,CAAC,YAAY2C,CAAC,EAAE,CAAC,CAAC;QAC/C,MAAMY,SAAS,GAAGD,QAAQ,CAACtD,GAAG,CAAC,aAAa2C,CAAC,EAAE,CAAC,CAAC;QACjD,MAAME,OAAO,GAAG7C,GAAG,CAAC,WAAW2C,CAAC,EAAE,CAAC;QACnC,IAAIU,QAAQ,GAAG,CAAC,IAAIE,SAAS,GAAG,CAAC,IAAIV,OAAO,EAAE;UAC1C,MAAM,CAACC,KAAK,EAAEC,OAAO,CAAC,GAAGF,OAAO,CAACxC,KAAK,CAAC,GAAG,CAAC,CAACN,GAAG,CAACiD,MAAM,CAAC;UACvD,MAAMC,IAAI,GAAG,IAAIjF,IAAI,CAACyE,QAAQ,CAAC;UAC/BQ,IAAI,CAACC,QAAQ,CAACJ,KAAK,EAAEC,OAAO,CAAC;UAC7BL,QAAQ,CAAC9B,IAAI,CAAC;YACVqC,IAAI;YACJI,QAAQ;YACRE,SAAS;YACTC,YAAY,EAAExD,GAAG,CAAC,iBAAiB2C,CAAC,EAAE,CAAC;YACvCc,aAAa,EAAEzD,GAAG,CAAC,kBAAkB2C,CAAC,EAAE;UAC5C,CAAC,CAAC;QACN;MACJ;MACA,OAAOD,QAAQ;IACnB,CAAC,CAAC;EACJ;EAEA,OAAOf,mBAAmBA,CAACvC,IAAI,EAAE;IAC/B,MAAMsE,cAAc,GAAG,CAAC,CAAC;IACzBtE,IAAI,CAACe,OAAO,CAACH,GAAG,IAAI;MAChB,MAAMiD,IAAI,GAAG,IAAIjF,IAAI,CAACgC,GAAG,CAAC,MAAM,CAAC,CAAC;MAClC,MAAM2D,OAAO,GAAGV,IAAI,CAACW,YAAY,CAAC,CAAC;MACnC,IAAI,CAACF,cAAc,CAACC,OAAO,CAAC,EAAE;QAC1BD,cAAc,CAACC,OAAO,CAAC,GAAG;UAAEV,IAAI;UAAEY,OAAO,EAAE,CAAC;UAAEC,OAAO,EAAE,CAAC;UAAEC,QAAQ,EAAE,CAAC;UAAEC,OAAO,EAAE,CAAC;UAAEC,KAAK,EAAE,CAAC;UAAEC,YAAY,EAAE;QAAE,CAAC;MAClH;MACA,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QAAA,IAAAwB,IAAA;QACzB,MAAMC,IAAI,IAAAD,IAAA,GAAGnE,GAAG,CAAC,iBAAiB2C,CAAC,EAAE,CAAC,cAAAwB,IAAA,uBAAzBA,IAAA,CAA2BE,WAAW,CAAC,CAAC;QACrD,MAAMtB,OAAO,GAAGH,UAAU,CAAC5C,GAAG,CAAC,oBAAoB2C,CAAC,EAAE,CAAC,CAAC;QACxD,IAAIyB,IAAI,IAAIrB,OAAO,GAAG,CAAC,EAAE;UACrB,IAAIqB,IAAI,CAACE,QAAQ,CAAC,SAAS,CAAC,EAAEZ,cAAc,CAACC,OAAO,CAAC,CAACE,OAAO,IAAId,OAAO,CAAC,KACpE,IAAIqB,IAAI,CAACE,QAAQ,CAAC,SAAS,CAAC,EAAEZ,cAAc,CAACC,OAAO,CAAC,CAACG,OAAO,IAAIf,OAAO,CAAC,KACzE,IAAIqB,IAAI,CAACE,QAAQ,CAAC,UAAU,CAAC,EAAEZ,cAAc,CAACC,OAAO,CAAC,CAACI,QAAQ,IAAIhB,OAAO,CAAC,KAC3E,IAAIqB,IAAI,CAACE,QAAQ,CAAC,SAAS,CAAC,EAAEZ,cAAc,CAACC,OAAO,CAAC,CAACK,OAAO,IAAIjB,OAAO,CAAC,KACzEW,cAAc,CAACC,OAAO,CAAC,CAACM,KAAK,IAAIlB,OAAO;UAC7CW,cAAc,CAACC,OAAO,CAAC,CAACO,YAAY,IAAInB,OAAO;QACnD;MACJ;IACJ,CAAC,CAAC;IACF,OAAOwB,MAAM,CAACC,MAAM,CAACd,cAAc,CAAC,CAACzD,MAAM,CAACU,CAAC,IAAIA,CAAC,CAACuD,YAAY,GAAG,CAAC,CAAC;EACtE;EAEA,OAAOrC,eAAeA,CAACzC,IAAI,EAAE;IAC3B,OAAOA,IAAI,CAACa,MAAM,CAACD,GAAG,IAAIA,GAAG,CAAC,MAAM,CAAC,CAAC,CAACD,GAAG,CAACC,GAAG,KAAK;MAC/CiD,IAAI,EAAE,IAAIjF,IAAI,CAACgC,GAAG,CAAC,MAAM,CAAC,CAAC;MAC3ByE,IAAI,EAAEzE,GAAG,CAAC,MAAM,CAAC;MACjBc,QAAQ,EAAEd,GAAG,CAAC,MAAM,CAAC,IAAI;IAC7B,CAAC,CAAC,CAAC;EACL;EAEA,OAAO+B,eAAeA,CAAC3C,IAAI,EAAE;IAC3B,OAAOA,IAAI,CAACa,MAAM,CAACD,GAAG,IAAIA,GAAG,CAAC,eAAe,CAAC,IAAIA,GAAG,CAAC,YAAY,CAAC,CAAC,CAACD,GAAG,CAACC,GAAG,KAAK;MAC7EiD,IAAI,EAAE,IAAIjF,IAAI,CAACgC,GAAG,CAAC,MAAM,CAAC,CAAC;MAC3B0E,QAAQ,EAAE1E,GAAG,CAAC,eAAe,CAAC,CAACqE,WAAW,CAAC,CAAC;MAC5CM,KAAK,EAAErB,QAAQ,CAACtD,GAAG,CAAC,YAAY,CAAC;IACrC,CAAC,CAAC,CAAC;EACL;EAEA,OAAOiC,gBAAgBA,CAAC7C,IAAI,EAAE;IAC5B,OAAOA,IAAI,CAACa,MAAM,CAACD,GAAG,IAAIA,GAAG,CAAC,aAAa,CAAC,IAAIA,GAAG,CAAC,eAAe,CAAC,CAAC,CAACD,GAAG,CAACC,GAAG,KAAK;MAC9EiD,IAAI,EAAE,IAAIjF,IAAI,CAACgC,GAAG,CAAC,MAAM,CAAC,CAAC;MAC3B8C,KAAK,EAAEF,UAAU,CAAC5C,GAAG,CAAC,aAAa,CAAC,CAAC;MACrC4E,OAAO,EAAE5E,GAAG,CAAC,eAAe,CAAC;MAC7B6E,WAAW,EAAEvB,QAAQ,CAACtD,GAAG,CAAC,oBAAoB,CAAC;IACnD,CAAC,CAAC,CAAC;EACL;EAEA,OAAOmC,eAAeA,CAAC/C,IAAI,EAAE;IAC3B,OAAOA,IAAI,CAACoD,OAAO,CAACxC,GAAG,IAAI;MACzB,MAAMyC,QAAQ,GAAG,IAAIzE,IAAI,CAACgC,GAAG,CAAC,MAAM,CAAC,CAAC;MACtC,MAAM8E,KAAK,GAAG,EAAE;MAChB,MAAMC,SAAS,GAAG,CAAC,WAAW,EAAE,OAAO,EAAE,QAAQ,CAAC;MAElDA,SAAS,CAAC5E,OAAO,CAAC6E,QAAQ,IAAI;QAC5B,MAAMnC,OAAO,GAAG7C,GAAG,CAAC,GAAGgF,QAAQ,OAAO,CAAC;QACvC,MAAMC,WAAW,GAAGjF,GAAG,CAAC,GAAGgF,QAAQ,WAAW,CAAC;QAE/C,IAAInC,OAAO,IAAIoC,WAAW,EAAE;UAC1B,MAAM,CAACnC,KAAK,EAAEC,OAAO,CAAC,GAAGF,OAAO,CAACxC,KAAK,CAAC,GAAG,CAAC,CAACN,GAAG,CAACiD,MAAM,CAAC;UACvD,MAAMC,IAAI,GAAG,IAAIjF,IAAI,CAACyE,QAAQ,CAAC;UAC/BQ,IAAI,CAACC,QAAQ,CAACJ,KAAK,EAAEC,OAAO,CAAC;UAE7B,MAAMmC,QAAQ,GAAGD,WAAW,CAAC5E,KAAK,CAAC,GAAG,CAAC,CAACN,GAAG,CAACoF,CAAC,IAAIA,CAAC,CAAC1H,IAAI,CAAC,CAAC,CAAC;UAE1DqH,KAAK,CAAClE,IAAI,CAAC;YACTqC,IAAI;YACJ+B,QAAQ;YACRE;UACF,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MAEF,OAAOJ,KAAK;IACd,CAAC,CAAC;EACJ;AACF;AAEA,eAAe/F,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}