{"ast":null,"code":"import _objectSpread from\"C:/Users/Matteo/Working_Folder/a. MCC Thesis Local Experimental/PGHD_Visualization_Dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/*\n dataService.js - Patient Data Service\n \n This service handles all data operations for the health dashboard:\n - Fetches patient CSV data from the server\n - Parses and processes CSV data using PapaParse\n - Transforms raw data into structured health metrics\n - Provides data validation and error handling\n - Manages patient information, medications, and health tracking data\n - Supports all health metric types (glucose, BP, exercise, mood, pain, sleep, meals)\n \n Architecture:\n - Uses PapaParse library for CSV parsing\n - Implements service class pattern for data operations\n - Provides comprehensive error handling and validation\n - Supports multiple data formats and structures\n \n Data Processing:\n - CSV parsing with header validation\n - Data transformation and normalization\n - Type conversion and validation\n - Error recovery and fallback mechanisms\n \n Health Metrics Supported:\n - Blood glucose monitoring with meal context\n - Blood pressure tracking with risk categorization\n - Exercise activity tracking and categorization\n - Mood assessment and tracking\n - Pain reporting with anatomical mapping\n - Sleep quality and duration analysis\n - Nutritional intake and meal composition\n \n Error Handling:\n - Network error recovery\n - CSV parsing error handling\n - Data validation and sanitization\n - Graceful degradation for missing data\n \n Core service for data management and processing throughout the application.\n */import Papa from'papaparse';// Configuration for CSV parsing\nconst CSV_CONFIG={header:true,skipEmptyLines:true,transformHeader:header=>(header===null||header===void 0?void 0:header.trim())||'',transform:value=>(value===null||value===void 0?void 0:value.trim())||'',dynamicTyping:false,// Keep everything as strings to avoid parsing issues\ndelimiter:',',quoteChar:'\"',escapeChar:'\"'};/*\n Fetches and parses CSV data for a specific patient\n \n - @param {string} patientId - The patient identifier\n - @returns {Promise<Array>} Parsed CSV data as array of objects\n - @throws {Error} If CSV fetch or parsing fails\n */const fetchPatientCsvData=async patientId=>{try{// Add cache busting to ensure fresh data\nconst baseUrl=process.env.NODE_ENV==='production'?'https://matteo567.github.io/PGHD_Visualization_Dashboard':'';const response=await fetch(\"\".concat(baseUrl,\"/synthetic_patients/\").concat(patientId,\".csv?v=\").concat(Date.now()));if(!response.ok){throw new Error(\"Failed to fetch CSV for \".concat(patientId,\": \").concat(response.status,\" \").concat(response.statusText));}const csvText=await response.text();if(!csvText||csvText.trim().length===0){throw new Error(\"Empty CSV file for patient \".concat(patientId));}const parsed=Papa.parse(csvText,CSV_CONFIG);if(parsed.errors.length>0){// Log parsing errors for debugging but don't throw (only in development)\nif(process.env.NODE_ENV==='development'){console.warn(\"CSV parsing warnings for \".concat(patientId,\":\"),parsed.errors);}}return parsed.data;}catch(error){if(process.env.NODE_ENV==='development'){console.error(\"Error fetching or parsing CSV for \".concat(patientId,\":\"),error);}throw error;}};/*\n Service class for handling patient data operations\n Provides methods for fetching and processing patient health data from CSV files\n *//*\n| Retrieves and processes all data for a specific patient\n| \n| @param {string} patientId - The patient identifier\n| @returns {Promise<Object>} Processed patient data including all health metrics\n| @throws {Error} If patient data cannot be retrieved or processed\n| */export async function getPatientData(patientId){if(!patientId){throw new Error('Patient ID is required');}try{const patientRows=await fetchPatientCsvData(patientId);if(!Array.isArray(patientRows)||patientRows.length===0){throw new Error(\"No data found for patient \".concat(patientId));}return processPatientData(patientRows,patientId);}catch(error){if(process.env.NODE_ENV==='development'){console.error(\"Error fetching patient data for \".concat(patientId,\":\"),error);}throw error;}}/**\n * Processes raw CSV data into structured patient information and health metrics\n * \n * - @param {Array} rows - Raw CSV data rows\n * - @param {string} patientId - The patient identifier\n * - @returns {Object} Structured patient data object\n * - @throws {Error} If data structure is invalid or processing fails\n */export function processPatientData(rows,patientId){if(!Array.isArray(rows)||rows.length===0){throw new Error(\"Invalid data structure for patient \".concat(patientId));}const firstRowData=rows[0];if(!firstRowData){throw new Error(\"No valid data rows found for patient \".concat(patientId));}const patientInfo={patientId,patientNumber:patientId,name:firstRowData['Name']||'Not specified',age:firstRowData['Age']||'Not specified',gender:firstRowData['Gender']||'Not specified',dataAvailable:'May 2025'};// Process medications using the cleaner individual medication fields\nconst detailedMedications=[];// Get medication data from the first row (should be consistent across all rows for a patient)\nconst medicationNamesStr=firstRowData['Medication_Names']||'';const medicationTypesStr=firstRowData['Medication_Types']||'';const medicationCategoriesStr=firstRowData['Medication_Categories']||'';const medicationDosagesStr=firstRowData['Medication_Dosages']||'';// Split the semicolon-separated strings into arrays\nconst medicationNames=medicationNamesStr?medicationNamesStr.split('; ').filter(Boolean):[];const medicationTypes=medicationTypesStr?medicationTypesStr.split('; ').filter(Boolean):[];const medicationCategories=medicationCategoriesStr?medicationCategoriesStr.split('; ').filter(Boolean):[];const medicationDosages=medicationDosagesStr?medicationDosagesStr.split('; ').filter(Boolean):[];// Process each medication\nfor(let i=0;i<Math.max(medicationNames.length,medicationTypes.length,medicationCategories.length,medicationDosages.length);i++){const name=medicationNames[i]||'';const type=medicationTypes[i]||'';const category=medicationCategories[i]||'';const dosage=medicationDosages[i]||'';if(name&&name.trim()&&!name.includes('Dose not specified')&&name.length<100&&// Filter out extremely long medication names\n!name.includes('Folic Acid Iron Magnesium Calcium Pain and Inflammation')){detailedMedications.push({name:name.trim(),schedule:dosage.trim(),// Use dosage as schedule\ncategory:'',// Don't include category in visualization\ndosage:''});}}// Process conditions\nconst conditionsSet=new Set();const conditionsRaw=[...new Set(rows.map(row=>row['Chronic_Conditions']||row['Conditions']).filter(Boolean))];conditionsRaw.forEach(conditionString=>{conditionString.split(';').forEach(c=>conditionsSet.add(c.trim()));});// Process all data types\nconst glucoseData=processGlucoseData(rows);const bloodPressureData=processBloodPressureData(rows);const exerciseData=processExerciseData(rows);const moodData=processMoodData(rows);const painData=processPainData(rows);const sleepData=processSleepData(rows);const mealData=processMealData(rows);return{patientInfo:_objectSpread(_objectSpread({},patientInfo),{},{detailedMedications,conditions:Array.from(conditionsSet)}),glucoseData,bloodPressureData,exerciseData,moodData,painData,mealData,sleepData,rawData:rows};}// Helper functions for glucose data processing\nfunction parseTimeString(timeStr){if(!timeStr||typeof timeStr!=='string'||!timeStr.includes(':')){return{hours:0,minutes:0};}const timeParts=timeStr.split(':');if(timeParts.length<2){return{hours:0,minutes:0};}const hours=parseInt(timeParts[0],10);const minutes=parseInt(timeParts[1],10);return{hours:isNaN(hours)?0:hours,minutes:isNaN(minutes)?0:minutes};}function createGlucoseReading(baseDate,value,timeStr,range,measurementType){const{hours,minutes}=parseTimeString(timeStr);const date=new Date(baseDate);date.setHours(hours,minutes);return{date:date,value:value,range:range,measurementType:measurementType};}function processMultiColumnGlucose(row,baseDate){const readings=[];for(let i=1;i<=4;i++){const value=parseFloat(row[\"Glucose_\".concat(i)]);const timeStr=row[\"Glucose_Time_\".concat(i)];if(value>0&&timeStr){const reading=createGlucoseReading(baseDate,value,timeStr,row[\"Glucose_Range_\".concat(i)],row[\"Glucose_Measurement_Type_\".concat(i)]);readings.push(reading);}}return readings;}function processSingleColumnGlucose(row,baseDate){const value=parseFloat(row['Glucose_Level']);if(value>0){const randomHour=Math.floor(Math.random()*24);const randomMinute=Math.floor(Math.random()*60);const date=new Date(baseDate);date.setHours(randomHour,randomMinute);let range='in range';if(value<70)range='below range';else if(value>180)range='above range';return[{date:date,value:value,range:range,measurementType:'Random'}];}return[];}/**\n * Processes blood glucose data from CSV rows\n */export function processGlucoseData(rows){const readings=[];rows.forEach(row=>{const baseDate=new Date(row['Date']);const hasMultiColumn=row['Glucose_1']!==undefined;if(hasMultiColumn){readings.push(...processMultiColumnGlucose(row,baseDate));}else{readings.push(...processSingleColumnGlucose(row,baseDate));}});return readings;}/**\n * Processes blood pressure data from CSV rows\n */export function processBloodPressureData(rows){const readings=[];for(let rowIndex=0;rowIndex<rows.length;rowIndex++){const row=rows[rowIndex];const baseDate=new Date(row['Date']);const hasMultiColumn=row['Systolic_1']!==undefined;if(hasMultiColumn){// Process up to 4 readings per day\nfor(let i=1;i<=4;i++){const systolic=parseInt(row[\"Systolic_\".concat(i)]);const diastolic=parseInt(row[\"Diastolic_\".concat(i)]);const timeStr=row[\"BP_Time_\".concat(i)];if(systolic>0&&diastolic>0&&timeStr){const timeParts=timeStr.split(':');if(timeParts.length>=2){const hours=parseInt(timeParts[0],10);const minutes=parseInt(timeParts[1],10);if(!isNaN(hours)&&!isNaN(minutes)){const date=new Date(baseDate);date.setHours(hours,minutes);readings.push({date:date,systolic:systolic,diastolic:diastolic,systolicType:row[\"Systolic_Type_\".concat(i)],diastolicType:row[\"Diastolic_Type_\".concat(i)]});}}}}}else{// Single reading format\nconst systolic=parseInt(row['Systolic_BP']);const diastolic=parseInt(row['Diastolic_BP']);if(systolic>0&&diastolic>0){const randomHour=Math.floor(Math.random()*24);const randomMinute=Math.floor(Math.random()*60);const date=new Date(baseDate);date.setHours(randomHour,randomMinute);let systolicType='normal';let diastolicType='normal';if(systolic>=180||diastolic>=120){systolicType='hypertensive crisis';diastolicType='hypertensive crisis';}else if(systolic>=140||diastolic>=90){systolicType='high';diastolicType='high';}else if(systolic>=130||diastolic>=80){systolicType='elevated';diastolicType='elevated';}readings.push({date:date,systolic:systolic,diastolic:diastolic,systolicType:systolicType,diastolicType:diastolicType});}}}return readings;}/**\n * Processes exercise data from CSV rows\n * \n * - @param {Array} rows - CSV data rows\n * - @returns {Array} Processed exercise data with activity types and durations\n */export function processExerciseData(rows){const exerciseByDate={};rows.forEach(row=>{const date=new Date(row['Date']);const dateKey=date.toDateString();if(!exerciseByDate[dateKey]){exerciseByDate[dateKey]={date,walking:0,swimming:0,running:0,biking:0,'muscle-strengthening':0,balance:0,other:0,totalMinutes:0};}const hasMultiColumn=row['Exercise_Type_1']!==undefined;if(hasMultiColumn){for(let i=1;i<=5;i++){var _row;const type=(_row=row[\"Exercise_Type_\".concat(i)])===null||_row===void 0?void 0:_row.toLowerCase();const minutes=parseFloat(row[\"Exercise_Minutes_\".concat(i)]);if(type&&minutes>0){categorizeExercise(type,minutes,exerciseByDate[dateKey]);}}}else{var _row$Exercise_Type;const type=(_row$Exercise_Type=row['Exercise_Type'])===null||_row$Exercise_Type===void 0?void 0:_row$Exercise_Type.toLowerCase();const minutes=parseFloat(row['Exercise_Minutes']);if(type&&minutes>0){categorizeExercise(type,minutes,exerciseByDate[dateKey]);}}});return Object.values(exerciseByDate).filter(d=>d.totalMinutes>0);}/**\n * Categorizes exercise activities into predefined types\n * \n * - @param {string} type - Exercise type from CSV\n * - @param {number} minutes - Duration in minutes\n * - @param {Object} dayData - Daily exercise data object\n */export function categorizeExercise(type,minutes,dayData){if(type.includes('walking'))dayData.walking+=minutes;else if(type.includes('swimming'))dayData.swimming+=minutes;else if(type.includes('running'))dayData.running+=minutes;else if(type.includes('biking'))dayData.biking+=minutes;else if(type.includes('muscle-strengthening')||type.includes('muscle strengthening')||type.includes('strength'))dayData['muscle-strengthening']+=minutes;else if(type.includes('balance'))dayData.balance+=minutes;else dayData.other+=minutes;dayData.totalMinutes+=minutes;}/**\n * Processes mood data from CSV rows\n */export function processMoodData(rows){const moodData=[];for(let i=0;i<rows.length;i++){const row=rows[i];if(row['Mood']){moodData.push({date:new Date(row['Date']),mood:row['Mood'],category:row['Mood']||'neutral'});}}return moodData;}/**\n * Processes pain data from CSV rows\n */export function processPainData(rows){const painData=[];for(let i=0;i<rows.length;i++){const row=rows[i];if(row['Pain_Location']&&row['Pain_Level']){painData.push({date:new Date(row['Date']),location:row['Pain_Location'].toLowerCase(),level:parseInt(row['Pain_Level'])});}}return painData;}/**\n * Processes sleep data from CSV rows\n */export function processSleepData(rows){const sleepData=[];for(let i=0;i<rows.length;i++){const row=rows[i];if(row['Sleep_Hours']&&row['Sleep_Quality']){sleepData.push({date:new Date(row['Date']),hours:parseFloat(row['Sleep_Hours']),quality:row['Sleep_Quality'],qualityCode:parseInt(row['Sleep_Quality_Code'])});}}return sleepData;}/**\n * Processes meal data from CSV rows\n */export function processMealData(rows){const filteredRows=[];for(let i=0;i<rows.length;i++){const row=rows[i];const mealTypes=['Breakfast','Lunch','Dinner','Late Night Snack'];let hasMealData=false;// Check each meal type\nfor(let j=0;j<mealTypes.length;j++){const mealType=mealTypes[j];const time=row[\"\".concat(mealType,\"_Time\")];const protein=row[\"\".concat(mealType,\"_Protein\")];const carbs=row[\"\".concat(mealType,\"_Carbohydrates\")];const vegetables=row[\"\".concat(mealType,\"_Vegetables\")];const fruit=row[\"\".concat(mealType,\"_Fruit\")];const alcohol=row[\"\".concat(mealType,\"_Alcohol\")];const sugar=row[\"\".concat(mealType,\"_Added_Sugar\")];// Check if time exists and at least one food component is present\nconst hasFood=protein===1||protein==='1'||carbs===1||carbs==='1'||vegetables===1||vegetables==='1'||fruit===1||fruit==='1'||alcohol===1||alcohol==='1'||sugar&&sugar!==''&&sugar!=='NaN';if(time&&hasFood){hasMealData=true;break;}}if(hasMealData){filteredRows.push(row);}}return filteredRows;}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}